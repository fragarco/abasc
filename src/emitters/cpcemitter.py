"""
Translates intermediate code generated by the parser
to Amstrad CPC Z80 Assembly language in Maxam/WinAPE style.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation in its version 3.

This program is distributed in the hope that it will be useful
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

Functions and Commands comments are taken from:
https://www.grimware.org/doku.php/documentations/software/locomotive.basic/start
and are not covered by the above license statement.
"""

from __future__ import annotations
from typing import cast, NoReturn
from enum import Enum
from baspp import CodeLine
from baserror import BasError
from baserror import WarningLevel as WL
from symbols import SymTable, SymEntry, SymType
import astlib as AST
from .cpcrt import FWCALL, RT

class DataSec(str, Enum):
    """ Nodes related to sections of data """
    GEN = "General",
    VARS = "Variables",
    DATA = "DataBlock",
    CONST = "Constants"

class CPCEmitter:
    def __init__(self, code: list[CodeLine], program: AST.Program, symtable: SymTable) -> None:
        self.source = code
        self.program = program
        self.symtable = symtable
        
        self.warning_level = WL.ALL
        self.verbose = False
        self.dataaddr = 0x4000
        self.startaddr = 0x040
        self.symbolafter = 9999
        self.memlimit = 99999

        self.context = ""
        self.headcode = ""
        self.startupcode = ""
        self.heapcode = ""
        self.srccode = ""
        self.codestack: list[str] = []
        self.data: dict[DataSec,str] = {
            DataSec.GEN: "",
            DataSec.VARS: "",
            DataSec.DATA: "",
            DataSec.CONST: ""
        }
        self.rtcode: str = ""
        self.rtvars: str = ""
        self.runtime: list[str] = []

        self.constants: int = 0
        self.issued_str_constants: dict[str,str] = {}
        self.issued_real_constants: dict[str,str] = {}
        self.free_heap_memory: bool = False
        self.reserved_heap_memory: int = 0
        self.max_heap_memory: int = 0
        self.heapstack: list[tuple[int, int, bool]] = []
        self.forloops: list[AST.ForLoop] = []
        self.wloops: list[AST.WhileLoop] = []
        self.ifblocks: list[AST.If] = []
        self.selectblocks: list[AST.SelectCase] = []

    def cfgset_wlevel(self, wlevel: WL) -> None:
        self.warning_level = wlevel
    
    def cfgset_verbose(self, verbose: bool) -> None:
        self.verbose = verbose

    def cfgset_dataaddr(self, dataaddr: int) -> None:
        self.dataaddr = dataaddr

    def cfgset_startaddr(self, startaddr: int) -> None:
        self.startaddr = startaddr

    def _emit_prepare_line(self, line: str, indent: int, info: str) -> str:
        pad = ""
        for _ in range(indent): pad = pad + " "
        line = f"{pad}{line}"
        if info != "":
            line = f"{line:<30}; {info}"
        return line

    def _emit_head(self, line: str="", indent: int=4, info: str="") -> None:
        line = self._emit_prepare_line(line, indent, info)
        self.headcode = self.headcode + line + "\n"

    def _emit_startup(self, line: str="", indent: int=4, info: str="") -> None:
        line = self._emit_prepare_line(line, indent, info)
        self.startupcode = self.startupcode + line + "\n"

    def _emit_heap(self, line: str="", indent: int=4, info: str="") -> None:
        line = self._emit_prepare_line(line, indent, info)
        self.heapcode = self.heapcode + line + "\n"

    def _emit_code(self, line: str="", indent: int=4, info: str="") -> None:
        """ Pure comments are added only if we are in verbose mode """
        if self.verbose or line == "" or line[0] != ";":
            line = self._emit_prepare_line(line, indent, info)
            self.srccode = self.srccode + line + "\n"

    def _emit_data(self, line: str="", indent: int=4, info: str="", section: DataSec=DataSec.GEN) -> None:
        line = self._emit_prepare_line(line,indent, info)
        self.data[section] = self.data[section] + line +"\n"

    def _emit_line_label(self, line: AST.Line) -> None:
        sym = self.symtable.find(str(line.number), SymType.Label, "")
        if sym is not None:
            codeline = self.source[line.line-1]
            self._emit_code(f"{sym.label}:", info=codeline.code)
        else:
            self._raise_error(2, line)

    def _emit_import(self, fname: str) -> bool:
        if fname not in self.runtime:
            self.runtime.append(fname)
            depends, datavars, fcode = RT[fname]
            for dep in depends:
                self._emit_import(dep)
            self.rtcode = self.rtcode + fcode
            self.rtvars = self.rtvars + datavars
            return True
        return False

    def _emit_push_memheap(self) -> None:      
        self._emit_code("ld      hl,(rt_heapmem_start)")
        self._emit_code("push    hl", info="store current heap memory start address")
        self._emit_code("ld      hl,(rt_heapmem_next)")
        self._emit_code("ld      (rt_heapmem_start),hl")

    def _emit_pop_memheap(self) -> None:
        self._emit_free_heapmem()
        self._emit_code("pop     hl")
        self._emit_code("ld      (rt_heapmem_start),hl")

    def _push_heapvalues(self) -> None:
        self.heapstack.append((
            self.max_heap_memory,
            self.reserved_heap_memory,
            self.free_heap_memory
        ))
        self.max_heap_memory = 0
        self.reserved_heap_memory = 0
        self.free_heap_memory = False

    def _pop_heapvalues(self) -> None:
        values = self.heapstack.pop()
        self.max_heap_memory = values[0]
        self.reserved_heap_memory = values[1]
        self.free_heap_memory = values[2]

    def _emit_free_heapmem(self) -> None:
        if self.free_heap_memory:
            self._emit_code("call    rt_free_all", info=f"free ({self.reserved_heap_memory} bytes of heap memory")
            self.free_heap_memory = False
            self.reserved_heap_memory = 0

    def _reserve_heapmem(self, nbytes: int, node: AST.ASTNode) -> None:
        self._emit_import("rt_malloc")
        self._emit_code(f"ld      bc,{nbytes}", info="bytes to reserve")
        self._emit_code("call    rt_malloc", info="HL points to heap memory")
        self.free_heap_memory = True
        self.reserved_heap_memory += nbytes
        self._check_heapmem()

    def _reserve_heapmem_de(self, nbytes: int, node: AST.ASTNode) -> None:
        self._emit_import("rt_malloc_de")
        self._emit_code(f"ld      bc,{nbytes}", info="bytes to reserve")
        self._emit_code("call    rt_malloc_de", info="DE points to heap memory")
        self.free_heap_memory = True
        self.reserved_heap_memory += nbytes
        self._check_heapmem()

    def _check_heapmem(self) -> None:
        if self.reserved_heap_memory > self.max_heap_memory:
            self.max_heap_memory = self.reserved_heap_memory

    def _emit_pushcontext(self) -> None:
        if self.context != "":
            self._emit_code("push    ix")

    def _emit_popcontext(self) -> None:
        if self.context != "":
            self._emit_code("pop     ix")

    def _moveflo_accum1(self) -> None:
        """ Moves real number in (HL) to rt_math_accum1"""
        self._emit_import("rt_move_real")
        self._emit_code("ld      de,rt_math_accum1")
        self._emit_code("call    rt_move_real", info="REAL to rt_math_accum1")

    def _moveflo_accum2(self) -> None:
        """ Moves real number in (HL) to rt_math_accum2"""
        self._emit_import("rt_move_real")
        self._emit_code("ld      de,rt_math_accum2")
        self._emit_code("call    rt_move_real", info="REAL to rt_math_accum2")

    def _moveflo_heap(self, node: AST.ASTNode) -> None:
        """ 
        Copies the current float number pointed by HL to a new
        temporal memory location (heap). Returns in Hl that address. 
        """
        self._emit_import("rt_move_real")
        self._reserve_heapmem_de(5, node)
        self._emit_code("call    rt_move_real", info="REAL to heap memory")

    def _emit_preamble(self) -> None:
        self._emit_head("; FILE GENERATED BY ABASC COMPILER", 0)
        self._emit_head("; DESIGNED TO BE ASSEMBLED BY ABASM", 0)
        self._emit_head(";", 0)
        self._emit_head("$LIMIT$", 0)
        self._emit_head(f"org  &{hex(self.startaddr)[2:]}", 0)
        self._emit_head("jp   _startup_", 0)
        self._emit_head()
    
        self._emit_startup("; PROGRAM MAIN", 0)
        self._emit_startup(f"_startup_:", 0)

        self._emit_data("; DATA must be allocated outside of Firmware memory area", 0)
        self._emit_data(f"if ($ < &{hex(self.dataaddr)[2:]})", 0)
        self._emit_data(f"org  &{hex(self.dataaddr)[2:]}")
        self._emit_data("endif", 0)
        self._emit_data("_data_:", 0) 

    def _emit_code_end(self) -> None:
        self._emit_code()
        self._emit_code("_code_end_: jr _code_end_", info="infinite end loop", indent=0)

    def _emit_heap_def(self) -> None:
        self._emit_heap("; DYNAMIC MEMORY AREA (HEAP), USED BY MALLOC AND FREE", 0)
        self._emit_heap("rt_heapmem_next:  dw rt_heapmem", 0, info="pointer to free memory for dynamic allocation")
        self._emit_heap("rt_heapmem_start: dw rt_heapmem", 0, info="reserved area for dynamic allocated memory")
        self._emit_heap(f"rt_heapmem:       defs {self.max_heap_memory}", 0, info="reserved area for dynamic allocated memory")
        self._emit_heap("rt_heapmem_end:   db &DE,&AD", 0, info="DEAD mark")
        self._emit_heap()
    
    def _emit_amsdos_support(self) -> None:
        if "rt_restoreroms" in self.runtime:
            self._emit_startup("call    rt_restoreroms")
            self._emit_startup("_restoreroms_end:", 0)

    def _emit_symbols(self, syms: dict[str, SymEntry], parent: SymEntry | None = None) -> None:
        for sym in syms:
            entry = syms[sym]
            if entry.label[0:2] == "G_" and parent is not None:
                # This is a global variable included in a Function or Sub context
                # with SHARED
                continue
            if entry.symtype == SymType.Variable:
                # optimized constant variables must not be added
                if entry.writes != 1 or entry.const is None:
                    self._emit_vardecl(entry)
            elif entry.symtype == SymType.Array:
                self._emit_arraydecl(entry)
            elif entry.symtype == SymType.Param or entry.symtype == SymType.ArrayParam:
                pass   # we will access params directly from the call stack frame
            elif entry.symtype == SymType.RSX:
                # last char must have bit 7 set and we have to remove RSX_
                lastchar = ord(sym[-1]) + 128
                self._emit_data(f'{entry.label}: db "{sym[4:-1]}",{lastchar}')
            elif entry.symtype == SymType.Function:
                self._emit_symbols(entry.locals.syms, entry)
            elif entry.symtype == SymType.Procedure:
                self._emit_symbols(entry.locals.syms, entry)

    def _emit_vardecl(self, entry: SymEntry) -> None:
        self._emit_data(f"{entry.label}: defs {entry.datasz}", section=DataSec.VARS)

    def _emit_arraydecl(self, entry: SymEntry) -> None:
        items = 1
        # index starts in 0 and DIM sets the last usable index
        # so number of items = max index + 1
        for index in entry.indexes: items = items * (index + 1)
        memsz = entry.datasz * items
        self._emit_data(f"{entry.label}: defs {memsz}", section=DataSec.VARS)

    def _emit_runtime(self) -> str:
        return "_runtime_:\n\n" + self.rtcode + '\n' + "_runtime_end_:\n\n"
    
    def _emit_symbol_table(self) -> None:
        # 240 is the BASIC default if no SYMBOL AFTER is used
        if self.symbolafter == 9999:
            # Default SYMBOL AFTER of 240 if this command has not been used
            self.symbolafter = 240
            self._emit_startup("ld      de,240")
            self._emit_startup("ld      hl,_symbols_table")
            self._emit_startup(f"call    {FWCALL.TXT_SET_M_TABLE}", info="TXT_SET_M_TABLE")
        if self.symbolafter < 256:
            self._emit_data()
            self._emit_data("; Table for symbols defined with SYMBOL keyword", 0)
            self._emit_data(f"; {256-self.symbolafter} elements x 8 bytes", 0)
            self._emit_data(f"_symbols_table: defs {(256 - self.symbolafter)*8}", 0)


    def _real(self, n: float) -> bytearray:
        """
        In Amstrad BASIC, a floating point number is stored in base-2 in a normalized form 1 x 2 ** <exp>
        The representation uses 5 bytes stored using the following structure:
        | M (31-24) | M	(23-16) | M	(15-8) | sign + M (7-0) | exponent |
        The exponent is 8-bit an uses a bias of 128 (128-255 possitive, 0-127 negative)
        """
        if n == 0:
            return bytearray([0,0,0,0x28,0])
        sign = '1' if n < 0 else '0'
        exp = 0
        prec = abs(n)
    
        while prec >= 1:
            exp = exp + 1
            prec = prec / 2.0
        while 0 < prec < 0.5:
            prec = prec * 2
            exp = exp - 1

        exp = exp + 128
        bit = 0
        mant = ""
        for i in range(32):
            prec = prec - bit
            prec = prec * 2
            bit = int(prec)
            mant = mant + str(bit)
        # round values last bit
        if prec > 0.5: mant = mant[:-1] + '1'
        # is normalized so drop first bit and used it for sign
        mant = sign + mant[1:]
        real = bytearray(int(mant, 2).to_bytes(4, byteorder='little'))
        real.extend(exp.to_bytes(1, 'little'))
        return real

    # ----------------- Label generation -----------------

    def _get_conststr_label(self) -> str:
        self.constants +=1
        return f"__const_str_{self.constants}"
    
    def _get_constlong_label(self) -> str:
        self.constants +=1
        return f"__const_long_{self.constants}"

    def _get_constreal_label(self) -> str:
        self.constants +=1
        return f"__const_real_{self.constants}"
    
    def _get_for_labels(self) -> tuple[str,str]:
        self.constants +=1
        return (f"__forloop_start_{self.constants}", f"__forloop_end_{self.constants}")

    def _get_while_labels(self) -> tuple[str,str]:
        self.constants +=1
        return (f"__whileloop_start_{self.constants}", f"__whileloop_end_{self.constants}")

    def _get_if_labels(self) -> tuple[str,str]:
        self.constants +=1
        return (f"__if_else_{self.constants}", f"__if_end_{self.constants}")

    def _get_symbol_label(self) -> str:
        self.constants +=1
        return f"__symbol_{self.constants}"

    def _get_userfun_label(self, name) -> str:
        symname = name.replace("$", "_S").replace("%", "_I").replace("!", "_R")
        return f"_userfn_{symname}"
    
    def _get_env_label(self) -> str:
        self.constants +=1
        return f"__sound_env_{self.constants}"
    
    def _get_ent_label(self) -> str:
        self.constants +=1
        return f"__sound_ent_{self.constants}"

    def _get_onjump_label(self) -> str:
        self.constants +=1
        return f"__on_jump_{self.constants}"

    def _set_select_case_labels(self, node:AST.SelectCase) -> None:
        node.case_labels = []
        node.def_label = ""
        self.constants +=1
        node.var_label = f"select_case{self.constants}"
        self._emit_data(f"{node.var_label}: dw 0", section=DataSec.VARS)
        for i in range(node.options):
            node.case_labels.append(f"__selectcase{self.constants}_case{i}")
        if node.defaultcase:
            node.def_label = f"__selectcase{self.constants}_default"
        self.constants += 1
        node.end_label = f"__selectcase{self.constants}_end"
            
    # ----------------- Error management -----------------

    def _raise_error(self, codenum: int, node: AST.ASTNode, info: str = "") -> NoReturn:
        if self.verbose:
            print(node)
        codeline = self.source[node.line - 1]
        raise BasError(
            codenum,
            codeline.source,
            codeline.code,
            codeline.line,
            node.col,
            info
        ) 

    def _raise_warning(self, level: WL, msg: str, node: AST.ASTNode) -> None:
        if level <= self.warning_level:
            # tokens start line counting in 1
            codeline = self.source[node.line - 1]
            print(f"[WARNING{int(level):02d}] {codeline.source}:{codeline.line}:{node.col}: {msg} in {codeline.code}")

    # ----------------- Commands and Functions -----------------

    def _emit_ABS(self, node:AST.Function) -> None:
        """
        Returns the absolute value of the given expression which primarily means
        that negative numbers are returned as positive. 
        """
        self._emit_import("rt_abs")
        self._emit_code("; ABS(<numeric expression>)")
        arg = node.args[0]
        self._emit_expression(node.args[0])
        if arg.etype == AST.ExpType.Real:
            self._emit_import("rt_math_call")
            self._emit_pushcontext()   
            self._moveflo_accum1()
            self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_SIGNUM}", info="MATH_REAL_SIGNUM")
            self._emit_code("call    rt_math_call")
            self._emit_code("jr      nc,$+8")
            self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_UMINUS}", info="MATH_REAL_UMINUS")
            self._emit_code("call    rt_math_call")
            self._moveflo_heap(node)
            self._emit_popcontext()
        else:
            self._emit_code("call    rt_abs")
        self._emit_code(";")

    def _emit_AFTER(self, node:AST.Command) -> None:
        """
        Invoke a subroutine after a given time period has elapsed. The first
        <int expr>, indicates the period of the delay, in units of 1/50 second,
        and the second <int expr>, (in range 0 to 3), indicates which of the
        four available delay timers should be used. 
        """
        self._emit_code("; AFTER <int expr>[,<int expr>] GOSUB (INT | IDENT)")
        self._emit_event_init(node)
        self._emit_code("ld      bc,0", info="recharge value")
        self._emit_code(f"call    {FWCALL.KL_ADD_TICKER}", info="KL_ADD_TICKER")
        self._emit_code(";")

    def _emit_event_init(self, node:AST.Command) -> None:
        self._emit_import("rt_timer")
        args = node.args
        self._emit_expression(args[0])
        self._emit_code("push    hl", info="number of ticks to fire event")
        if len(args) == 3:
            self._emit_expression(args[1])
            self._emit_code("ld      b,l")
        else:
            self._emit_code("ld      b,0", info="default timer ID is 0")
        self._emit_code("call    rt_timer_get", info="HL address to event block")
        self._emit_code("push    hl", info="tick block address")
        self._emit_code("ld      bc,6")
        self._emit_code("add     hl,bc", info="HL = event block inside the tick")
        # GOSUB address
        label = args[-1].args[0] # type: ignore [attr-defined]
        if isinstance(label, AST.Integer) or isinstance(label, AST.Label):
            sym = self.symtable.find(str(label.value), SymType.Label, "")
            if sym is not None:
                self._emit_code(f"ld      de,{sym.label}")
        self._emit_code("ld      bc,&80fd", info="async far call / ROM select")
        self._emit_code(f"call    {FWCALL.KL_INIT_EVENT}", info="KL_INIT_EVENT")
        self._emit_code("pop     hl", info="tick block address")
        self._emit_code("pop     de", info="timer ticks needed to fire the event")

    def _emit_ASC(self, node:AST.Function) -> None:
        """
        Gets the numeric value of the first character of a string as long as
        ASCII characters are used.
        """
        self._emit_code("; ASC(<string>)")
        self._emit_expression(node.args[0])
        self._emit_code("inc     hl")
        self._emit_code("ld      a,(hl)", info="get first char numeric value")
        self._emit_code("ld      l,a")
        self._emit_code("ld      h,0")
        self._emit_code(";")

    def _emit_ASM(self, node:AST.Command) -> None:
        """
        Inserts direct ASM code.
        """
        self._emit_code("; ASM <string>[,<string>]* ")
        for a in node.args:
            if isinstance(a, AST.String):
                self._emit_code(a.value)
            else:
                self._raise_error(2, a)
        self._emit_code(";")

    def _emit_ATN(self, node:AST.Function) -> None:
        """
        Calculates the arc-tangent (forcing the numeric expression) to a real
        number ranging from -PI/2 to +PI/2 of the value specified.
        """
        self._emit_import("rt_math_call")
        self._emit_code("; ATN(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        self._moveflo_accum1()
        self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_ARCTANGENT}", info="MATH_REAL_ARCTANGENT")
        self._emit_code("call    rt_math_call")
        self._moveflo_heap(node)
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_AUTO(self, node:AST.Command) -> None:
        """
        Generate line numbers automatically. The <line number>, sets the first
        line to be generated, in case you want to add to the end of an existing
        program. The value of the <increment> between line numbers, and the first
        line number to be generated, both default to 10 if not specified.
        """
        self._emit_code("; AUTO [<line number>l[,<increment>]")
        self._raise_warning(WL.MEDIUM, 'AUTO is ignored and has not effect', node)
        self._emit_code("; IGNORED")
        
    def _emit_BINSS(self, node:AST.Function) -> None:
        """
        Produces a string of binary digits that represents the value of the
        <unsigned integer expression>, filling with leading zeros to the number
        of digits instructed by the second <integer expression>.
        """
        # prints 8 or 16 characters
        self._emit_import("rt_int2bin")
        self._emit_code("; BIN$(<unsigned integer expression>[,<integer expression>])")
        if len(node.args) == 2:
            self._emit_expression(node.args[1])
        else:
            self._emit_code("ld      hl,16")
        self._emit_code("push    hl")
        self._emit_expression(node.args[0])
        self._emit_code("ex      de,hl", info="number to convert")
        self._reserve_heapmem(17, node)
        self._emit_code("pop     bc", info="number of characters")
        self._emit_code("ld      a,c", info="only 8 or 16 are valid")
        self._emit_code("call    rt_int2bin")
        self._emit_code(";")

    def _emit_BORDER(self, node:AST.Command) -> None:
        """
        To change the colour of the border on the screen. If two colours are
        specified, the border alternates between the two at the rate determined
        in the SPEED INK command, if given. The range of border colours
        is 0 to 26.        
        """ 
        self._emit_code("; BORDER <colour>[,<colour>]")
        self._emit_expression(node.args[0])
        if len(node.args) == 2:
            self._emit_code("push    hl")
            self._emit_expression(node.args[1])
            self._emit_code("ld      c,l", info="second color")
            self._emit_code("pop     de")
            self._emit_code("ld      b,e", info="first color")
        else:
            self._emit_code("ld      c,l", info="second color")
            self._emit_code("ld      b,l", info="first color")
        self._emit_code(f"call    {FWCALL.SCR_SET_BORDER}", info="SCR_SET_BORDER")
        self._emit_code(";")

    def _emit_CALL(self, node:AST.Command) -> None:
        """
        Allows an externally developed sub-routine to be invoked from BASIC.
        The routine is called with IX pointing to the list of parameters and A
        containing the number of parameters. Parameters are passed in reverse
        order, ie. (IX+0) is the last parameter supplied.
        """
        self._emit_code("; CALL <address expression> ,[<list of: <parameter>]")
        params = node.args[1:]
        if len(params) > 0:
            self._emit_pushcontext()
            for a in params:
                self._emit_expression(a)
                self._emit_code("push    hl")
            self._emit_code("ld      ix,0")
            self._emit_code("add     ix,sp")
        if isinstance(node.args[0],AST.Integer):
            address = node.args[0].value
            self._emit_code(f"call     {address}", info=f"calling {address:#04x}")
        elif isinstance(node.args[0],AST.String):
            self._emit_code(f"call     {node.args[0].value}", info=f"calling asm routine")
        elif node.args[0].etype == AST.ExpType.Integer:
            self._emit_import("rt_call")
            self._emit_expression(node.args[0])
            self._emit_code(f"ld      a,{len(params)}")
            self._emit_code("call    rt_call", info="HL has the address")
        else:
            self._raise_error(5, node)
        if len(params) > 0:
            for a in params:
                self._emit_code("pop     de")
            self._emit_popcontext()
        self._emit_code(";")

    def _emit_CASE(self, node:AST.Command) -> None:
        if len(self.selectblocks):
            sel = self.selectblocks[-1]
            self._emit_code("; CASE <int_expression>")
            if sel.currentopt != 0:
                self._emit_code(f"jp      {sel.end_label}")
            label = sel.case_labels[sel.currentopt]
            self._emit_code(f"{label}:")
            self._emit_expression(node.args[0])
            self._emit_code(f"ld      de,({sel.var_label})")
            self._emit_code("or      a")
            self._emit_code("sbc     hl,de")
            sel.currentopt += 1
            if sel.currentopt < sel.options:
                self._emit_code(f"jp      nz,{sel.case_labels[sel.currentopt]}")
            else:
                if sel.defaultcase:
                    self._emit_code(f"jp      nz,{sel.def_label}")
                else:
                    self._emit_code(f"jp      nz,{sel.end_label}")
            self._emit_code(";")
        else:
            self._raise_error(2, node, "unexpected CASE")

    def _emit_CASE_DEFAULT(self, node:AST.Command) -> None:
        if len(self.selectblocks):
            self._emit_code("; CASE DEFAULT")
            sel = self.selectblocks[-1]
            if sel.currentopt != sel.options:
                self._raise_error(2, node, "CASE DEAFULT must be the last option")
            self._emit_code(f"jp      {sel.end_label}")
            self._emit_code(f"{sel.def_label}:")
            self._emit_code(";")
        else:
            self._raise_error(2, node, "unexpected CASE DEFAULT")

    def _emit_CAT(self, node:AST.Command) -> None:
        """
        Causes BASIC to start reading the directory of the current drive
        (cassette or disc) and to display the names of all files found.
        This does not affect the program currently in memory, and so may be used
        to verify a program that has just been saved before altering the program
        memory. 
        """
        self._emit_import("rt_fileinbuf")
        self._emit_code("; CAT")
        self._emit_code("ld      de,rt_fileinbuf", info="buffer address in DE")
        self._emit_code(f"call    {FWCALL.CAS_CATALOG}")
        self._emit_code(";")

    def _emit_CHAIN(self, node:AST.Command) -> None:
        """
        CHAIN loads a program from disc or cassette into the memory; replacing the
        existing program. The new program then commences running, either from the
        beginning, or from the line specified in the optional <line number expr>.
        Protected files (saved with the ',P' type) can be loaded and run by chaining.
        """
        self._emit_code("; CHAIN <file name>[,<line number>]")
        self._raise_warning(WL.HIGH, 'CHAIN is ignored and has not effect', node)
        self._emit_code("; IGNORED")
        self._emit_code(";")

    def _emit_CHAIN_MERGE(self, node:AST.Command) -> None:
        """
        CHAIN MERGE merges a program from disc or cassette into the current program
        memory. The <line number expression>, indicates the line number from which
        execution is to begin once the new program is chain merged. In the absence
        of <line number expression>, BASIC will default to the lowest line number
        available. 
        """
        # CHAIN MERGE is processed by the preprocessor and it is used to
        # append additional BAS files, so here we don't have to do anything.
        self._emit_code("; CHAIN MERGE <file name>[,<line number>][, DELETE <range>]")
        self._raise_warning(WL.LOW, 'CHAIN MERGE is ignored and has not effect', node)
        self._emit_code("; IGNORED")

    def _emit_CHRSS(self, node:AST.Function) -> None:
        """
        Converts <integer expression> in the range 0 to 255, to its character
        string equivalent. Note that 0 to 31 are control characters. 
        """
        self._emit_code("; CHR$(<integer expression>)") 
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._reserve_heapmem(2, node)
        self._emit_code("ld      (hl),1")
        self._emit_code("inc     hl")
        self._emit_code("ld      (hl),a")
        self._emit_code("dec     hl")
        self._emit_code(";")

    def _emit_CINT(self, node:AST.Function) -> None:
        """
        Converts the given value to a rounded integer in the range -32768..32767. 
        """
        self._emit_code("; CINT(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        if node.args[0].etype == AST.ExpType.Real:
            self._emit_import("rt_real2int")
            self._moveflo_accum1()
            self._emit_code("call    rt_real2int")
        else:
            self._emit_code("; already INT so no action taken")
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_CLEAR(self, node:AST.Command) -> None:
        """
        Clears all variables to zero or null. All open files are abandoned, all
        arrays and user functions are erased, and BASIC is set to radians mode
        of calculation. 
        """
        self._emit_import("rt_math_call")
        self._emit_import("rt_reset_vars")
        self._emit_code("; CLEAR")
        self._emit_pushcontext()
        self._emit_code("call    rt_reset_vars", info="Fill all vars data area with 0s")
        self._emit_code("xor     a")
        self._emit_code(f"ld      ix,{FWCALL.MATH_SET_ANGLE_MODE}", info="SET_ANGLE_MODE")
        self._emit_code("call    rt_math_call")
        self._emit_code(f"call    {FWCALL.CAS_INITIALISE}", info="CAS_INITIALISE")
        self._emit_popcontext()
        self._emit_code(";")
        
    def _emit_CLEAR_INPUT(self, node:AST.Command) -> None:
        """
        Only available with BASIC 1.1
        Discards all previously typed input from the keyboard, still in the
        keyboard buffer.
        """
        # There is an specific Firmware routine in the 6128 (KM FLUSH)
        # but to make it compatible with the 464 we use KM RESET instead
        self._emit_code("; CLEAR INPUT")
        self._emit_code(f"call    {FWCALL.KM_RESET}", info="KM_RESET")
        self._emit_code(";")

    def _emit_CLG(self, node:AST.Command) -> None:
        """
        Clears the graphics screen to the graphics paper colour. If the <ink>
        is specified, the graphics paper is set to that value. 
        """
        self._emit_code("; CLG [<masked ink>]")
        if len(node.args) > 0:
            self._emit_expression(node.args[0])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.GRA_SET_PAPER}", info="GRA_SET_PAPER")
        self._emit_code(f"call    {FWCALL.GRA_CLEAR_WINDOW}", info="GRA_CLEAR_WINDOW")
        self._emit_code(";")
    
    def _emit_CLOSEIN(self, node:AST.Command) -> None:
        """
        Close any input file from disc or cassette.
        """
        self._emit_code("; CLOSEIN")
        self._emit_code(f"call    {FWCALL.CAS_IN_CLOSE}", info="CAS_IN_CLOSE")
        self._emit_code(";")

    def _emit_CLOSEOUT(self, node:AST.Command) -> None:
        """
        Close any output file from disc or cassette.
        """
        self._emit_code("; CLOSEOUT")
        self._emit_pushcontext()
        self._emit_code(f"call    {FWCALL.CAS_OUT_CLOSE}", info="CAS_OUT_CLOSE")
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_CLS(self, node:AST.Command) -> None:
        """
        Clear the given screen stream (window) to its paper ink. If no
        <stream expression> is given, screen stream #0 is cleared. 
        """
        self._emit_code("; CLS [#<stream expression>]")
        if len(node.args):
            self._emit_expression(node.args[0])
            self._emit_stream()
        self._emit_code(f"call    {FWCALL.TXT_CLEAR_WINDOW}", info="TXT_CLEAR_WINDOW")
        if len(node.args):
            self._emit_stream_0()
        self._emit_code(";")

    def _emit_CONST(self, node:AST.Command) -> None:
        """
        CONST declares and defines named constants, assigning them a fixed integer value.
        When the constant name is used in an expression, its value is substituted directly,
        which may enable compiler optimizations.
        """
        self._emit_code("; CONST IDENT = INT")
        self._emit_code(";")

    def _emit_CONT(self, node:AST.Command) -> None:
        """
        Continue program execution after a *Break*, STOP or END, as long as the
        program has not been altered. Direct commands may be entered. 
        """
        # We reuse CONT to be able to add "BREAK POINTS" that stop the execution
        # until a key is pressed
        self._emit_code("; CONT")
        self._raise_warning(WL.HIGH, 'CONT will stop de program until a key is pressed', node)
        self._emit_code(f"call    {FWCALL.KM_WAIT_CHAR}", info="KM_WAIT_CHAR")
        self._emit_code(";")
    
    def _emit_COPYCHRSS(self, node:AST.Function) -> None:
        """
        BASIC 1.1 only
        COPies ChaRacter from the current position in the stream (which MUST be
        specified). If the character read is not recognized, a null string is
        returned. 
        """
        self._emit_import("rt_copychrs")
        self._emit_code("; COPYCHR$(#<stream expression>)")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._reserve_heapmem(2, node)
        self._emit_code("call    rt_copychrs")
        self._emit_code(";")

    def _emit_COS(self, node:AST.Function) -> None:
        """
        Calculates the COSINE of a given value. The function defaults to radian
        measure unless specifically instructed otherwise by the DEG command. 
        """
        self._emit_import("rt_math_call")
        self._emit_code("; COS(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        self._moveflo_accum1()
        self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_COSINE}", info="MATH_REAL_COSINE")
        self._emit_code("call    rt_math_call")
        self._moveflo_heap(node)
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_CREAL(self, node:AST.Function) -> None:
        """
        Converts a value to a real number (As opposed to integer).
        """
        self._emit_code("; CREAL(<numeric expression>)")
        self._emit_import("rt_int2real")
        self._emit_expression(node.args[0])
        if node.args[0].etype == AST.ExpType.Integer:
            self._emit_pushcontext()
            self._emit_code("call    rt_int2real", info="REAL in rt_math_accum1")
            self._moveflo_heap(node)
            self._emit_popcontext()
        else:
            self._emit_code("; already REAL so no action taken")
        self._emit_code(";")

    def _emit_CURSOR(self, node:AST.Command) -> None:
        """
        Only available with BASIC 1.1
        Sets the system switch or the user switch to the cursor, ON or OFF. The
        <system switch> and <user switch> parameters must be either 0 (OFF) or 1 (ON).
        The cursor is displayed whenever both the <system switch> and <user switch>
        are ON (1). The <system switch> is automatically turned OFF when printing
        text to screen. Either swtich parameter may be omitted, but not both. If
        a switch parameter is omitted, that particular switch state is not changed.
        """
        self._emit_code("; CURSOR [<system switch>][,<user switch>]")
        calls_on = [FWCALL.TXT_CUR_ON, FWCALL.TXT_CUR_ENABLE]
        calls_off = [FWCALL.TXT_CUR_OFF, FWCALL.TXT_CUR_DISABLE]
        for i,a in enumerate(node.args):
            self._emit_code("; system cursor" if i == 0 else "; user cursor")
            self._emit_expression(a)
            self._emit_code("ld      a,l", info="valid values are 0 or <>0")
            self._emit_code("or      a")
            self._emit_code("jr      z,$+7")
            self._emit_code(f"call    {calls_on[i]}", info="TXT_CURSOR_ON/TXT_CURSOR_ENABLE")
            self._emit_code("jr      $+5")
            self._emit_code(f"call    {calls_off[i]}", info="TXT_CURSOR_OFF/TXT_CURSOR_DISABLE")
        self._emit_code(";")
   
    def _emit_DATA(self, node:AST.Data) -> None:
        """
        Compatibility
        With BASIC 1.0, DATA statements have to be at the end of the line.
        With BASIC 1.1, DATA statements can appear anywhere within a line.
        Declares constant data for use within a program. One of the most widely
        used features of BASIC that lumps constant data in DATA statements for
        retrieval as required. The data type must be consistent with the variable
        invoking it. A DATA statement may appear anywhere in a program. 
        """
        self._emit_code("; DATA <list of constant>")
        self._emit_import("rt_datablock")
        dataline = "db "
        for a in node.args:
            if isinstance(a, AST.String):
                dataline = dataline + f'{len(a.value)},"{a.value}",'
            elif isinstance(a, AST.Integer):
                dataline = dataline + f'{a.value % 256},{a.value // 256},'
            elif isinstance(a, AST.Real):
                cpcreal = self._real(a.value)
                for b in cpcreal:
                    dataline = dataline + f'&{b:02X},'
            else:
                self._raise_error(2, node, 'DATA constant type not supported yet')
        # emit the labels that RESTORE can use
        if node.userlabel != "":
            self._emit_data(f"{node.userlabel}:", section=DataSec.DATA)
        inserted = self.symtable.add(ident = node.linelabel,
                                     info = SymEntry(SymType.Label, AST.ExpType.Void, SymTable()),
                                     context=""
                                    )
        if not inserted:                                     
            self._raise_error(2, node, "only one DATA statement is allowed per line")
        self._emit_data(f"{node.linelabel}:", section=DataSec.DATA)
        # we have to remove last ','
        self._emit_data(dataline[:-1], section=DataSec.DATA)
        self._emit_code(";")

    def _emit_DECLARE(self, node:AST.Command) -> None:
        """
        Imported from Locomotive BASIC 2 Plus
        Declares a variable before being used. This allows users to set a size
        lower than 254 (+1 for size) for strings.
        """
        self._emit_code("; DECLARE list of: <string ident> [FIXED INT] | <ident>")
        self._emit_code(";")

    def _emit_DECSS(self, node:AST.Function) -> None:
        """
        Only available with BASIC 1.1
        Return a DECimal string representation of the <numeric expression>, using
        the specified <format template> to control the print format of the resulting string.
        The format template may contain ONLY the characters: + - Â£ $ * # , . ^
        """
        self._emit_code("; DEC$(<numeric expression>,<format template>)")
        # TODO: apply format
        arg = node.args[0]
        self._emit_expression(arg)
        if arg.etype == AST.ExpType.Integer:
            self._emit_import("rt_int2str")
            self._emit_code("call    rt_int2str")
            self._reserve_heapmem_de(8, node)
            self._emit_code("push    de")
            self._emit_code("ldir")
            self._emit_code("pop     hl")
        else:
            self._emit_import("rt_real2strz")
            self._emit_import("rt_strzcopy")
            self._emit_pushcontext()
            self._emit_code("call    rt_real2strz")
            self._reserve_heapmem(12, node)
            self._emit_code("ld      de,rt_real2strz_buf")
            self._emit_code("call    rt_strzcopy")
            self._emit_popcontext()
        self._raise_warning(WL.MEDIUM, "text patterns are not supported yet", node)
        self._emit_code(";")

    def _emit_DEFINT(self, node:AST.Command) -> None:
        """
        Define default variable types where <type> is integer, real or string.
        The variable will be set according to the first letter of the variable's
        name which may be either upper or lower case. 
        """
        # In our case, this command is ignored as types must be especified
        # always using sufixes
        self._emit_code("; DEFINT <range(s) of letters>")
        self._raise_warning(WL.LOW, "DEFINT has no effect, use % ! $ sufixes instead", node)
        self._emit_code("; IGNORED")

    def _emit_DEFREAL(self, node:AST.Command) -> None:
        """
        Define default variable types where <type> is integer, real or string.
        The variable will be set according to the first letter of the variable's
        name which may be either upper or lower case. 
        """
        # In our case, this command is ignored as types must be especified
        # always using sufixes
        self._emit_code("; DEFREAL <range(s) of letters>")
        self._raise_warning(WL.LOW, "DEFREAL has no effect, use % ! $ sufixes instead", node)
        self._emit_code("; IGNORED")

    def _emit_DEFSTR(self, node:AST.Command) -> None:
        """
        Define default variable types where <type> is integer, real or string.
        The variable will be set according to the first letter of the variable's
        name which may be either upper or lower case. 
        """
        # In our case, this command is ignored as types must be especified
        # always using sufixes
        self._emit_code("; DEFSTR <range(s) of letters>")
        self._raise_warning(WL.LOW, "DEFSTR has no effect, use % ! $ sufixes instead", node)
        self._emit_code("; IGNORED")

    def _emit_DEF_FN(self, node:AST.DefFN) -> None:
        """
        BASIC allows the program to define and use simple value returning functions.
        DEF FuNction is the definition part of this mechanism and creates program-specific
        function which works within the program in the same way as a function such as
        COS operates as a built-in function of BASIC.
        It may be invoked throughout the program. Variable types must be consistent and
        the DEF FuNction command should be written in part of the program outside
        the execution loop. 
        """
        self._emit_code("; DEF FN <name> [(<formal parameters>)]=<general expression>")
        self.context = node.name
        currentcode = self.srccode  # keep current generated code
        self.srccode = ""           # capture only the code that will be generated now
        self._push_heapvalues()
        self._emit_expression(node.body)
        self._emit_code("ret")
        fcode = self.srccode
        self.srccode = currentcode  # restore previous generated code
        self.context=""
        flabel = self._get_userfun_label(node.name)
        self._emit_data(f"{flabel}:", 0)
        self._emit_data(fcode, 0)
        # If the expresion required heap memory (tmp memory)
        # we store the amount
        entry = self.symtable.find(node.name, SymType.Function)
        if entry is not None:
            entry.heapused = self.max_heap_memory
            self._pop_heapvalues()
        else:
            self._raise_error(2, node)
        self._emit_code(";")

    def _emit_DEG(self, node:AST.Statement) -> None:
        """
        Set degrees mode. The default condition is for functions such as SIN and
        COS is to assume radian measure for numeric data. The command sets to
        degree mode until instructed otherwise by a CLEAR or RAD or if any new
        program is loaded.
        """
        self._emit_import("rt_math_call")
        self._emit_code("; DEG")
        self._emit_pushcontext()
        self._emit_code("ld      a,&FF")
        self._emit_code(f"ld      ix,{FWCALL.MATH_SET_ANGLE_MODE}", info="SET_ANGLE_MODE")
        self._emit_code("call    rt_math_call")
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_DELETE(self, node:AST.Command) -> None:
        """
        A command that removes part of the current program as defined in the line
        number range, expression. Not recoverable if issued in error, so use with
        care, and check for mistyping before entering. 
        """
        # We reuse this command to "delete" memory (fill memory with 0s).
        # Therefore, the range indicates the memory range and not line numbers.
        self._emit_code("; DELETE <line number range>")
        arg = node.args[0]
        if isinstance(arg, AST.Range):
            self._emit_code(f"ld      hl,{arg.high}")
            self._emit_code(f"ld      de,{arg.low}")
            self._emit_code("sbc     hl,de")
            self._emit_code("push    hl")
            self._emit_code(f"ld      hl,{arg.low}")
            self._emit_code("ld      (hl),0")
            self._emit_code("inc     de")
            self._emit_code("pop     bc")
            self._emit_code("ldir")
        self._emit_code(";")

    def _emit_DERR(self, node:AST.Statement) -> None:
        """
        Only available with BASIC 1.1.
        Report the last error code returned by the disc operating system. The
        value of DERR may be used to ascertain the particular Disc ERRor that
        occured. See the listing of error messages. 
        """
        self._emit_code("; DERR")
        self._raise_warning(WL.MEDIUM, "DERR is ignored and has no effect", node)
        self._emit_code("; IGNORED")

    def _emit_DI(self, node:AST.Command) -> None:
        """
        Disable interrupts (other than the *Break* interrupt) until re-enabled
        explicitly by EI or implicitly by the RETURN at the end of an interrupt
        GOSUB routine.
        """
        self._emit_code("; DI")
        self._emit_code(f"call    {FWCALL.KL_EVENT_DISABLE}", info="KL_EVENT_DISABLE")
        self._emit_code(";")

    def _emit_DIM(self, node:AST.Command) -> None:
        """
        Allocate space for arrays and specify maximum subscript values. Basic must be
        advised of the space to be reserved for an array, or it will default to 10.
        Once set either implicitly or explicitly, the size of the array may not be changed,
        or an error will result.
       """
        self._emit_code("; DIM <list of: subscripted variable>")
        # We don't really emit code here but check that we don't consume 
        # more than 28K of central memory leaving 4K max for code.
        for var in node.args:
            if isinstance(var, AST.Array):
                entry = self.symtable.find(var.name, SymType.Array, context=self.context)
                if entry is not None:
                    mem = 1
                    for index in entry.indexes: mem = mem * (index + 1)
                    mem = mem * entry.datasz
                    self._emit_code(f"; Array variable {entry.label} with {mem} bytes")
                    if mem > 28*1024:
                        self._raise_error(7, node)
                else:
                    self._raise_error(2, node)
            else:
                self._raise_error(2, node)
        self._emit_code(";")

    def _emit_DRAW(self, node:AST.Command) -> None:
        """
        <ink mode> is only available with BASIC 1.1
        Draws a line on the screen from the current graphics cursor position to
        an absolute position. The co-ordinate positions remain unchanged between
        the three different screen modes. The <ink> in which to draw the line may
        be specified (in the range 0 to 15).
        The optional <ink mode> determines how the ink being written interacts
        with that already on the graphics screen. The four <ink mode>s are:
        0: Fill (normal)
        1: XOR (eXclusive OR)
        2: AND
        3: OR
        """
        self._emit_code("; DRAW <x co-ordinate>,<y co-ordinate>[,<ink>][,<ink mode>]")
        if len(node.args) > 2:
            self._emit_expression(node.args[2])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.GRA_SET_PEN}", info="GRA_SET_PEN")
        if len(node.args) > 3:
            self._emit_expression(node.args[3])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.SCR_ACCESS}", info="SCR_ACCESS")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code(f"call    {FWCALL.GRA_LINE_ABSOLUTE}", info="GRA_LINE_ABSOLUTE")
        self._emit_code(";")
        

    def _emit_DRAWR(self, node:AST.Command) -> None:
        """
        <ink mode> is only available with BASIC 1.1
        To draw a line on the screen from the current graphics cursor position to
        a position relative to it. The <ink> in which to draw the line may be
        specified (in the range 0 to 15).
        The optional <ink mode> determines how the ink being written interacts with that already on the graphics screen. The four <ink mode>s are:
        0: Normal
        1: XOR (eXclusive OR)
        2: AND
        3: OR
        """
        self._emit_code("; DRAWR <x offset>,<y offset>[,<ink>][,<ink mode>]")
        if len(node.args) > 2:
            self._emit_expression(node.args[2])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.GRA_SET_PEN}", info="GRA_SET_PEN")
        if len(node.args) > 3:
            self._emit_expression(node.args[3])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.SCR_ACCESS}", info="SCR_ACCESS")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code(f"call    {FWCALL.GRA_LINE_RELATIVE}", info="GRA_LINE_RELATIVE")
        self._emit_code(";")

    def _emit_EDIT(self, node:AST.Statement) -> None:
        """
        Edit a program line by calling for a specific line number. 
        """
        self._emit_code("; EDIT <line number>")
        self._raise_warning(WL.MEDIUM, "EDIT is ignored and has no effect", node)
        self._emit_code("; IGNORED")

    def _emit_EI(self, node:AST.Command) -> None:
        """
        Enable interrupts disabled by a DI command. 
        """
        self._emit_code("; EI")
        self._emit_code(f"call    {FWCALL.KL_EVENT_ENABLE}", info="KL_EVENT_ENABLE")
        self._emit_code(";")

    def _emit_ELSE(self, node:AST.Statement) -> None:
        if len(self.ifblocks) > 0:
            # END IF will remove from the queue
            ifnode = self.ifblocks[-1]
            self._emit_code(f"jp      {ifnode.end_label}")
            self._emit_code("; ELSE")
            self._emit_code(ifnode.else_label, 0)
        else:
            self._raise_error(37, node)

    def _emit_END(self, node:AST.Command) -> None:
        """
        End of program. An END is implicit in AMSTRAD BASIC as the program
        passes the last line of instruction. END closes all cassette files and
        returns to the direct mode. Sound queues will continue until empty.
        """
        # In our version, we call FULL RESET after any key is pressed
        self._emit_code("; END")
        self._emit_code(f"jp      _code_end_")

    def _emit_ENT(self, node:AST.Command) -> None:
        """
        Sets the Tone ENvelope specified in the <envelope section> (in the
        range 1 to 15), which is used in conjunction with the SOUND command.
        If the <envelope number> is negative (in the range -1 to -15), the envelope
        repeats until the end of the duration of the SOUND command.
        Each of the <envelope section>s may contain either 2 ou 3 parameters:
        Parameter 1: <number of step> The available range of <number of steps> is 0 to 239.
        Parameter 2: <step size> in the range -128 to +127.
        Parameter 3: <pause time>
        OR
        Parameter 1: <tone period> (See parameter 2 of the SOUND command).
        Parameter 2: <pause time>
        """
        # NOTE: Sections will be integers of 3 bytes: byte, byte, byte or 2-bytes, byte.
        self._emit_code("; ENT <envelope number>[,<envelope section>]*")
        entlabel = self._get_ent_label()
        values = ""
        args = node.args[1:]
        if len(args) % 3 == 0:
            for a in args:
                if isinstance(a, AST.Integer):
                    values = values + f",{a.value}"
                else:
                    self._raise_error(2, a)
            values = f"{len(args)//3}{values}"
        else:
            for i,a in enumerate(args):
                if isinstance(a, AST.Integer):
                    if i % 2 == 1:
                        values = values + f",{a.value}"
                    else:
                        values = values + f",{a.value % 256},{a.value // 256}"
                else:
                    self._raise_error(2, a)
            values = f"{len(args)//2}{values}"
        entid: int = node.args[0].value # type: ignore [attr-defined]
        self._emit_code(f"ld      hl,{entlabel}")
        self._emit_code(f"ld      a,{abs(entid)}") 
        self._emit_code(f"call    {FWCALL.SOUND_TONE_ENVELOPE}", info="SOUND_TONE_ENVELOPE")
        if entid < 0: values = "128+" + values # set bit 7 in repetitive ent
        self._emit_data(f"{entlabel}: db {values}", section=DataSec.CONST)
        self._emit_code(";")

    def _emit_ENV(self, node:AST.Command) -> None:
        """
        Sets the volume envelope specified in the <envelope number> (in the range 1 to 15),
        which is used in conjunction with the SOUND command. Each of the <enveloppe section>s
        may contain either 2 or 3 parameters:
        Parameter 1: <number of step> range of <number of steps> is 0 to 127.
        Parameter 2: <step size> can be between -128 and +127
        Parameter 3: <pause time> the range of the <pause time> is 0 to 255.
        OR
        Parameter 1: <hardware envelope> the value to send to the envelope shape register.
        Parameter 2: <envelope period> the value to send to the envelope period registers. 
        """
        # NOTE: Sections will be integers of 3 bytes: byte, byte, byte or byte, 2-bytes.
        self._emit_code("; ENV <envelope number>[,<envelope section>]*")
        envlabel = self._get_env_label()
        values = ""
        args = node.args[1:]
        if len(args) % 3 == 0:
            for a in args:
                if isinstance(a, AST.Integer):
                    values = values + f",{a.value}"
                else:
                    self._raise_error(2, a)
            values = f"{len(args)//3}{values}"
        else:
            for i,a in enumerate(args):
                if isinstance(a, AST.Integer):
                    if i % 2 == 0:
                        values = values + f",128+{a.value}"
                    else:
                        values = values + f",{a.value % 256},{a.value // 256}"
                else:
                    self._raise_error(2, a)
            values = f"{len(args)//2}{values}"
        self._emit_data(f"{envlabel}: db {values}", section=DataSec.CONST)
        self._emit_code(f"ld      hl,{envlabel}")
        self._emit_code(f"ld      a,{node.args[0].value}") # type: ignore [attr-defined]
        self._emit_code(f"call    {FWCALL.SOUND_AMPL_ENVELOPE}", info="SOUND_AMPL_ENVELOPE")
        self._emit_code(";")

    def _emit_EOF(self, node:AST.Function) -> None:
        """
        Tests to see if the cassette input is at the end of the file. Returns -1
        (true) at the end, otherwise 0 (false).
        """
        self._emit_code("; EOF")
        self._emit_code("ld      hl,&FFFF", info="EOF")
        self._emit_code(f"call    {FWCALL.CAS_TEST_EOF}", info="CAS_TEST_EOF")
        self._emit_code("jr      nc,$+3")
        self._emit_code("inc     hl", info="NOT EOF")
        self._emit_code(";")

    def _emit_ERASE(self, node:AST.Command) -> None:
        """
        When an array is no longer required, it may be ERASEd and the memory used
        be reclaimed ready for other use.
        """
        # In our case this has not effect
        self._emit_code("; ERASE list of: <variable name>")
        self._emit_code("; IGNORED")

    def _emit_ERL(self, node:AST.Function) -> None:
        """
        Reports the Line number of the last ERror encountered.
        """
        self._emit_code("; ERL")
        self._raise_warning(WL.MEDIUM, "ERL is ignored and has no effect", node)
        self._emit_code("; IGNORED")

    def _emit_ERR(self, node:AST.Function) -> None:
        """
        Reports the number of the last ERRor encountered.
        """
        # in our case, we retrieve the error number set by ERROR
        # error generated using OPENIN or OPENOUT
        self._emit_import("rt_error")
        self._emit_code("; ERR")
        self._emit_code("ld      h, 0")
        self._emit_code("ld      a,(rt_error)")
        self._emit_code("ld      l,a")
        self._emit_code(";")

    def _emit_ERROR(self, node:AST.Command) -> None:
        """
        Invokes the error specified in the <integer expression>. The error may
        be one already used and recognised by BASIC, in which case the action taken
        is the same as would be taken if such an error had been detected by BASIC.
        Error numbers beyond those recognised by BASIC may be used by the program
        to signal its own errors.
        """
        # In our case, this sets the runtime variable RT_ERROR that can be
        # retrieve with ERR
        self._emit_import("rt_error")
        self._emit_code("; ERROR <integer expression>")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code("ld      (rt_error),a")
        self._emit_code(";")

    def _emit_EVERY(self, node:AST.Command) -> None:
        """
        The EVERY command allows a BASIC program to arrange for subroutines to
        be called at regular intervals. Four delay timers are available, specified
        by the 2nd <int expression> in the range 0 to 3 each of which may have a
        subroutine associated with it.
        """
        self._emit_code("; EVERY <int expr>[,<int expr>] GOSUB (INT | IDENT)")
        self._emit_event_init(node)
        self._emit_code("ld      b,d", info="recharge value")
        self._emit_code("ld      c,e")
        self._emit_code(f"call    {FWCALL.KL_ADD_TICKER}", info="KL_ADD_TICKER")
        self._emit_code(";")

    def _emit_EXIT_FOR(self, node:AST.Command) -> None:
        """
        Interrupts a FOR ... NEXT loop and transfers the control to the line
        just after the NEXT keyword.
        """
        self._emit_code("; EXIT FOR")
        fornode = self.forloops[-1]
        self._emit_code(f"jp      {fornode.end_label}")
        self._emit_code(";")
    
    def _emit_EXIT_WHILE(self, node:AST.Command) -> None:
        """
        Interrupts a WHILE ... WEND loop and transfers the control to the line
        just after the WEND keyword.
        """
        self._emit_code("; EXIT WHILE")
        wnode = self.wloops[-1]
        self._emit_code(f"jp      {wnode.end_label}")
        self._emit_code(";")

    def _emit_EXP(self, node:AST.Function) -> None:
        """
        Calculates E to the power given in numeric expression, where E is approximately
        2.7182818 - the number whose natural logarithm is 1. 
        """
        self._emit_import("rt_math_call")
        self._emit_code("; EXP(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        self._moveflo_accum1()
        self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_EXP}", info="MATH_REAL_EXP")
        self._emit_code("call    rt_math_call")
        self._moveflo_heap(node)
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_FILL(self, node:AST.Command) -> None:
        """
        Only available with BASIC 1.1
        Fills an area of the screen starting from the current graphics position
        and extending until it reaches either the edge of the window or a pixel
        set to the <ink>. 
        """
        self._emit_import("rt_fill")
        self._emit_code("; FILL <ink>")
        self._raise_warning(WL.HIGH,"FILL is supported only by 664 and 6128 machines", node)
        self._emit_expression(node.args[0])
        self._emit_code("call    rt_fill")
        self._emit_code(";")

    def _emit_FIX(self, node:AST.Function) -> None:
        """
        Unlike CINT, FIX merely removes the part of the numeric expression, to
        the right of the decimal point, and leaves an integer result, rounding
        towards zero.
        """
        self._emit_code("; FIX(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        if node.args[0].etype == AST.ExpType.Real:
            self._emit_import("rt_real2fix")
            self._moveflo_accum1()
            self._emit_code("call    rt_real2fix")
        else:
            self._emit_code("; already INT so no action taken")
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_FOR(self, node:AST.ForLoop) -> None:
        """
        Execute a body of program a given number of times, stepping a control
        variable between a start and an end value. If not specified, STEP
        defaults to 1. 
        """
        sym = self.symtable.find(node.var.name, SymType.Variable, self.context)
        startlab, endlab = self._get_for_labels()
        node.start_label = startlab
        node.end_label = endlab
        hasstep = node.step is not None
        if sym is not None:
            self._emit_code("; FOR <variable> = <start> TO <end> [STEP <size>]")
            self._emit_code("; START calculation")
            self._emit_expression(node.start)
            self._emit_code(f"ld      ({sym.label}),hl")
            self._emit_code("; END calculation")
            self._emit_expression(node.end)
            self._emit_code("push    hl")
            if hasstep:
                self._emit_code("; STEP calculation")
                self._emit_expression(node.step) # type: ignore [arg-type]
                self._emit_code("push    hl")           
            # clear temporal memory used by the expressions
            self._emit_free_heapmem()

            self._emit_code("; FOR condition check")
            self._emit_code(startlab, 0)
            self._emit_code(f"ld      de,({sym.label})", info="current value")
            if hasstep:
                self._emit_code("pop     bc", info="STEP value")
            self._emit_code("pop     hl", info="END value")
            self._emit_code("push    hl")
            if hasstep:
                self._emit_code("push    bc")
                self._emit_code("bit     7,b", info="STEP sign")
                self._emit_code("jr      z,$+3")
                self._emit_code("ex      de,hl")
            self._emit_code("or      a")
            self._emit_code("sbc     hl,de")
            self._emit_code(f"jp      m,{endlab}")
            self._emit_code("; FOR body")
            node.var_label = sym.label
            self.forloops.append(node)
        else:
            self._raise_error(2, node, f"undeclared variable {node.var.name}")

    def _emit_FRAME(self, node:AST.Statement) -> None:
        """
        Only available with BASIC 1.1
        Synchronises the writing of the graphics on the screen with the frame
        flyback (VSYNC) of the display. The overall effect of this is that
        character or graphics movement on the screen will appear to be smoother,
        without flickering or tearing.
        With BASIC 1.0, two alternatives for the FRAME command exist:
        - CALL &BD19 (call the firmware function MC WAIT FLYBACK).
        - WAIT &F500,1 (wait until the frame flyback bit at PPI Port B is set).
        """
        self._emit_code("; FRAME")
        self._emit_code(f"call    {FWCALL.MC_WAIT_FLYBACK}", info="MC_WAIT_FLYBACK")
        self._emit_code(";")

    def _emit_FRE(self, node:AST.Command) -> None:
        """
        Establishes how much memory remains unused by BASIC. The form FRE("")
        forces a garbage collection before returning a value for available space. 
        """
        # In our case we code this command as follows:
        # FRE(0) - Amount of memory between end of the program and high jump block starting address
        # FRE(1) - Current available temporal memory
        # FRE("")- Forces a free of the temporal memory and works as FRE(0)
    
        self._emit_code("; FRE(<num expression>|<str expression>)")
        arg = node.args[0]
        if arg.etype == AST.ExpType.String:
            # Free memory between the high limit and our program binary end
            # Free temporal memory too
            self.free_heap_memory = True
            self._emit_free_heapmem()
            self._emit_code(f"ld      hl,{FWCALL.HIGH_LIMIT}")
            self._emit_code("ld      de,_program_end_")
        else: # should be isinstance(arg, AST.Integer)
            if arg.etype == AST.ExpType.Integer and arg.value == 1: #type: ignore [attr-defined]
                # Current free temporal memory
                self._emit_code("ld      hl,_startup_")
                self._emit_code("ld      de,(_memory_next)")
            else:
                # Free memory between the high limit and our program binary end
                self._emit_code(f"ld      hl,{FWCALL.HIGH_LIMIT}")
                self._emit_code("ld      de,_program_end_")
        self._emit_code("or      a")
        self._emit_code("sbc     hl,de")
        self._emit_code(";")

    def _emit_FUNCTION(self, node:AST.DefFUN) -> None:
        """
        Adopted from Locomotive BASIC 2 Plus, FUNCTION allows the program to define
        and use simple functions ended with END FUNCTION. Values are turned using
        RETURN call.
        It may be invoked throughout the program as regular functions. Variable types
        must be consistent and the FUNCTION command should be written in part of the
        program outside the execution loop AND BEFORE the function is called. 
        """
        self._emit_code("; FUNCTION <name> [(<formal parameters>)]=<general expression>")
        self._emit_code(";")
        self.context = node.name
        flabel = self._get_userfun_label(node.name)
        self.codestack.append(str(self.srccode))  # store current generated code
        self.srccode = ""                         # so we generate now sub body only
        self._emit_code(f"{flabel}:", 0)
        if not node.asm:
            # procedures decorated with ASM in the declaration doesn't need
            # to care about the temporal memory but may better use only
            # ASM code or something bad will happen!
            self._emit_push_memheap()
            entry = self.symtable.find(node.name, SymType.Function)
            if entry is not None:
                self._push_heapvalues()
                self.max_heap_memory = 0
            else:
                self._raise_error(2,node)


    def _emit_GOSUB(self, node:AST.Command) -> None:
        """
        Call a BASIC subroutine by branching to the specified line number or
        label. 
        """
        label = node.args[0]
        self._emit_code("; GOSUB <line number> | <label> ")
        if isinstance(label, AST.Integer) or isinstance(label, AST.Label):
            sym = self.symtable.find(str(label.value), SymType.Label, "")
            if sym is not None:
                self._emit_code(f"call    {sym.label}")
            else:
                self._raise_error(38, label)
        self._emit_code(";")

    def _emit_GOTO(self, node:AST.Command) -> None:
        """
        Branch to specified line number or label. 
        """
        label = node.args[0]
        self._emit_code("; GOTO <line number> | <label> ")
        if isinstance(label, AST.Integer) or isinstance(label, AST.Label):
            sym = self.symtable.find(str(label.value), SymType.Label, "")
            if sym is not None:
                self._emit_code(f"jp      {sym.label}")
            else:
                self._raise_error(38, label)
        self._emit_code(";")

    def _emit_GRAPHICS_PAPER(self, node:AST.Command) -> None:
        """
        Only available with BASIC 1.1
        Sets the <ink> of the graphics paper, ie. the area behind graphics drawn
        on the screen. When drawing continuous lines, the graphics papers will
        not be seen. The graphics paper's ink (in the range 0 to 15) is used for
        the paper area of characters written when TAG is in operation, and as the
        default when clearing the graphics window, using CLG. 
        """
        self._emit_code("; GRAPHICS PAPER <ink>")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"call    {FWCALL.GRA_SET_PAPER}", info="GRA_SET_PAPER")
        self._emit_code(";")

    def _emit_GRAPHICS_PEN(self, node:AST.Command) -> None:
        """
        Only available with BASIC 1.1
        Set the <ink> (in the range 0 to 15) to be used for drawing lines and
        plotting points. The graphics <background mode> can also be set to either:
            0: Opaque background.
            1: Transparent background.
        Transparent background affects the graphics paper of characters written
        with TAG on, and the gaps in dotted lines. Either parameter may be omitted,
        but not both. If a parameter is omitted, that particular setting is not changed. 
        """
        self._emit_code("; GRAPHICS PEN [<ink>][,<background mode>]")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"call    {FWCALL.GRA_SET_PEN}", info="GRA_SET_PEN")
        if len(node.args) == 2:
            self._emit_expression(node.args[1])
            self._raise_warning(WL.MEDIUM,"GRAPHICS PEN transparency is supported only by 664 and 6128 machines", node)
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.GRA_SET_BACK}", info="GRA_SET_BACK")
        self._emit_code(";")

    def _emit_HEXSS(self, node:AST.Function) -> None:
        """
        Converts the number given into Hexadecimal form. The second <int expr>
        can be used to specify the minimum length of the result. 
        """
        # prints 2 or 4 characters
        self._emit_import("rt_int2hex")
        self._emit_code("; HEX$(<int expr>[,<int expr>])")
        if len(node.args) == 2:
            self._emit_expression(node.args[1])
        else:
            self._emit_code("ld      hl,&0004")
        self._emit_code("push    hl")
        self._emit_expression(node.args[0])
        self._emit_code("ex      de,hl", info="number to convert")
        self._reserve_heapmem(5, node)
        self._emit_code("pop     bc", info="number of characters")
        self._emit_code("ld      a,c", info="only 2 or 4 are valid")
        self._emit_code("call    rt_int2hex")
        self._emit_code(";")

    def _emit_HIMEM(self, node:AST.Function) -> None:
        """
        Gives the address of the highest byte of memory used by BASIC, and can
        be used in numeric expressions in the usual way.
        """
        # In our case we use this to return the address where the compiled program
        # ends, which could be useful to issue Load commands
        self._emit_code("; HIMEM")
        self._emit_code("ld      hl,_program_end_")
        self._emit_code(";")

    def _emit_IF(self, node:AST.If) -> None:
        """
        It is used to conditionally determine branch points in a program. The
        logical part is evaluated, and if true the THEN or GOTO part is executed,
        if false, the program skips to the ELSE part, or merely passes onto the
        next line.
        """
        elselabel, endlabel = self._get_if_labels()
        node.else_label = elselabel
        node.end_label = endlabel
        self._emit_code("; IF <logical expr> THEN <option part> [ELSE <option part>]")
        self._emit_expression(node.condition)
        # clear temporal memory if used by the condition expression before
        # jumping. Modifies DE
        self._emit_free_heapmem()
        self._emit_code("ld      a,h")
        self._emit_code("or      l")
        if node.has_else:
            self._emit_code(f"jp      z,{elselabel}")
        else:
            self._emit_code(f"jp      z,{endlabel}")
        self._emit_code("; THEN")
        if len(node.inline_then):
            for stmt in node.inline_then:
                self._emit_statement(stmt)
            if node.has_else:
                self._emit_code(f"jp      {endlabel}")
            if len(node.inline_else):
                self._emit_code("; ELSE")
                self._emit_code(f"{elselabel}:", 0)
                for stmt in node.inline_else:
                    self._emit_statement(stmt)
            self._emit_code("; IFEND")
            self._emit_code(f"{endlabel}:", 0)
        else:
            self.ifblocks.append(node)

    def _emit_END_FUNCTION(self, node:AST.Command) -> None:
        """
        Signals the end of a user defined FUNCTION. BASIC returns to continue
        processing at the point after the expression which invoked it. Arriving
        here is usually an error, as RETURN must be used to send back a result
        of a function.
        """
        if len(self.codestack) == 0:
            self._raise_error(41, node)
        # Restore pointer to heap free memory
        if not node.args[0].asm:        # type: ignore [attr-defined]
            self._emit_pop_memheap()
            fretvar = self.context[3:]
            # Return value is stored in a local variable with the same name as the function
            # so we check that it exists or return an error
            entry = self.symtable.find(fretvar, SymType.Variable, self.context)
            if entry is not None:
                if entry.exptype == AST.ExpType.Integer:  
                    self._emit_code(f"ld      hl,({entry.label})")
                elif entry.exptype == AST.ExpType.String:
                    self._emit_code(f"ld      hl,{entry.label}")
                elif entry.exptype == AST.ExpType.Real:
                    self._emit_code(f"ld      hl,{entry.label}")
                else:
                    self._raise_error(2, node, info="invalid return type")
            else:
                self._raise_error(2, node, info="no return value in FUNCTION")
            self._emit_code("ret")
        subfun = str(self.srccode)
        self.srccode = self.codestack.pop()
        # we only really emit this code if the function was called
        entry = self.symtable.find(ident=self.context, stype=SymType.Function)
        if entry and entry.calls > 0:
            self._emit_data(subfun, 0)
            if not node.args[0].asm:        # type: ignore [attr-defined]
                entry.heapused = self.max_heap_memory
                self._pop_heapvalues()
            else:
                entry.heapused = 0
        self.context = ""

    def _emit_END_IF(self, node:AST.BlockEnd) -> None:
        if len(self.ifblocks) > 0:
            ifnode = self.ifblocks.pop()
            self._emit_code("; END IF")
            self._emit_code(f"{ifnode.end_label}:", 0)
            self._emit_code(";")
        else:
            self._raise_error(36, node)

    def _emit_END_SELECT(self, node:AST.BlockEnd) -> None:
        if len(self.selectblocks):
            sel = self.selectblocks.pop()
            self._emit_code("; END SELECT")
            self._emit_code(f"{sel.end_label}:")
            self._emit_code(";")
        else:
            self._raise_error(46, node)

    def _emit_END_SUB(self, node:AST.Command) -> None:
        """
        Signals the end of a subroutine. BASIC returns to continue processing at
        the point after the CALL which invoked it.
        """
        if len(self.codestack) == 0:
            self._raise_error(41, node)
        if not node.args[0].asm:        # type: ignore [attr-defined]
            self._emit_pop_memheap()
            self._emit_code("ret")
        subfun = str(self.srccode)
        self.srccode = self.codestack.pop()
        # we only really emit this code if the subrutine was called
        entry = self.symtable.find(ident=self.context, stype=SymType.Procedure)
        if entry and entry.calls > 0:
            self._emit_data(subfun, 0)
            if not node.args[0].asm:        # type: ignore [attr-defined]
                entry.heapused = self.max_heap_memory
                self._pop_heapvalues()
            else:
                entry.heapused = 0
        self.context = ""

    def _emit_INK(self, node:AST.Command) -> None:
        """
        Assigns colour(s) to a given ink. The <ink> parameter describes the ink
        reference, which must be an integer expression in the range 0 to 15, for
        use in the appertaining PEN or PAPER command. The first <colour>
        parameter should be an integer expression yielding a colour value in the
        range 0 to 26. If an optional second <colour> is specified, the ink
        alternates between the two colours, at a rate determined by SPEED INK
        command. Depending on the current screen mode, a number of INKs are
        available.
        NOTE: Ink values are not sent to the hardware until the next FLYBACK (VSYNC)
              event.
        """
        self._emit_code("; INK <ink>,<colour>[,<colour>]")
        self._emit_expression(node.args[1])
        if len(node.args) == 3:
            self._emit_code("push    hl")
            self._emit_expression(node.args[2])
            self._emit_code("ld      c,l", info="second color")
            self._emit_code("pop     de")
            self._emit_code("ld      b,e", info="first color")
        else:
            self._emit_code("ld      c,l", info="second color")
            self._emit_code("ld      b,l", info="first color")
        self._emit_code("push    bc")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code("pop     bc")
        self._emit_code(f"call    {FWCALL.SCR_SET_INK}", info="SCR_SET_INK")
        self._emit_code(";")

    def _emit_INKEY(self, node:AST.Function) -> None:
        """
        This function interrogates the keyboard to report which keys are being
        pressed. The keyboard is scanned at 1/50 sec. The function is particularly
        useful for spotting Y/N responses, since the state of shift is not required
        according to one of the interpretation options.
        [SHIFT] and [CTRL] are identified as follow:
        Value returned	[SHIFT]	[CTRL]	Specified key
        -1 	    ignored     ignored 	    UP
        0 	    UP 	        UP 	            DOWN
        32 	    DOWN 	    UP 	            DOWN
        128 	UP 	        DOWN 	        DOWN
        160 	DOWN 	    DOWN 	        DOWN 
        """
        self._emit_import("rt_inkey")
        self._emit_code("; INKEY(<integer expression>)")
        self._emit_expression(node.args[0])
        self._emit_code("call    rt_inkey")
        self._emit_code(";")

    def _emit_INKEYSS(self, node:AST.Function) -> None:
        """
        Reads a key from the keyboard to provide operator interaction without
        hitting [ENTER] after every answer. If there is a key pressed, then the
        function responds - if no key is pressed, it continues to return an
        empty string which is used to loop until a valid input is detected
        for processing.
        """
        self._emit_code("; INKEY$")
        self._emit_import("rt_inkeys")
        self._reserve_heapmem(2, node)
        self._emit_code("call    rt_inkeys")
        self._emit_code(";")

    def _emit_INP(self, node:AST.Function) -> None:
        """
        A function that returns the input value from the I/O port specified in the address. 
        """
        self._emit_code("; INP(<port number>)")
        self._emit_expression(node.args[0])
        self._emit_code("ld      c,l")
        self._emit_code("ld      b,h")
        self._emit_code("in      a,(c)")
        self._emit_code("ld      l,a")
        self._emit_code("ld      h,0")
        self._emit_code(";")

    def _emit_INPUT(self, node:AST.Input, carriage=True) -> None:
        """
        Reads data from the stated stream. A semicolon after INPUT suppresses the
        carriage return typed at the end of the line being entered. A semicolon
        after the <quoted string> causes a question mark to be displayed.
        A comma suppresses the question mark. All responses must be terminated
        with an [ENTER].
        """
        self._emit_import("rt_input")
        self._emit_code("; INPUT [#<stream>][;][<quoted string>,]<list: [var]>")
        if node.stream is not None:
            self._emit_expression(node.stream)
            self._emit_stream()
        if node.prompt != "":
            self._print_str(AST.String(value=node.prompt))
        if node.question:
            self._emit_code("ld      hl,rt_input_question")
            self._emit_code("call    rt_print_str")
        # Ask for values and check that we get as many values as variables
        inputs = len(node.vars)
        lstart, lend = self._get_while_labels()
        self._emit_code(lstart, 0)
        self._emit_code("call    rt_input")
        if carriage:
            self._emit_code("call    rt_print_nl")
        self._emit_code("ld      a,c", info="check all quoted strings are terminated")
        self._emit_code("and     &01", info="the count must be even so A turns 0")
        self._emit_code("add     b", info="number of substrings")
        self._emit_code(f"cp      {inputs}", info="number of given variables")
        self._emit_code(f"jr      z,{lend}")
        self._emit_code("ld      hl,rt_input_redo")
        self._emit_code("call    rt_print_str")
        self._emit_code(f"jr      {lstart}")
        self._emit_code(lend, 0)
        self._emit_code("ld      hl,rt_input_buf")
        for v in node.vars:
            self._emit_code("call    rt_extract_substrz")
            self._emit_code("push    hl", info="current position in input buffer")
            self._emit_pointer(v)
            entry = self.symtable.find(v.name, SymType.Variable, self.context)
            if entry is None:
                entry = self.symtable.find(v.name, SymType.Array, self.context)
            if entry is not None:
                self._emit_code(f"; identifier {v.name}")
                if v.etype == AST.ExpType.String:
                    self._emit_input_str()
                elif v.etype == AST.ExpType.Integer:
                    self._emit_input_int()
                elif v.etype == AST.ExpType.Real:
                    self._emit_input_real(v, entry)
            else:
                self._raise_error(2, v, "unknown identifier")
            self._emit_code("pop     hl", info="ready for next substring")
        if node.stream is not None:
            self._emit_stream_0()
        self._emit_code(";")

    def _emit_input_str(self) -> None: 
        self._emit_code("ld      de,rt_scratch_pad")
        self._emit_code("ld      (hl),c", info="string len")
        self._emit_code("inc     hl")
        self._emit_code("ex      de,hl")
        self._emit_code("ld      b,0")
        self._emit_code("ldir")

    def _emit_input_int(self) -> None:
        self._emit_import("rt_strz2num")
        self._emit_code("push    hl")
        self._emit_code("ld      de,rt_scratch_pad")
        self._emit_code("call    rt_strz2num")
        self._emit_code("ex      de,hl")
        self._emit_code("pop     hl")
        self._emit_code("ld      (hl),e")
        self._emit_code("inc     hl")
        self._emit_code("ld      (hl),d")
        
    def _emit_input_real(self, v:AST.Variable | AST.ArrayItem, var: SymEntry) -> None:
        self._emit_import("rt_strz2real")
        self._emit_import("rt_move_real")
        self._emit_pushcontext()
        self._emit_code("push    hl")
        self._emit_code("ld      de,rt_scratch_pad")
        self._emit_code("call    rt_strz2real")
        self._emit_code("pop     de")
        self._emit_code("call    rt_move_real")
        self._emit_popcontext()

    def _emit_INSTR(self, node:AST.Function) -> None:
        """
        Searches the first string expression, for the first occurance of the second
        string expression), where the optional number at the start indicates where
        to start the search - otherwise the search begins at the first character of
        the first string expression (default for start is 1, 0 produces error). 
        """
        self._emit_import("rt_findstr")
        self._emit_code("; INSTR(<integer expression>,<string expression>,<string expression>)")
        self._emit_expression(node.args[-1])
        self._emit_code("push    hl", info="substring to find")
        self._emit_expression(node.args[-2])
        if len(node.args) == 3:
            self._emit_code("push    hl")
            self._emit_expression(node.args[0])
            self._emit_code("ld      b,l")
            self._emit_code("pop     hl")
        else:
            self._emit_code("ld      b,1")
        self._emit_code("pop     de")
        self._emit_code("call    rt_findstr")
        self._emit_code(";")

    def _emit_INT(self, node:AST.Function) -> None:
        """
        Rounds the number to the nearest lower integer, removing any fractional
        part. The same as FIX for positive numbers, but returns one less than FIX
        for negative numbers not already integers.
        """
        self._emit_code("; INT(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        if node.args[0].etype == AST.ExpType.Real:
            self._emit_import("rt_real_int")
            self._moveflo_accum1()
            self._emit_code("call    rt_real_int")
        else:
            self._emit_code("; already INT so no action taken")
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_JOY(self, node:AST.Function) -> None:
        """
        The JOY function reads a bit-significant result from the joystick specified
        in the <integer expression> (either 0 or 1).
        Bit	Decimal 	Joystick
        0 	    1 	    Up
        1 	    2 	    Down
        2 	    4 	    Left
        3 	    8 	    Right
        4 	    16 	    Fire 2
        5 	    32 	    Fire 1 
        """
        self._emit_code("; JOY(<integer expression>)")
        self._emit_expression(node.args[0])
        self._emit_code("ex      de,hl", info="keep joystick number in DE")
        self._emit_code(f"call    {FWCALL.KM_GET_JOYSTICK}", info="KM_GET_JOYSTICK")
        self._emit_code("ld      a,e")
        self._emit_code("or      a")
        self._emit_code("jr      nz,$+3")
        self._emit_code("ld      l,h")
        self._emit_code("ld      h,0")
        self._emit_code(";")

    def _emit_KEY(self, node:AST.Command) -> None:
        """
        Fixes a new function key definition. There are thirty two keyboard expansion
        characters in the range 128-159. When one of these characters is read it is
        expanded into the string associated with it, although the total number of
        expansion characters cannot exceed 100. The KEY command associates a string
        with a given expansion character. 
        """
        self._emit_code("; KEY <integer expression>,<string expression>")
        self._raise_warning(WL.MEDIUM, "KEY is ignored and has not effect", node)
        self._emit_code("; IGNORED")

    def _emit_KEY_DEF(self, node:AST.Command) -> None:
        """
        DEFines the KEY values to be returned by the specified <key number> in the
        range 0 to 79. The <normal>, <shifted> and <control> parameters should contain
        the values required to be returned when the key is pressed, alone, together
        with [SHIFT], and together with [CTRL], respectively. Each of these parameters
        is optional. The <repeat> parameter enables you to set the key auto-repeat
        function ON or OFF (1 or 0), the rate of auto-repeat being adjustable by use
        of the SPEED KEY command. 
        """
        self._emit_code("; KEY DEF <key number>,<repeat>[,<normal>[,<shifted>[,<control>]]]")
        self._raise_warning(WL.MEDIUM, "KEY DEF is ignored and has not effect", node)
        self._emit_code("; IGNORED")

    def _emit_LABEL(self, node:AST.Label) -> None:
        """
        Only available on BASIC 2.0
        """
        sym = self.symtable.find(node.value, SymType.Label, "")
        if sym is not None:
            self._emit_code(f"{sym.label}:", info="USER DEFINED LABEL")
        else:
            self._raise_error(38, node)

    def _emit_LEFTSS(self, node:AST.Function) -> None:
        """
        Extracts characters to the left of, and including the position specified
        in the <integer expression> from the the given <string expression>. If the
        <str expr> is shorter than the required length, the whole <str expr> is
        re-turned. 
        """
        self._emit_import("rt_strleft")
        self._emit_code("; LEFT$(<string expression>,<integer expression>)")
        self._emit_expression(node.args[-1])
        self._emit_code("push    hl")
        self._emit_expression(node.args[0])
        self._reserve_heapmem_de(255, node)
        self._emit_code("pop     bc")
        self._emit_code("call    rt_strleft")
        self._emit_code(";")

    def _emit_LEN(self, node:AST.Function) -> None:
        """
        Returns a number corresponding to the number of all types of characters,
        including spaces, in the <string expression>. 
        """
        self._emit_code("; LEN(<string expression>)")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,(hl)")
        self._emit_code("ld      l,a")
        self._emit_code("ld      h,0")
        self._emit_code(";")

    def _emit_LET(self, node:AST.Command) -> None:
        """
        A remnant from early BASICS where variable assignments had to be seen coming.
        No use apart from providing compatibility with the programs supplied in
        early BASIC training manuals. 
        """
        self._emit_code("; LET - NOTHING TO DO")

    def _emit_LINE_INPUT(self, node:AST.LineInput) -> None:
        """
        Reads an entire line from the stream indicated. The first optional semicolon suppresses
        the echo of carriage return / line feed. The default <stream expression> is, as always,
        #0 :screen. 
        """
        self._emit_code("; LINE INPUT [<#stream expression>,][;][quoted string; ]<string variable>")
        fileinput = False
        if node.stream:
            if isinstance(node.stream, AST.Integer):
                self._emit_expression(node.stream)
                self._emit_stream()
                if node.stream.value == 9: fileinput = True
            else:
                self._raise_error(2, node.stream, info="stream must be an integer")
        if fileinput:
            self._emit_import("rt_freadstr")
            if node.prompt != "":
                self._print_str(AST.String(value=node.prompt))
            if node.question:
                self._emit_import("rt_input")
                self._emit_code("ld      hl,rt_input_question")
                self._emit_code("call    rt_print_str")
            self._emit_pointer(node.var)
            self._emit_code("call    rt_freadstr")
            if node.carriage:
                self._emit_import("rt_print_nl")
                self._emit_code("call    rt_print_nl")
        else:
            # like a regular INPUT
            self._emit_INPUT(AST.Input(
                stream=None,
                prompt=node.prompt,
                question=node.question,
                vars=[node.var],
            ), carriage=node.carriage)
        if node.stream:
            self._emit_stream_0()
        self._emit_code(";")

    def _emit_LIST(self, node:AST.Command) -> None:
        """
        List program lines to the given stream. 0 is the default screen, 8 is
        the printer.
        """
        self._emit_code("; LIST [<line number range>][,#<strea m expression>]")
        self._raise_warning(WL.MEDIUM, "LIST is ignored and has not effect", node)
        self._emit_code("; IGNORED")

    def _emit_LOAD(self, node:AST.Command) -> None:
        """
        To read a BASIC program from disc or cassette into memory, replacing any
        existing program. Specifying the optional <address expression> will cause
        a binary file to be loaded at that address, rather than the address from
        which it was saved.
        A protected BASIC program can NOT be loaded using the LOAD command as it
        will be immediately deleted from memory. Instead, use the RUN or CHAIN
        commands.
        """
        self._emit_code("; LOAD <file name>[, <address expression>]")
        if len(node.args) == 1:
            self._emit_import("rt_load")
            self._emit_expression(node.args[0])
            self._emit_code("call    rt_load")
        else:
            self._emit_import("rt_loadaddr")
            self._emit_expression(node.args[1])
            self._emit_code("push    hl")
            self._emit_expression(node.args[0])
            self._emit_code("pop     de")
            self._emit_code("call    rt_loadaddr")
        self._emit_code(";")

    def _emit_LOCATE(self, node:AST.Command) -> None:
        """
        Moves the text cursor at the stream indicated, to the position specified
        by the x and y co-ordinates, which are relative to the origin of the
        stream (WINDOW). Stream 0 is the default stream.
        """
        self._emit_code("; LOCATE [#<stream expression>,] <x coord>,<y coord>")
        args = node.args
        if len(args) == 3:
            self._emit_expression(args[0])
            self._emit_stream()
            args = args[1:]
        self._emit_expression(args[0])
        self._emit_code("push    hl", info="X coord")
        self._emit_expression(args[1])
        self._emit_code("pop     de")
        self._emit_code("ld      h,e")
        self._emit_code(f"call    {FWCALL.TXT_SET_CURSOR}", info="TXT_SET_CURSOR")
        if len(node.args) == 3:
            self._emit_stream_0()
        self._emit_code(";")

    def _emit_LOG(self, node:AST.Function) -> None:
        """
        Calculates the natural logarithm of numeric expression. 
        """
        self._emit_import("rt_math_call")
        self._emit_code("; LOG(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        self._moveflo_accum1()
        self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_LOG}", info="MATH_REAL_LOG")
        self._emit_code("call    rt_math_call")
        self._moveflo_heap(node)
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_LOG10(self, node:AST.Function) -> None:
        """
        Calculates the base 10 logarithm of numeric expression. 
        """
        self._emit_import("rt_math_call")
        self._emit_code("; LOG10(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        self._moveflo_accum1()
        self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_LOG_10}", info="MATH_REAL_LOG_10")
        self._emit_code("call    rt_math_call")
        self._moveflo_heap(node)
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_LOWERSS(self, node:AST.Function) -> None:
        """
        Returns a new string expression the same as the input string expression but
        in which all upper case characters are converted to lower case. Useful for
        processing input where the answers may come in mixed upper/lower case. 
        """
        self._emit_import("rt_lower")
        self._emit_code("; LOWER$(<string expression>)")
        self._emit_expression(node.args[0])
        self._reserve_heapmem_de(255, node)
        self._emit_code("call    rt_lower")
        self._emit_code(";")

    def _emit_MASK(self, node:AST.Command) -> None:
        """
        Only available with BASIC 1.1
        Sets the mask or template to be used when drawing lines. The binary value
        of the <int expr> in the range 0 to 255, sets the bits in each adjacent
        group of 8 pixels to ON (1) or OFF (0).
        The <first point setting> determines whether the first point of the line
        is to be plotted (1) or not plotted (0).
        Either of the parameters may be omitted, but not both. If a parameter is
        omitted, that particular setting is not changed. 
        """
        self._emit_code("; MASK [<integer expression>l[,<first point setting>]")
        self._raise_warning(WL.HIGH,"MASK is supported only by 664 and 6128 machines", node)
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"call    {FWCALL.GRA_SET_LINEMASK}", info="GRA_SET_LINEMASK")
        if len(node.args) == 2:
            self._emit_expression(node.args[1])
            self._emit_code("ld      a,l")
            self._emit_code("or      a")
            self._emit_code("jr      z,$+4")
            self._emit_code("ld      a,&FF")
            self._emit_code(f"call     {FWCALL.GRA_SET_FIRST}", info="GRA_SET_FIRST")
        self._emit_code(";")

    def _emit_MAX(self, node:AST.Function) -> None:
        """
        Extracts the largest value from the list of numeric expressions. 
        """
        self._emit_code("; MAX(<list of: numeric expression>))")
        if node.etype == AST.ExpType.Integer:
            self._emit_import("rt_max")
            self._emit_expression(node.args[0])
            for a in node.args[1:]:
                self._emit_code("push    hl")
                self._emit_expression(a)
                self._emit_code("pop     de")
                self._emit_code("call    rt_max")
        else:
            self._emit_import("rt_maxreal")
            self._emit_expression(node.args[0])
            self._moveflo_accum1()
            for a in node.args[1:]:
                self._emit_expression(a)
                self._moveflo_accum2()
                self._emit_code("call    rt_maxreal")
            self._emit_code("ld      hl,rt_math_accum1")
            self._moveflo_heap(node)
        self._emit_code(";")

    def _emit_MEMORY(self, node:AST.Command) -> None:
        """
        Reset BASIC memory parameters to change the amount of BASIC memory
        available by setting the address of the highest byte. See the description
        of the keyword HIMEM. To examine the amount of memory, use the FRE command. 
        """
        # In our case, MEMORY sets the limit for the compiled program so
        # it gives an error if the output binary exceedes that limit
        self._emit_code("; MEMORY <address expression>")
        limit = node.args[0]
        if isinstance(limit, AST.Integer):
            self.memlimit = min(self.memlimit, cast(int, limit.value))
        else:
            self._raise_error(2, node, "MEMORY can be evaluated only at compiling time")
        self._emit_code(";")

    def _emit_MERGE(self, node:AST.Statement) -> None:
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MIDSS(self, node:AST.Function) -> None:
        """
        MID$ specifies part of a string (a sub-string) which can be used either as
        the destination of an assignment (MID$ as a command) or as an argument in
        a string expression (MID$ as a Function). The first <integer expression>
        specifies the position of the first character of the sub-string.
        The second <integer expression> specifies the length of the sub-string
        to be returned. If omitted, this extends to the end of the original string. 
        """
        # In our case this cannot be used as a Command only as a Function
        self._emit_import("rt_substr")
        self._emit_code("; MID$(<string>, <integer expression> [, <integer expression>]))")
        self._emit_expression(node.args[1])
        self._emit_code("push    hl")
        if len(node.args) == 3:
            self._emit_expression(node.args[2])
            self._emit_code("pop     bc")
            self._emit_code("ld      b,l")
            self._emit_code("push    bc")
        self._emit_expression(node.args[0])
        self._reserve_heapmem_de(255, node)
        self._emit_code("pop     bc")
        self._emit_code("call    rt_substr")
        self._emit_code(";")

    def _emit_MIN(self, node:AST.Function) -> None:
        """
        Extracts the smallest value from the list of numeric expressions. 
        """
        self._emit_import("rt_max")
        self._emit_code("; MIN(<list of: <numeric expression>))")
        if node.etype == AST.ExpType.Integer:
            self._emit_expression(node.args[0])
            for a in node.args[1:]:
                self._emit_code("push    hl")
                self._emit_expression(a)
                self._emit_code("pop     de")
                self._emit_code("call    rt_max")
                self._emit_code("ex      de,hl")
        else:
            self._emit_import("rt_maxreal")
            self._emit_expression(node.args[0])
            self._moveflo_accum2()
            for a in node.args[1:]:
                self._emit_expression(a)
                self._moveflo_accum1()
                self._emit_code("call    rt_maxreal")
            self._emit_code("ld      hl,rt_math_accum2")
            self._moveflo_heap(node)
        self._emit_code(";")

    def _emit_MODE(self, node:AST.Command) -> None:
        """
        Change the screen mode (0,1 or 2), and clear the screen to INK 0, which
        may not be the current PAPER ink. All text and graphics WINDOWS are reset
        to the whole screen, and the text and graphics cursors homed to their
        respective origins. 
        """
        self._emit_code("; MODE <integer expression>")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"call    {FWCALL.SCR_SET_MODE}", info="SCR_SET_MODE")

    def _emit_MOVE(self, node:AST.Command) -> None:
        """
        <ink> and <ink mode> are only available with BASIC 1.1
        To move the graphics cursor to a position specified by the absolute co-ordinates.
        YPOS and XPOS are the corresponding functions to establish the current
        graphics cursor position.
        The optionnal <ink> parameter can be used to specify the graphic pen
        (in the range 0 to 15). The optional <ink mode> determines how the ink
        being written interacts with that already on the graphics screen.
        The four <ink mode>s are:
        0: FILL (Normal)
        1: XOR (eXclusive OR)
        2: AND
        3: OR
        """
        self._emit_code("; MOVE <x co-ordinate>,<y co-ordinate>[,<ink>][,<ink mode>]")
        if len(node.args) > 2:
            self._emit_expression(node.args[2])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.GRA_SET_PEN}", info="GRA_SET_PEN")
        if len(node.args) > 3:
            self._emit_expression(node.args[3])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.SCR_ACCESS}", info="SCR_ACCESS")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code(f"call    {FWCALL.GRA_MOVE_ABSOLUTE}", info="GRA_MOVE_ABSOLUTE")
        self._emit_code(";")

    def _emit_MOVER(self, node:AST.Command) -> None:
        """
        <ink> and <ink mode> are only available with BASIC 1.1
        To move the graphics cursor to a position relative to the current co-ordinates.
        YPOS and XPOS are the corresponding functions to establish the current graphics
        cursor position. The optionnal <ink> parameter can be used to specify the
        graphic pen (in the range 0 to 15). The optional <ink mode> determines how the
        ink being written interacts with that already on the graphics screen.
        The four <ink mode>s are:
        0: FILL (Normal)
        1: XOR (eXclusive OR)
        2: AND
        3: OR
        """
        self._emit_code("; MOVER <x co-ordinate>,<y co-ordinate>[,<ink>][,<ink mode>]")
        if len(node.args) > 2:
            self._emit_expression(node.args[2])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.GRA_SET_PEN}", info="GRA_SET_PEN")
        if len(node.args) > 3:
            self._emit_expression(node.args[3])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.SCR_ACCESS}", info="SCR_ACCESS")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code(f"call    {FWCALL.GRA_MOVE_RELATIVE}", info="GRA_MOVE_RELATIVE")
        self._emit_code(";")

    def _emit_NEW(self, node:AST.Statement) -> None:
        """
        Delete current program and variables. KEY definitions are not lost,
        and the display is not cleared.
        """
        # In our case this just resets the computer
        self._emit_code("; NEW")
        self._emit_code("call    0", info="MACHINE RESET")
        self._emit_code(";")

    def _emit_NEXT(self, node:AST.BlockEnd) -> None:
        fornode = self.forloops.pop()
        self._emit_code("; NEXT [<variable>]")
        self._emit_code(f"ld      hl,({fornode.var_label})")
        if fornode.step is not None:
            self._emit_code("pop     bc", info="STEP value")
            self._emit_code("add     hl,bc")
            self._emit_code("push    bc")
        else:
            self._emit_code("inc     hl")
        self._emit_code(f"ld      ({fornode.var_label}),hl")
        self._emit_code(f"jp      {fornode.start_label}")
        self._emit_code(f"{fornode.end_label}:", 0)
        if fornode.step is not None:
            self._emit_code("pop     bc")
        self._emit_code("pop     hl")
        self._emit_code(";")

    def _emit_ON_GOSUB(self, node:AST.Command) -> None:
        """
        GOSUB to the subroutine as directed by the result of the <int expr>.
        If the result is 1, then the first line number in the list is chosen,
        if 2 then the second etc.
        """
        self._emit_code("; ON <integer expression> GOSUB <list of:<line number>")
        self._emit_onjump(node)
        self._emit_code("call    rt_onjump")
        self._emit_code(";")

    def _emit_ON_GOTO(self, node:AST.Command) -> None:
        """
        GOTO to the statement as directed by the result of the <int expr>.
        If the result is 1, then the first line number in the list is chosen,
        if 2 then the second etc.
        """
        self._emit_code("; ON <integer expression> GOTO <list of:<line number>")
        self._emit_onjump(node)
        self._emit_code("jp      rt_onjump")
        self._emit_code(";")

    def _emit_onjump(self, node:AST.Command) -> None:
        self._emit_import("rt_onjump")
        addresses = self._get_onjump_label()
        datastr = ""
        for a in node.args[1:]:
            sym = None
            if isinstance(a, AST.Integer):
                sym = self.symtable.find(str(a.value), SymType.Label, "")
            elif isinstance(a, AST.Label):
                sym = self.symtable.find(a.value, SymType.Label, "")
            if sym is not None:
                datastr = datastr + f"{sym.label},"
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"ld      b,{len(node.args[1:])}")
        self._emit_code(f"ld      de,{addresses}")
        addresses = addresses + f": dw {datastr[:-1]}"
        self._emit_data(addresses, section=DataSec.CONST)

    def _emit_ON_BREAK_CONT(self, node:AST.Command) -> None:
        """
        ON BREAK CONT disables the option to break a program pressing
        the escape key twice.
        """
        # This is the default state and we don't support ON BREAK GOSUB
        # so we do nothing here.
        self._emit_code("; ON BREAK CONT")
        self._emit_code(";")

    def _emit_ON_BREAK_STOP(self, node:AST.Command) -> None:
        """
        ON BREAK STOP disables the trap created by ON BREAK GOSUB,
        but has no other immediate effect.
        """
        # This is the default state and we don't support ON BREAK GOSUB
        # so we do nothing here.
        self._emit_code("; ON BREAK STOP")
        self._emit_code(";")

    def _emit_ON_BREAK_GOSUB(self, node:AST.Command) -> None:
        """
        Calls a subroutine on breaking from program execution by pressing [ESC]
        twice.
        """
        self._emit_code("; ON BREAK GOSUB <line number> | STOP")
        self._raise_warning(WL.MEDIUM, "ON BREAK GOSUB is ignored and has not effect", node)
        self._emit_code("; IGNORED")

    def _emit_ON_ERROR_GOTO(self, node:AST.Command) -> None:
        """
        Go to a specified line number in the program on detecting an error. 
        """
        # In our case, we jump to the label if ERR variable is <> 0
        self._emit_code("; ON ERROR GOTO <line number> | <label> ")
        self._emit_import("rt_error")
        label = node.args[0]
        if isinstance(label, AST.Integer) or isinstance(label, AST.Label):
            self._emit_code("ld      a,(rt_error)")
            self._emit_code("cp      0")
            sym = self.symtable.find(str(label.value), SymType.Label, "")
            if sym is not None:
                self._emit_code(f"jp      nz,{sym.label}")
            else:
                self._raise_error(38, label)
        self._emit_code(";")

    def _emit_ON_SQ(self, node:AST.Command) -> None:
        """
        Enable an interrupt for when there is a free slot in the given sound queue.
        The <channel> is an integer expression yielding one of the values:
        1: for channel A
        2: for channel B
        4: for channel C
        """
        self._emit_import("rt_onsq")
        self._emit_code("; ON SQ (<channel>) GOSUB <line number>")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        label = node.args[1]
        if isinstance(label, AST.Integer) or isinstance(label, AST.Label):
            sym = self.symtable.find(str(label.value), SymType.Label, "")
            if sym is not None:
                self._emit_code(f"ld      de,{sym.label}")
            else:
                self._raise_error(38, label)
        self._emit_code("call    rt_onsq")
        self._emit_code(";")

    def _emit_OPENIN(self, node:AST.Command) -> None:
        """
        Opens an input file from disc or cassette which contains information for
        use in the current program in the computer's memory.
        If tape deck is selected and the first character in the <file name> is !
        then the displayed cassette processing messages are suppressed. The program
        reads in the first block from the cassette, ready for processing.
        The input file to open myst be an ASCII file. 
        """
        self._emit_import("rt_fileinbuf")
        self._emit_code("; OPENIN <filename>")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        self._emit_code("ld      b,(hl)")
        self._emit_code("inc     hl")
        self._emit_code("ld      de,rt_fileinbuf", info="2K buffer to contain the data")
        self._emit_code(f"call    {FWCALL.CAS_IN_OPEN}", info="CAS_IN_OPEN")
        self._emit_code("ex      de,hl")
        self._emit_code("xor     a")
        self._emit_code("jr      c,$+4", info="if CF the file was open")
        self._emit_code("ld      a,31", info="File not open error code")
        self._emit_code("ld      (rt_error),a", info="update ERR")
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_OPENOUT(self, node:AST.Command) -> None:
        """
        Opens an output file onto disc or cassette. If the tape deck is selected
        and the first character in the <file name> is ! then the displayed cassette
        processing messages are suppressed. The program creates the first block of data,
        in the file with the given name. Each block consists of up to 2048 bytes of data. 
        """
        self._emit_import("rt_fileoutbuf")
        self._emit_code("; OPENOUT <filename>")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        self._emit_code("ld      b,(hl)")
        self._emit_code("inc     hl")
        self._emit_code("ld      de,rt_fileoutbuf", info="2K buffer to contain the data")
        self._emit_code(f"call    {FWCALL.CAS_OUT_OPEN}", info="CAS_OUT_OPEN")
        self._emit_code("ex      de,hl")
        self._emit_code("xor     a")
        self._emit_code("jr      c,$+4", info="if CF the file was open")
        self._emit_code("ld      a,31", info="File not open error code")
        self._emit_code("ld      (rt_error),a", info="update ERR")
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_ORIGIN(self, node:AST.Command) -> None:
        """
        Determines the start point for the graphics cursor. The [optional part]
        of the command contains the instructions to set a new graphics window,
        which will be operational in all screen modes due the pixel addressing
        technique employed. The ORIGIN is the point with co-ordinates 0,0
        (co-ordinates grow up and right). If any of the window edges are specified
        to a position that is off the screen, they are assumed to represent the
        furthest visible position in the given direction. 
        """
        self._emit_code("; ORIGIN <x>,<y>[<left>,<right>,<top>,<bottom>]")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code(f"call    {FWCALL.GRA_SET_ORIGIN}", info="GRA_SET_ORIGIN")
        if len(node.args) > 2:
            # change graphics window dimensions
            self._emit_expression(node.args[2])
            self._emit_code("push    hl")
            self._emit_expression(node.args[3])
            self._emit_code("pop     de")
            self._emit_code(f"call    {FWCALL.GRA_WIN_WIDTH}", info="GRA_WIN_WIDTH")
            self._emit_expression(node.args[4])
            self._emit_code("push    hl")
            self._emit_expression(node.args[5])
            self._emit_code("pop     de")
            self._emit_code(f"call    {FWCALL.GRA_WIN_HEIGHT}", info="GRA_WIN_HEIGHT")
        self._emit_code(";")

    def _emit_OUT(self, node:AST.Command) -> None:
        """
        Sends the value in the <integer expression> (which must lie in the range
        0 to 255) to the port address specified in the <port number>.
        """
        self._emit_code("; OUT <port number> , <integer expression>")
        self._emit_expression(node.args[1])
        self._emit_code("ld      a,l")
        self._emit_expression(node.args[0])
        self._emit_code("ld      c,l")
        self._emit_code("ld      b,h")
        self._emit_code("out     (c),a")
        self._emit_code(";")

    def _emit_PAPER(self, node:AST.Command) -> None:
        """
        Sets the background ink for characters. When characters are written to
        the text screen, the character cell is filled with the PAPER ink before
        the character is written, unless the transparent mode has been selected. 
        """
        self._emit_code("; PAPER [#<stream expression>,]<masked ink>")
        args = node.args
        if len(args) == 2:
            self._emit_expression(args[0])
            self._emit_stream()
            args = args[1:]
        self._emit_expression(args[0])
        self._emit_code("ld      a,l", info="color")
        self._emit_code(f"call    {FWCALL.TXT_SET_PAPER}", info="TXT_SET_PAPER")
        if len(node.args) == 2:
            self._emit_stream_0()
        self._emit_code(";")


    def _emit_PEEK(self, node:AST.Function) -> None:
        """
        Examine the contents of a memory location specified in the <address>
        which should be in the range &0000 to &FFFF (0 to 65535). In all cases
        PEEK will return the value at the RAM address specified (not the ROM),
        and will be in the range &00 to &FF (0 to 255).
        """
        self._emit_code("; PEEK(<address expression>)")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,(hl)")
        self._emit_code("ld      h,0")
        self._emit_code("ld      l,a")
        self._emit_code(";")

    def _emit_PEN(self, node:AST.Command) -> None:
        """
        PEN sets the ink to be used when drawing at the given screen stream,
        defaulting to screen #0. 
        """
        self._emit_code("; PEN [#<stream expression>, ]<masked ink>")
        args = node.args
        if len(args) == 2:
            self._emit_expression(args[0])
            self._emit_stream()
            args = args[1:]
        self._emit_expression(args[0])
        self._emit_code("ld      a,l", info="color")
        self._emit_code(f"call    {FWCALL.TXT_SET_PEN}", info="TXT_SET_PEN")
        if len(node.args) == 2:
            self._emit_stream_0()
        self._emit_code(";")

    def _emit_PI(self, node:AST.Statement) -> None:
        """
        The value of the ratio between the circumference and the diameter of a circle.
        It is used extensively in graphics routines such as the one listed above. 
        """
        self._emit_import("rt_math_call")
        self._emit_code("; PI")
        self._emit_pushcontext()
        self._emit_code("ld      hl,rt_math_accum1")
        self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_PI}", info="MATH_REAL_PI")
        self._emit_code("call    rt_math_call")
        self._moveflo_heap(node)
        self._emit_popcontext()
        self._emit_code(";")
    
    def _emit_PLOT(self, node:AST.Command) -> None:
        """
        <ink mode> is only available with BASIC 1.1
        Plots a point on the graphics screen at the absolute position specified
        in the x,y co-ordinates. The <ink> in which to plot the point may be
        specified (in the range 0 to 15).
        The optional <ink mode> determines how the ink being written interacts
        with that already on the graphics screen. The four <ink mode>s are:
        0: FILL (Normal)
        1: XOR (eXclusive OR)
        2: AND
        3: OR
        """
        self._emit_code("; PLOT <x co-ordinate>,<y co-ordinate>[,<ink>][,<ink mode>]")
        if len(node.args) > 2:
            self._emit_expression(node.args[2])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.GRA_SET_PEN}", info="GRA_SET_PEN")
        if len(node.args) > 3:
            self._emit_expression(node.args[3])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.SCR_ACCESS}", info="SCR_ACCESS")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code(f"call    {FWCALL.GRA_PLOT_ABSOLUTE}", info="GRA_PLOT_ABSOLUTE")
        self._emit_code(";")

    def _emit_PLOTR(self, node:AST.Command) -> None:
        """
        <ink> and <ink mode> are only available with BASIC 1.1
        Plots a point on the graphics screen at the specified position <x offset>
        and <y offset>, relative to the current graphics cursor position. The <ink>
        in which to plot the point may be specified (in the range 0 to 15).
        The four <ink mode>s are:
        0: FILL (Normal)
        1: XOR (eXclusive OR)
        2: AND
        3: OR
        """
        self._emit_code("; PLOTR <x offset>,<y offset>[,<ink>][,<ink mode>]")
        if len(node.args) > 2:
            self._emit_expression(node.args[2])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.GRA_SET_PEN}", info="GRA_SET_PEN")
        if len(node.args) > 3:
            self._emit_expression(node.args[3])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.SCR_ACCESS}", info="SCR_ACCESS")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code(f"call    {FWCALL.GRA_PLOT_RELATIVE}", info="GRA_PLOT_RELATIVE")
        self._emit_code(";")

    def _emit_POKE(self, node:AST.Command) -> None:
        """
        Provides direct access to the machine memory. Writes the <int expr> in
        the range 0 to 255 directly into the machine memory (RAM) at the
        specified <address expression>. 
        """
        self._emit_code("; POKE <address expression>, <integer expression>")
        self._emit_expression(node.args[1])
        self._emit_code("push    hl", info="value to write")
        self._emit_expression(node.args[0])
        self._emit_code("pop     de")
        self._emit_code("ld      (hl),e")
        self._emit_code(";")

    def _emit_POS(self, node:AST.Function) -> None:
        """
        Reports the current horizontal POSition of the text cursor relative to
        the leftedge of the text window. The <stream expression> MUST be specified,
        and does NOT default to #0. 
        """
        self._emit_code("; POS(#<int_expression>)")
        self._emit_expression(node.args[0])
        self._emit_stream()
        self._emit_code("ld      b,a", info="keep previous stream")
        self._emit_code(f"call    {FWCALL.TXT_GET_CURSOR}", info="TXT_GET_CURSOR")
        self._emit_code("ld      l,h")
        self._emit_code("ld      h,0")
        self._emit_code("push    hl")
        self._emit_code("ld      l,b")
        self._emit_stream()
        self._emit_code("pop     hl")
        self._emit_code(";")

    def _emit_PRINT(self, node:AST.Print) -> None:
        """
        Prints the list of: <print items>s to the given stream (to stream #0 if
        <stream expression> is not specified). Note that when a semicolon is
        used to tell the computer to print the following <print item> next to
        the preceding item, BASIC first checks to see if the following
        <print item> can fit onto the same line. If not, it will be printed on a
        new line regardless of the semicolon. Note that when a coma is used to
        tell the computer to print the following <print item> in the next print
        zone, BASIC first checks to see that the preceding item has not exceeded
        the lenght of the current zone. If it has, the following <print item>
        is printed in a further zone. 
        """
        self._emit_code("; PRINT [#<stream expression>,][list of: <print item>]")
        if node.stream is not None:
            self._emit_expression(node.stream)
            self._emit_stream()
        for item in node.items:
            if isinstance(item, AST.Separator):
                self._print_separator(item)
            elif isinstance(item, AST.Pointer):
                self._print_pointer(item)
            elif isinstance(item, AST.Command):
                self._print_cmd(item)
            elif item.etype == AST.ExpType.String:
                self._print_str(item)
            elif item.etype == AST.ExpType.Integer:
                self._print_int(item)
            elif item.etype == AST.ExpType.Real:
                self._print_real(item)
            else:
                self._raise_error(2, item, 'print item not supported yet')
        if node.newline:
            self._print_newline()
        if node.stream is not None:
            self._emit_stream_0()
        self._emit_code(";")

    def _print_cmd(self, item:AST.Command) -> None:
        if item.name in ("SPC", "TAB", "USING"):
            self._emit_command(item)
        else:
            self._raise_error(2, item, "unexpected command")
    
    def _print_str(self, item:AST.Statement) -> None:
        self._emit_import("rt_print_str")
        self._emit_code("; PRINT string item")
        self._emit_expression(item)
        self._emit_code("call    rt_print_str")

    def _print_int(self, item:AST.Statement) -> None:
        # Integers always print one space before and after
        self._emit_import("rt_print_int")
        self._emit_code("; PRINT INT item")
        self._emit_expression(item)
        self._emit_code("call    rt_print_int")
    
    def _print_pointer(self, item:AST.Pointer) -> None:
        # Pointer are always an address (int 16 bits)
        self._emit_import("rt_print_int")
        self._emit_code("; PRINT pointer item")
        self._emit_pointer(item.var)
        self._emit_code("call    rt_print_int")

    def _print_real(self, item:AST.Statement) -> None:
        self._emit_import("rt_print_real")
        self._emit_code("; PRINT REAL item")
        self._emit_pushcontext()
        self._emit_expression(item)
        self._moveflo_accum1()
        self._emit_code("call    rt_print_real")
        self._emit_popcontext()

    def _print_separator(self, item:AST.Separator) -> None:
        self._emit_code(f"; PRINT separator [{item.sym}]")
        if item.sym == ',':
            self._emit_import("rt_print_nextzone")
            self._emit_code("call    rt_print_nextzone")

    def _print_newline(self) -> None:
        self._emit_import("rt_print_nl")
        self._emit_code("call    rt_print_nl")

    def _emit_RAD(self, node:AST.Statement) -> None:
        """
        Set Radians Mode (see DEG).
        """
        self._emit_import("rt_math_call")
        self._emit_code("; RAD")
        self._emit_pushcontext()
        self._emit_code("xor     a")
        self._emit_code(f"ld      ix,{FWCALL.MATH_SET_ANGLE_MODE}", info="SET_ANGLE_MODE")
        self._emit_code("call    rt_math_call")
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_RANDOMIZE(self, node:AST.Command) -> None:
        """
        BASIC's random number generator produces a pseudo random sequence in which each
        number depends on the previous number - starting from a given number, the sequence
        is always the same. RANDOMIZE sets a new initial value for the random number generator,
        either to a given value, or to a value entered by the operator. RANDOMIZE TIME will
        produce a sequence that will be difficult to repeat. 
        """
        # In our case, if RANDOMIZE is used without parameters, instead of ask for a value
        # we do the same as puting RANDOMIZE TIME, but even more optimized as we don't copy
        # the real number to a temporal memory after callin gettime
        self._emit_import("rt_randomize")
        self._emit_code("; RANDOMIZE [<numeric expression>]")
        if len(node.args):
            self._emit_expression(node.args[0])
        else:
            self._emit_pushcontext()
            self._emit_import("rt_gettime")
            self._emit_code("call    rt_gettime")
            self._emit_popcontext()
        self._emit_code("call    rt_randomize")
        self._emit_code(";")

    def _emit_READ(self, node:AST.Command) -> None:
        """
        READ fetches data from the list of constants supplied in the corresponding
        DATA statements and assigns it to variables, automatically stepping to the
        next item in the data statement. RESTORE will return the pointer to the
        beginning of the DATA statement. See the DATA keyword.
        """
        self._emit_code("; READ list of:<variable>")
        for a in node.args:
            if isinstance(a, AST.Variable):
                self._emit_variable_ptr(a)
            elif isinstance(a, AST.ArrayItem):
                self._emit_arrayitem_ptr(a)
            else:
                self._raise_error(2, a, "READ doesn't support this variable type yet")
            if a.etype == AST.ExpType.Integer:
                self._emit_import("rt_read_int")
                self._emit_code("call    rt_read_int")
            if a.etype == AST.ExpType.String:
                self._emit_import("rt_read_str")
                self._emit_code("call    rt_read_str")
            if a.etype == AST.ExpType.Real:
                self._emit_import("rt_read_real")
                self._emit_code("call    rt_read_real")
        self._emit_code(";")

    def _emit_READIN(self, node:AST.ReadIn) -> None:
        """
        READIN is an alias of an INPUT #9,<list of vars> command. Used
        to read from a file open using OPENIN keyword.
        """
        self._emit_code("; READIN <list of vars> (alias of INPUT #9,<list of vars>)")
        # TODO: reals
        self._emit_pushcontext()
        self._emit_code("di")
        for v in node.vars:
            self._emit_pointer(v)
            entry = self.symtable.find(v.name, SymType.Variable, self.context)
            if entry is None:
                entry = self.symtable.find(v.name, SymType.Array, self.context)
            if entry is not None:
                if v.etype == AST.ExpType.String:
                    self._emit_import("rt_readstr")
                    self._emit_code("call    rt_readstr")
                elif v.etype == AST.ExpType.Integer:
                    self._emit_import("rt_readint")
                    self._emit_code("push    hl")
                    self._emit_code("call    rt_readint")
                    self._emit_code("pop     de")
                    self._emit_code("ex      de,hl")
                    self._emit_code("ld      (hl),e")
                    self._emit_code("inc     hl")
                    self._emit_code("ld      (hl),d")
                elif v.etype == AST.ExpType.Real:
                    self._raise_error(13, node, 'REAL variables are not supported')
            else:
                self._raise_error(2, v, "unsupported identifier")
        self._emit_code("ei")
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_RECORD(self, node:AST.Command) -> None:
        """
        Imported from Locomotive BASIC 2 Plus
        Defines a series of patterns that can be used to access specific parts
        of an string variable memory so data can be store and manage as a
        struct or record.
        """
        self._emit_code("; RECORD IDENT; IDENT[,IDENT]*")
        # this is managed through the symbols table
        self._emit_code(";")

    def _emit_RELEASE(self, node:AST.Command) -> None:
        """
        When a sound is placed on a sound queue it may include a hold state. If
        any of the channels specified in this channel are in hold state, then they
        are released, the expression to identify the sound channel is bit significant:
        A= bit 0
        B= bit 1
        C= bit 2
        """
        self._emit_code("; RELEASE <sound channels>")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"call    {FWCALL.SOUND_RELEASE}", info="SOUND_RELEASE")
        self._emit_code(";")

    def _emit_REMAIN(self, node:AST.Function) -> None:
        """
        Returns the REMAINing count from the delay timer specified in <int expr>
        (in the range 0 to 3) and disable it. 
        """
        self._emit_import("rt_timer")
        self._emit_code("; REMAIN(<integer expression>)")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code("call    rt_timer_get", info="HL address to event block")
        self._emit_code("ld      bc,4")
        self._emit_code("add     hl,bc", info="point to recharge value")
        self._emit_code("ld      (hl),&0000", info="reset recharge value")
        self._emit_code("dec     hl",   info="remaining ticks")
        self._emit_code("ld      d,(hl)")
        self._emit_code("dec     hl")
        self._emit_code("ld      e,(hl)")
        self._emit_code("ld      (hl),&0000", info="disable ticker")
        self._emit_code("ex      de,hl")
        self._emit_code("inc     hl", info="user count starts in 1 but system in 0")
        self._emit_code(";") 

    def _emit_RENUM(self, node:AST.Statement) -> None:
        """
        Renumber program lines from the line specified, using the increment specified.
        The <new line number> gives the first number for the new sequence, defaulting to 10.
        The <old line number> identifies where RENUM is to commence, and assumes the first
        program line if omitted.
        The <increment> sets the increment to use between the line numbers, again
        defaulting to 10. RENUM takes care of all GOSUB, GOTO and other line calls.
        If all the specifiers are omitted from the command, the program is renumbered as
        if RENUM 10,,10 were issued. Line numbers are valid in the range 1 to 65535. 
        """
        self._emit_code("; RENUM [<new line number>][ ,[<old line number>][,< increment>]")
        self._raise_warning(WL.LOW, "RENUM is ignored and has not effect", node)
        self._emit_code("; IGNORED")

    def _emit_REPLACESS(self, node:AST.Command) -> None:
        """
        ABASC representation for the MID$() keyword as a command:
        MID$(...) = <str expression>
        """
        self._emit_import("rt_strreplace")
        self._emit_code("; REPLACE$(<substr>, <source str>, <insertion point>)")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl", info="string to insert")
        self._emit_expression(node.args[1])
        self._emit_code("push    hl", info="destination string")
        self._emit_expression(node.args[2])
        self._emit_code("ld      b,l")
        self._emit_code("pop     hl")
        self._emit_code("pop     de")
        self._emit_code("call    rt_strreplace")
        self._emit_code(";")

    def _emit_RESTORE(self, node:AST.Command) -> None:
        """
        Restores the position of the reading pointer back to the beginning of the
        DATA statement specified in the optional <line number> or <label>. Omitting
        the parameter restores the position of the pointer back to the beginning
        of the first DATA statement. 
        """
        self._emit_code("; RESTORE [<line number> | <label>]")
        self._emit_import("rt_datablock")
        if len(node.args) == 0:
            self._emit_code("ld      hl,_data_datablock_")
        else:
            label = node.args[0]
            if isinstance(label, AST.Integer) or isinstance(label, AST.Label):
                sym = self.symtable.find(str(label.value), SymType.Label, "")
                if sym is not None:
                    self._emit_code(f"ld      hl,_data_{str(label.value)}_label")
                else:
                    self._raise_error(38, label)
            else:
                self._raise_error(2, node, "invalid label")
        self._emit_code("ld      (rt_data_ptr),hl")
        self._emit_code(";")

    def _emit_RESUME(self, node:AST.Command) -> None:
        """
        When an error has been trapped by an ON ERROR GOTO command, and has been
        processed, RESUME allows normal program execution to continue, the resuming
        line number being optionally specifiable. If not specified, the line in
        which the error has occurred is returned to.
        """
        self._emit_code("; RESUME <linenumber> | NEXT")
        self._raise_warning(WL.LOW, "RESUME is ignored and has not effect", node)
        self._emit_code("; IGNORED")

    def _emit_RETURN(self, node:AST.Command) -> None:
        """
        Signals the end of a subroutine. BASIC returns to continue processing at
        the point after the GOSUB which invoked it.
        """
        self._emit_code("; RETURN")
        if len(node.args):
            # this must be a return inside a FUNCTION
            if self.context == "":
                self._raise_error(3, node)
            self._emit_expression(node.args[0])
            self._emit_free_heapmem()
        self._emit_code("ret")
        self._emit_code(";")

    def _emit_RIGHTSS(self, node:AST.Function) -> None:
        """
        Extracts the number of characters specified by the <int expression> from
        the right of the str expression. If the str expression is shorter than
        the required length, the whole <str expression> is returned. 
        """
        self._emit_import("rt_strright")
        self._emit_code("; RIGHT$(<string expression>,<integer expression>)")
        self._emit_expression(node.args[-1])
        self._emit_code("push    hl")
        self._emit_expression(node.args[0])
        self._reserve_heapmem_de(255, node)
        self._emit_code("pop     bc")
        self._emit_code("call    rt_strright")
        self._emit_code(";")

    def _emit_RND(self, node:AST.Function) -> None:
        """
        Fetches a random number, which may be the next in sequence, a repeat of
        the last one, or the first in a new sequence. RND(0) returns a copy of
        the last random number generated. Where <numeric expression> is negative,
        the number sequence generated is predictable.
        """
        self._emit_import("rt_rnd")
        self._emit_code(";  RND[(<int expression>)]")
        self._emit_pushcontext()
        if len(node.args) == 0:
            self._emit_code("call    rt_rnd")
        else:
            self._emit_expression(node.args[0])
            self._emit_code("call    rt_rnd0")
        self._moveflo_heap(node)
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_ROUND(self, node:AST.Function) -> None:
        """
        Rounds <numeric expression> to a number of decimal places or power of ten
        specified in <integer expression>. If the <integer expression> is less
        than zero, then value is rounded to give an absolute integer followed by
        a number of zeros determined by the <integer expression> before the
        decimal point. 
        """
        self._emit_import("rt_real_round")
        self._emit_code("; ROUND (<numeric expression>[,<integer expression>])")
        if len(node.args) == 2:
            self._emit_expression(node.args[-1])
            self._emit_code("ld      b,l")
        else:
            self._emit_code("xor     a")
            self._emit_code("ld      b,a")
        self._emit_code("push    bc")
        self._emit_expression(node.args[0])
        self._emit_code("pop     bc")
        self._emit_code("call    rt_real_round")
        self._moveflo_heap(node)   
        self._emit_code(";")

    def _emit_RUN(self, node:AST.Command) -> None:
        """
        Loads a program (BASIC or binary) from disc or tape and start executing it.
        """
        self._emit_import("rt_reset_vars")
        self._emit_code("; RUN [<str_expression> | <int_expression>]")
        self._emit_code("call    rt_reset_vars")
        self._emit_code(f"call    {FWCALL.CAS_INITIALISE}", info="CAS_INITIALISE")
        if len(node.args) == 0:
            self._emit_code("jp      _code_")
        elif isinstance(node.args[0], AST.Integer):
            sym = self.symtable.find(str(node.args[0].value), SymType.Label, "")
            if sym is not None:
                self._emit_code(f"jp      {sym.label}")
            else:
                self._raise_error(38, node.args[0])
        else:
            self._raise_error(2, node, "RUN file is not supported")
        self._emit_code(";")

    def _emit_SAVE(self, node:AST.Command) -> None:
        """
        Saves the current BASIC program or an area of memory to tape or disc.
        """
        # In our case, only saving memory as binary files makes sense. As a 
        # result, we ignore the third parameter that we will always consider to
        # be 'B'
        self._emit_import("rt_save")
        self._emit_code(";  SAVE <filename>[,<file type>][,<address>,<length>[,<entry point>]]")
        if len(node.args) < 4:
            self._raise_error(2, node, "only saving binaries is supported")
        else:
            self._emit_pushcontext()
            self._emit_expression(node.args[2])
            self._emit_code("push    hl", info="memory address")
            if len(node.args) > 4:
                self._emit_expression(node.args[4])
                self._emit_code("push    hl", info="entry point")
            else:
                self._emit_code("push    hl", info="use memory address as entry point")
            self._emit_expression(node.args[3])
            self._emit_code("push    hl", info="memory block length")
            self._emit_code("ld      ix,0")
            self._emit_code("add     ix,sp")
            self._emit_expression(node.args[0]) # filename
            self._emit_code("call    rt_save")
            self._emit_popcontext()
        self._emit_code(";")

    def _emit_SELECT_CASE(self, node:AST.SelectCase) -> None:
        """
        """
        self._emit_code("; SELECT CASE <int_expression>")
        self._set_select_case_labels(node)
        node.currentopt = 0
        self._emit_expression(node.condition)
        self._emit_code(f"ld      ({node.var_label}),hl")
        self.selectblocks.append(node)
        self._emit_code(";")

    def _emit_SGN(self, node:AST.Function) -> None:
        """
        Determines the sign of the <numeric expression>. Returns -1 if
        <numeric expression> is less than 0. Returns 0 if <numeric expression>
        equal 0. Returns 1 if <numeric expression> is greater than zero.
        """
        self._emit_code("; SGN(<numeric expression>)")
        if node.args[0].etype == AST.ExpType.Integer:
            self._emit_import("rt_intsgn")
            self._emit_expression(node.args[0])
            self._emit_code("call    rt_intsgn")
        else:
            self._emit_import("rt_realsgn")
            self._emit_pushcontext()
            self._emit_expression(node.args[0])
            self._moveflo_accum1()
            self._emit_code("call    rt_realsgn")
            self._emit_popcontext()
        self._emit_code(";")

    def _emit_SHARED(self, node:AST.Command) -> None:
        """
        Imported from Locomotive BASIC 2 Plus
        Sometimes is necessary to allow routines to access global variables declared
        in the main program. This can be done by declaring the variable in the routine
        as SHARED. The use of brackets at the end of the ident name means that the
        variable is an array.
        """
        self._emit_code("; SHARED list of: <string ident[[]] > | <ident>[[]] ")
        # Lets check that the identifiers exists in the global context
        for arg in node.args:
            if isinstance(arg, AST.Variable):
                entry = self.symtable.find(arg.name, SymType.Variable)
                if entry is None:
                    entry = self.symtable.find(arg.name, SymType.Array)
                if entry is None:
                    self._raise_error(38, node)
        self._emit_code(";")
        pass

    def _emit_SIN(self, node:AST.Function) -> None:
        """
        Calculates the SINE of a given value. The function defaults to radian
        measure unless specifically instructed otherwise by the DEG command. 
        """
        self._emit_import("rt_math_call")
        self._emit_code("; SIN(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        self._moveflo_accum1()
        self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_SINE}", info="MATH_REAL_SINE")
        self._emit_code("call    rt_math_call")
        self._moveflo_heap(node)
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_SOUND(self, node:AST.Command) -> None:
        """
        Each SOUND channel has a queue of SOUND s to play. There is space in this queue for five
        separate SOUND commands: one active and four waiting. The operating system of the CPC464
        can continue with other tasks while playing out the sound queue, only returning when
        necessary to pick up more SOUND commands. The SOUND command has the following shape:
        SOUND Channel,Period,Duration,Volume,Volume-Envelope,Tone-Envelope,Noise
        """
        self._emit_import("rt_sound")
        self._emit_code("; SOUND <channel status>, <tone period>[,<duration>[,<volume>[,<volume envelope>[,<tone envelope>[,<noise period>]]]]")
        self._emit_expression(node.args[0]) 
        self._emit_code("ld      a,l")
        self._emit_code("ld      (rt_sound_buf),a")    # channel
        self._emit_expression(node.args[4])
        self._emit_code("ld      a,l")
        self._emit_code("ld      (rt_sound_buf+1),a")  # ENV
        self._emit_expression(node.args[5])
        self._emit_code("ld      a,l")
        self._emit_code("ld      (rt_sound_buf+2),a")  # ENT
        self._emit_expression(node.args[1])
        self._emit_code("ld      (rt_sound_buf+3),hl") # tone
        self._emit_expression(node.args[6])
        self._emit_code("ld      a,l")
        self._emit_code("ld      (rt_sound_buf+5),a")  # noise
        self._emit_expression(node.args[3])
        self._emit_code("ld      a,l")
        self._emit_code("ld      (rt_sound_buf+6),a")  # volume
        self._emit_expression(node.args[2])
        self._emit_code("ld      (rt_sound_buf+7),hl") # duration
        self._emit_code("call    rt_sound")
        self._emit_code(";")

    def _emit_SPACESS(self, node:AST.Function) -> None:
        """
        Creates a string of spaces of the given length.
        """
        self._emit_import("rt_strfill")
        self._emit_code("; SPACE$(<integer expression>)")
        self._emit_expression(node.args[0])
        self._reserve_heapmem_de(255, node)
        self._emit_code("ld      c,32")
        self._emit_code("call    rt_strfill")
        self._emit_code(";")

    def _emit_SPC(self, node:AST.Command) -> None:
        """
        SPC prints the number of spaces specified in the <integer expression>,
        and will print any following <print item> immediately next to the spaces
        (assuming the follown <print item> will fit onto the line). Hence it is
        not necessary to terminate SPC with a semicolon. 
        """
        self._emit_import("rt_print")
        self._emit_code("; PRINT SPC(<integer expression>)]")
        self._emit_expression(node.args[0])
        self._emit_code("call    rt_print_spc")
        self._emit_code(";")

    def _emit_SPEED_INK(self, node:AST.Command) -> None:
        """
        The INK and BORDER commands allow two colours to be associated with each Ink,
        in which case the INK alternates between the two colours. The first integer
        expression) specifies the time for the first INK specified to be used, and
        the second integer expression sets the time for the second INK.
        Times between colour changes are measured in units of 1/50 second. (50 Hz) 
        """
        self._emit_code("; SPEED INK <integer expression>,<integer expression>")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code("ld      h,e")
        self._emit_code(f"call   {FWCALL.SCR_SET_FLASHING}", info="SCR_SET_FLASHING")
        self._emit_code(";")

    def _emit_SPEED_KEY(self, node:AST.Command) -> None:
        """
        If held down continuously, the keys auto repeat at the <repeat period> after
        the given <start delay> period. The setting is made in 1/50 sec units, in
        the range 1 to 255. The default rate is set to 30,2.
        Very small start delays will interact with keyboard de-bounce routines.
        The actual speed at which the keyboard is read by the software is not affected
        by this command.
        Not all keys repeat, the KEY DEF commnd will allow the user to redefine the
        particular attributes of a given key. 
        """
        self._emit_code("; SPEED KEY <start delay>, <repeat period>")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code("ld      h,e")
        self._emit_code(f"call    {FWCALL.KM_SET_DELAY}")
        self._emit_code(";")

    def _emit_SPEED_WRITE(self, node:AST.Command) -> None:
        """
        The cassette can be witten at either 2000 baud (where <int expr> is 1),
        or the default of 1000 baud (where the <integer expression> is 0). When
        loading a file from tape, the CPC464 automatically establishes the correct
        reading speed from information in the file software, thus it is not necessary
        for the user to specify.
        When using cassette tape of uncertain data recording ability, the 1000 baud
        rate is recommended for maximum reliability. 
        """
        self._emit_import("rt_speedwrite")
        self._emit_code("; SPEED WRITE <integer expression>")
        self._emit_expression(node.args[0])
        self._emit_code("call    rt_speedwrite")
        self._emit_code(";")

    def _emit_SQ(self, node:AST.Function) -> None:
        """
        The SQ function is used to check the number of free entries in the queue for
        a given channel, where channel A is 1, B is 2, and C is 4. The function
        determines whether the channel is active - and if not - why the entry at the
        head of the queue (if any) is waiting.
        The result is bit significant:
        bits 0,1,2 indicate the number of free entries in the queue
        bits 3,4,5 indicate the Rendezvous state at the head of the queue (if any)
        bit 6 is set if the head of the queue is held
        bit 7 is set if the channel is currently active
        """
        self._emit_code("; SQ(<channel>)")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"call    {FWCALL.SOUND_CHECK}", info="SOUND_CHECK")
        self._emit_code("ld      h,0\n")
        self._emit_code("ld      l,a\n")
        self._emit_code(";")

    def _emit_SQR(self, node:AST.Function) -> None:
        """
        Returns the square root of <numeric expression>.
        """
        self._emit_import("rt_math_call")
        self._emit_code("; SQR(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        self._moveflo_accum1()
        self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_SQR}", info="MATH_REAL_SQR")
        self._emit_code("call    rt_math_call")
        self._moveflo_heap(node)
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_STOP(self, node:AST.Statement) -> None:
        """
        To stop execution of a program, but leave BASIC in a state where the program
        can be restarted after the STOP command by using the CONT command. This may
        be used to interrupt the program at a particular point when debugging.
        """
        # in our case we just reboot
        self._emit_code("; STOP")
        self._emit_code("call    0")
        self._emit_code(";")

    def _emit_STRINGSS(self, node:AST.Function) -> None:
        """
        Delivers a <string expression> consisting of the specified character
        repeated a number of times. 
        """
        self._emit_import("rt_strfill")
        self._emit_code("; STRING$(<integer expression>,<character expression>)")
        self._emit_expression(node.args[1])
        if node.args[1].etype == AST.ExpType.String:
            self._emit_code("inc     hl")
            self._emit_code("ld      a,(hl)", info="first character")
            self._emit_code("ld      c,a")
        else:
            self._emit_code("ld      c,l")
        self._emit_code("push    bc")
        self._emit_expression(node.args[0])
        self._reserve_heapmem_de(255, node)
        self._emit_code("pop     bc")
        self._emit_code("call    rt_strfill")
        self._emit_code(";")

    def _emit_STRSS(self, node:AST.Function) -> None:
        """
        Converts the numeric expression) to a decimal string representation in the
        same form as used in the PRINT command.
        """
        self._emit_code("; STR$(<numeric expression>)")
        arg = node.args[0]
        self._emit_expression(arg)
        if arg.etype == AST.ExpType.Integer:
            self._emit_import("rt_int2str")
            self._emit_code("call    rt_int2str")
            self._reserve_heapmem_de(8, node)
            self._emit_code("push    de")
            self._emit_code("ldir")
            self._emit_code("pop     hl")
        else:
            self._moveflo_accum1()
            self._emit_import("rt_real2strz")
            self._emit_import("rt_strzcopy")
            self._emit_pushcontext()
            self._emit_code("call    rt_real2strz")
            self._reserve_heapmem(12, node)
            self._emit_code("ld      de,rt_real2strz_buf")
            self._emit_code("call    rt_strzcopy")
            self._emit_popcontext()
        self._emit_code(";")

    def _emit_SUB(self, node:AST.DefSUB) -> None:
        """
        Adopted from Locomotive BASIC 2 Plus, SUB allows the program to define
        and use simple procedures ended with END SUB.
        It may be invoked throughout the program using CALL. Variable types must
        be consistent and the SUB command should be written in part of the program
        outside the execution loop. 
        """
        self._emit_code("; SUB <name> [(<formal parameters>)]=<general expression>")
        self._emit_code(";")
        self.codestack.append(str(self.srccode)) # store current generated code
        self.srccode = ""                        # so we generate now sub body only
        self.context = node.name
        self._emit_code(f"{self._get_userfun_label(node.name)}:", 0)
        if not node.asm:
            # procedures decorated with ASM in the declaration doesn't need
            # to care about the temporal memory but may better use only
            # ASM code or something bad will happen!
            self._emit_push_memheap()
            entry = self.symtable.find(node.name, SymType.Procedure)
            if entry is not None:
                # store current to calculate any use in END FUNCTION
                self._push_heapvalues()
                self.max_heap_memory = 0
            else:
                self._raise_error(2,node)

    def _emit_SYMBOL(self, node:AST.Command) -> None:
        """
        The SYMBOL command redefines the representation of a given character that
        has first been specified in the SYMBOL AFTER command. The character number,
        is chosen from the available ASCII or other characters from the CPC464's
        standard character set, and the following entries define the new character
        on an 8Ã8 pixel matrix. A 0 in the row indicates the paper colour to be
        used and a 1 indicates that the pixel is to be set to the current ink colour. 
        """
        self._emit_code("; SYMBOL <character number>,<list of: row>")
        label = self._get_symbol_label()
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"ld      hl,{label}")
        self._emit_code(f"call    {FWCALL.TXT_SET_MATRIX}", info="TXT_SET_MATRIX")
        self._emit_code(";")
        data = f"{label}: db "
        values: list[str] = []
        for i in range(1,9):
            arg = node.args[i]
            if isinstance(arg, AST.Integer):
                values.append(str(arg.value))
            else:
                self._raise_error(2, arg, 'an integer value was expected')
        data = data + ','.join(values)
        self._emit_data(data)

    def _emit_SYMBOL_AFTER(self, node:AST.Command) -> None:
        """
        The number of user definable characters is set by the SYMBOL AFTER command.
        The default setting is 240, giving 16 user defined characters. If the
        <integer expression>, is 32, then all characters from 32 to 255 are
        redefinable. Whenever a SYMBOL AFTER command is used, all user defined
        characters are reset to the default condition. 
        """
        # We use a static table that will be dimensioned to the biggest value
        # used in a symbol after call. For that reason, we don't allow
        # expressions and require de argument to be an integer value
        arg = node.args[0]
        if isinstance(arg, AST.Integer):
            num = arg.value
            if num < 0 or num > 255: num = 256 
            self._emit_code("; SYMBOL AFTER <int expression>")
            if num != 256 or self.symbolafter != 9999:
                self._emit_code(f"ld      de,{num}")
                self._emit_code("ld      hl,_symbols_table")
                self._emit_code(f"call    {FWCALL.TXT_SET_M_TABLE}", info="TXT_SET_M_TABLE")
                self._emit_code(";")
            if num < self.symbolafter:
                self.symbolafter = num
        else:
            self._raise_error(2, arg, 'an integer value was expected')

    def _emit_TAB(self, node:AST.Command) -> None:
        """
        TAB prints the number of spaces relative to the left efge of the text window,
        and will print any following <print item> immediately next to the spaces
        (assuming the following <print item> will fit onto the line).
        Hence it is not necessary to terminate TAB with a semicolon. If the current
        position is greater than the required position, then a carriage return is
        executed, followed by spaces to reach the required position on the next line.
        """
        self._emit_import("rt_print_nl")
        self._emit_code("; PRINT TAB(<integer expression>)]")
        self._emit_code(f"call    {FWCALL.TXT_GET_CURSOR}", info="TXT_GET_CURSOR")
        self._emit_code("push    hl")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code("pop     de")
        self._emit_code("ld      l,e")
        self._emit_code("cp      d", info="current cursor far right than tab position?")
        self._emit_code("jr      nc,$+3")
        self._emit_code("inc     l")
        self._emit_code("ld      h,a")
        self._emit_code(f"call    {FWCALL.TXT_SET_CURSOR}", info="TXT_SET_CURSOR")
        self._emit_code(";")

    def _emit_TAG(self, node:AST.Command) -> None:
        """
        Text sent to a given stream may be redirected to be written at the graphics
        cursor position. This allows text and symbols to be mixed with graphics.
        The stream expression) defaults to 0 if omitted. The top left of the
        character cell is tagged to the graphics cursor, and non-printing control
        characters will display. In particular, new line characters will display
        if the PRINT statement is not followed by a semi-colon ; 
        """
        self._emit_code("; TAG [#<stream expression>]")
        if len(node.args) == 1:
            self._emit_expression(node.args[0])
            self._emit_stream()
        self._emit_code("ld      a,&FF")
        self._emit_code(f"call    {FWCALL.TXT_SET_GRAPHIC}", info="TXT_SET_GRAPHIC")
        if len(node.args) == 1:
            self._emit_stream_0()
        self._emit_code(";")

    def _emit_TAGOFF(self, node:AST.Command) -> None:
        """
        Cancels the TAG for a given stream, and sends the text to the previous
        text cursor position at the point at which TAG was invoked. 
        """
        self._emit_code("; TAGOFF [#<stream expression>]")
        if len(node.args) == 1:
            self._emit_expression(node.args[0])
            self._emit_stream()
        self._emit_code("ld      a,0")
        self._emit_code(f"call    {FWCALL.TXT_SET_GRAPHIC}", info="TXT_SET_GRAPHIC")
        if len(node.args) == 1:
            self._emit_stream_0()
        self._emit_code(";")

    def _emit_TAN(self, node:AST.Function) -> None:
        """
        Calculates the tangent for the angle given in <numeric expression>, which
        must be in the range -200,000â¦.+200,000, defaulting to radian measure
        unless declared otherwise by a DEG command. 
        """
        self._emit_import("rt_math_call")
        self._emit_code("; TAN(<numeric expression>)")
        self._emit_pushcontext()
        self._emit_expression(node.args[0])
        self._moveflo_accum1()
        self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_TANGENT}", info="MATH_REAL_TANGENT")
        self._emit_code("call    rt_math_call")
        self._moveflo_heap(node)
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_TEST(self, node:AST.Function) -> None:
        """
        Reports the value of the ink currently at the specified graphics screen location. 
        """
        self._emit_code("; TEST(<x co-ordinate>,<y co-ordinate>)")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code(f"call    {FWCALL.GRA_TEST_ABSOLUTE}", info="GRA_TEST_ABSOLUTE")
        self._emit_code("ld      h,0")
        self._emit_code("ld      l,a")
        self._emit_code(";")

    def _emit_TESTR(self, node:AST.Function) -> None:
        """
        Moves the graphics cursor relatively from it's current location and reports
        the value of the ink at the new location. 
        """
        self._emit_code("; TESTR(<x offset>,<y offset>)")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code(f"call    {FWCALL.GRA_TEST_RELATIVE}", info="GRA_TEST_RELATIVE")
        self._emit_code("ld      h,0")
        self._emit_code("ld      l,a")
        self._emit_code(";")

    def _emit_TIME(self, node:AST.Function) -> None:
        """
        Holds the elapsed time since switch-on, excluding periods when reading or writing
        the cassette (interrupts off). The units of time are 1/300th of a second.
        The firmware call returns the result in DEHL. The call eneables interrups.
        As this is a long number, the result is coded into a Real.
        """
        # We allow programmers to set TIME value too. For example, with TIME(0)
        self._emit_code("; TIME [(<int_expression>)]")
        if len(node.args):
            self._emit_import("rt_settime")
            self._emit_expression(node.args[0])
            self._emit_code("call    rt_settime")
        elif node.etype == AST.ExpType.Integer:
            # This is the integer version of TIME so we can call
            # the rutine because it leaves the value directly in HL
            self._emit_code(f"call    {FWCALL.KL_TIME_PLEASE}", info="KL_TIME_PLEASE")
        else:
            # Full TIME GET
            self._emit_import("rt_gettime")
            self._emit_pushcontext()
            self._emit_code("call    rt_gettime")
            self._moveflo_heap(node)
            self._emit_popcontext()
        self._emit_code(";")

    def _emit_TROFF(self, node:AST.Statement) -> None:
        """
        BASIC includes the facility to trace the execution of a program, by
        reporting the number of each line in square brackets [ ] , just before it
        is executed. TRON enables the feature, TROFF turns it off.
        """
        self._emit_code("; TROFF")
        self._raise_warning(WL.LOW, "TROFF is ignored and has not effect", node)
        self._emit_code("; IGNORED")

    def _emit_TRON(self, node:AST.Statement) -> None:
        """
        BASIC includes the facility to trace the execution of a program, by
        reporting the number of each line in square brackets [ ] , just before it
        is executed. TRON enables the feature, TROFF turns it off.
        """
        self._emit_code("; TRON")
        self._raise_warning(WL.LOW, "TRON is ignored and has not effect", node)
        self._emit_code("; IGNORED")

    def _emit_UNT(self, node:AST.Function) -> None:
        """
        Converts an unsigned 16-bit integer in the range 0 to 65535. Returns an
        integer value in the range -32768 to +32767.
        """
        self._emit_code("; UNT(<address expression>)")
        self._emit_expression(node.args[0])
        self._emit_code(";")

    def _emit_UPPERSS(self, node:AST.Function) -> None:
        """
        Returns a new string expression the same as the input string expression)
        but in which all lower case characters are converted to upper case.
        """
        self._emit_import("rt_upper")
        self._emit_code("; UPPER$(<string expression>)")
        self._emit_expression(node.args[0])
        self._reserve_heapmem_de(255, node)
        self._emit_code("call    rt_upper")
        self._emit_code(";")

    def _emit_USING(self, node:AST.Command) -> None:
        """
        PRINT USING enables you to specify the print format of the expression
        returned by the PRINT command. This is achieved by specifying a
        <format template> to which the printed result must correspond.
        """
        # TODO: apply format
        self._emit_code("; USING <format template>;<expression>[,<expression>]*")
        self._raise_warning(WL.MEDIUM, "text patterns are not supported yet", node)
        for a in node.args[1:]:
            if a.etype == AST.ExpType.Integer:
                self._print_int(a)
            elif a.etype == AST.ExpType.Real:
                self._print_real(a)
            elif a.etype == AST.ExpType.String:
                self._print_str(a)
            else:
                self._raise_error(2, a, "type not supported by USING")
        self._emit_code(";")

    def _emit_VAL(self, node:AST.Function) -> None:
        """
        Extracts a <numeric expression> from the beginning of the string expression.
        The opposite of STR$. 
        """
        # In our case, VAL is restricted to integer convertions
        self._emit_import("rt_strz2num")
        self._emit_import("rt_scratch_pad")
        self._emit_code("; VAL(<string expression>)")
        self._emit_expression(node.args[0])
        self._emit_code("ld      c,(hl)")
        self._emit_code("ld      b,0")
        self._emit_code("inc     hl")
        self._emit_code("ld      de,rt_scratch_pad")
        self._emit_code("push    de")
        self._emit_code("ldir")
        self._emit_code("ex      de,hl")
        self._emit_code("ld      (hl),0")
        self._emit_code("pop     de")
        self._emit_code("call    rt_strz2num")
        self._emit_code(";")
    
    def _emit_VPOS(self, node:AST.Function) -> None:
        """
        Reports the current vertical POSition of the text cursor relative to
        the leftedge of the text window. The <stream expression> MUST be specified,
        and does NOT default to #0. 
        """
        self._emit_code("; VPOS")
        self._emit_expression(node.args[0])
        self._emit_stream()
        self._emit_code("ld      b,a", info="keep previous stream")
        self._emit_code(f"call    {FWCALL.TXT_GET_CURSOR}", info="TXT_GET_CURSOR")
        self._emit_code("ld      h,0")
        self._emit_code("push    hl")
        self._emit_code("ld      l,b")
        self._emit_stream()
        self._emit_code("pop     hl")
        self._emit_code(";")

    def _emit_WAIT(self, node:AST.Command) -> None:
        """
        Suspends operation until a given I/O port returns a particular value in
        the range 0 to 255. BASIC loops whilst reading the I/O port. The value-read
        is Exclusive ORed with the <inversion> and then ANDed with the <mask> until
        a non-zero result occurs. BASIC will get stuck in a WAIT loop if the
        required condition does not occur. 
        """
        self._emit_code("; WAIT <port number>,<mask>[,<inversion]")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        if len(node.args) == 3:
            self._emit_code("push    hl")
            self._emit_expression(node.args[2])
            self._emit_code("ld      e,l")
            self._emit_code("pop     bc")
            self._emit_code("ld      d,c")
        else:
            self._emit_code("ld      d,l")
            self._emit_code("ld      e,0")
            
        self._emit_code("pop     bc")
        self._emit_code("in      a,(c)")
        self._emit_code("xor     e", info="inversion")
        self._emit_code("and     d", info="mask")
        self._emit_code("jr      z,$-4")
        self._emit_code(";")

    def _emit_WEND(self, node:AST.Statement) -> None:
        wnode = self.wloops.pop()
        self._emit_code("; WEND")
        self._emit_code(f"jp      {wnode.start_label}")
        self._emit_code(f"{wnode.end_label}:", 0)
        self._emit_code(";")

    def _emit_WHILE(self, node:AST.WhileLoop) -> None:
        """
        A WHILE loop repeatedly executes a body of program until a given
        condition is true. The WHILE command defines the head of the loop, and
        gives the condition. The WEND command terminates the WHILE loop. 
        """
        start, end = self._get_while_labels()
        node.start_label = start
        node.end_label = end
        self._emit_code("; WHILE <logical expression>")
        self._emit_code(start, 0)
        self._emit_expression(node.condition)
        # clear temporal memory if used by the condition before
        # jumping. Modifies DE
        self._emit_free_heapmem()
        self._emit_code("ld      a,h")
        self._emit_code("or      l")
        self._emit_code(f"jp      z,{end}")
        self._emit_code("; WHILE BODY")
        self.wloops.append(node)
    
    def _emit_WIDTH(self, node:AST.Command) -> None:
        """
        Tells BASIC how wide the printer is in characters, this information allows
        BASIC to insert carriage returns as required when printing. 
        """
        self._emit_code("; WIDTH <integer expression>")
        self._raise_warning(WL.MEDIUM, 'WIDTH is ignored and has not effect', node)
        self._emit_code("; IGNORED")

    def _emit_WINDOW(self, node:AST.Command) -> None:
        """
        Sets a text window for a given screen stream. 
        """
        self._emit_code("; WINDOW [#<stream expression>,] <left>, <right>, <top>, <bottom>")
        args = node.args
        if len(args) == 5:
            self._emit_expression(args[0])
            self._emit_stream()
            args = args[1:]
        self._emit_expression(args[0])
        for a in args[1:]:
            self._emit_code("push    hl")
            self._emit_expression(a)
        self._emit_code("ld      e,l", info="bottom")
        self._emit_code("dec     e")
        self._emit_code("pop     bc")
        self._emit_code("ld      l,c", info="top")
        self._emit_code("dec     l")
        self._emit_code("pop     bc")
        self._emit_code("ld      d,c", info="right")
        self._emit_code("dec     d")
        self._emit_code("pop     bc")
        self._emit_code("ld      h,c", info="left")
        self._emit_code("dec     h")
        self._emit_code(f"call    {FWCALL.TXT_WIN_ENABLE}", info="TXT_WIN_ENABLE")
        if len(node.args) == 5:
            self._emit_stream_0()
        self._emit_code(";")

    def _emit_WINDOW_SWAP(self, node:AST.Command) -> None:
        """
        Exchanges the text windows. For example, BASIC messages sent to stream #0
        may be swapped with another window to highlight aspects of program development
        and operation.
        """
        self._emit_code("; WINDOW SWAP <stream expression>, <stream expression>")
        self._emit_expression(node.args[0])
        self._emit_code("push    hl")
        self._emit_expression(node.args[1])
        self._emit_code("pop     de")
        self._emit_code("ld      c,e")
        self._emit_code("ld      b,l")
        self._emit_code(f"call    {FWCALL.TXT_SWAP_STREAMS}", info="TXT_SWAP_STREAMS")
        self._emit_code(";")

    def _emit_WRITE(self, node:AST.Write) -> None:
        """
        Prints the values of a number of expressions to the given stream, separating them
        by commas and enclosing strings in double quotes. Used mainly for outputting data
        to files (on tape or disc).
        """
        # In our case WRITE always writes to dist/tape so stream is just ignored and
        # always considered to be 9. That saves a couple of bytes and cicles.
        # TODO: reals
        self._emit_code("; WRITE [#<stream expression >, ][<write list>]")
        self._emit_import("rt_writenl")
        self._emit_pushcontext()
        self._emit_code("di")
        for i,item in enumerate(node.items):
            self._emit_expression(item)
            if item.etype == AST.ExpType.String:
                self._emit_import("rt_writestr")
                self._emit_code("call    rt_writestr")
            elif item.etype == AST.ExpType.Integer:
                self._emit_import("rt_writeint")
                self._emit_code("call    rt_writeint")
            elif item.etype == AST.ExpType.Real:
                self._raise_error(2, item, 'item not supported yet')
            else:
                self._raise_error(13, item)
            if i < (len(node.items) - 1):
                self._emit_code('ld      a,&2c')
                self._emit_code(f"call    {FWCALL.CAS_OUT_CHAR}", info="CAS_OUT_CHAR")
        self._emit_code("call    rt_writenl")
        self._emit_code("ei")
        self._emit_popcontext()
        self._emit_code(";")

    def _emit_XPOS(self, node:AST.Function) -> None:
        """
        Establishes the horizontal position of the graphics cursor.
        """
        self._emit_code("; XPOS")
        self._emit_code(f"call    {FWCALL.GRA_ASK_CURSOR}", info="GRA_ASK_CURSOR")
        self._emit_code("ex      de,hl")
        self._emit_code(";")

    def _emit_YPOS(self, node:AST.Function) -> None:
        """
        Establishes the vertical position of the graphics cursor.
        """
        self._emit_code("; YPOS")
        self._emit_code(f"call    {FWCALL.GRA_ASK_CURSOR}", info="GRA_ASK_CURSOR")
        self._emit_code(";")

    def _emit_ZONE(self, node:AST.Command) -> None:
        """
        Changes the width of the Print Zone used in PRINT, from the default value
        of 13 to a new value in the range 1 to 255. Reset by NEW, LOAD, CHAIN
        and RUN"<file name>" commands.
        """
        self._emit_import("rt_print_zone")
        self._emit_code("; ZONE <int expression>")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code("ld      (rt_print_zone),a")
        self._emit_code(";")

    # ----------------- Expressions -----------------

    def _emit_expression(self, node: AST.Statement) -> None:
        if isinstance(node, AST.Integer):
            self._emit_code(f"ld      hl,{node.value & 0xFFFF}")
        elif isinstance(node, AST.String):
            self._emit_const_str(node)
        elif isinstance(node, AST.Real):
            self._emit_const_real(node)
        elif isinstance(node, AST.Variable):
            self._emit_variable(node)
        elif isinstance(node, AST.ArrayItem):
            self._emit_arrayitem(node)
        elif isinstance(node, AST.BinaryOp):
            self._emit_binaryop(node)
        elif isinstance(node, AST.UnaryOp):
            self._emit_unaryop(node)
        elif isinstance(node, AST.Function):
            self._emit_function(node)
        elif isinstance(node, AST.Pointer):
            self._emit_pointer(node.var)
        elif isinstance(node, AST.UserFun):
            self._emit_userfun(node)
        else:
            self._raise_error(2, node, 'expression not supported yet')

    def _emit_const_str(self, node: AST.String) -> None:
        if node.value not in self.issued_str_constants:
            label = self._get_conststr_label()
            values = ""
            for c in node.value:
                values = values + f'&{ord(c):02X},'
            if len(values):
                self._emit_data(f'{label}: db {len(node.value)},{values[:-1]}', info=repr(node.value), section=DataSec.CONST)
            else:
                self._emit_data(f'{label}: db 0', section=DataSec.CONST)
            self.issued_str_constants[node.value] = label
        else:
            label = self.issued_str_constants[node.value]
        self._emit_code(f"ld      hl,{label}")

    def _emit_const_real(self, node: AST.Real) -> None:
        vstr = str(node.value)
        if vstr not in self.issued_real_constants:
            label = self._get_constreal_label()
            cpcreal = self._real(node.value)
            values = ""
            for b in cpcreal:
                values = values + f'&{b:02X},'
            # send code without last ','
            self._emit_data(f'{label}: db {values[:-1]}', info=f'{node.value}', section=DataSec.CONST)
            self.issued_real_constants[vstr] = label
        else:
            label = self.issued_real_constants[vstr]
        self._emit_code(f"ld      hl,{label}")

    def _emit_record(self, node: AST.Variable) -> None:
        varname, rname = node.name.split('$.')
        varname = varname + "$" # restore data type character
        var = self.symtable.find(varname, SymType.Variable, self.context)
        entry = self.symtable.find(rname, SymType.Record, self.context)
        if entry is not None and var is not None:
            if node.etype == AST.ExpType.Integer:  
                self._emit_code(f"ld      hl,({var.label}+{entry.memoff})")
            else:
                self._emit_code(f"ld      hl,{var.label}+{entry.memoff}")
        else:
            self._raise_error(38, node)

    def _emit_variable(self, node: AST.Variable) -> None:
        """
        Params are special variables because they don't have permanent reserved
        memory but are stored in the call stack frame and accessed through IX.
        """
        if "$." in node.name:
            self._emit_record(node)
            return
        entry = self.symtable.find(node.name, SymType.Param, context=self.context)
        if entry is None:
            entry = self.symtable.find(node.name, SymType.Variable, context=self.context)
        if entry is not None:
            # parameters always contain the address to the real data so 
            # all behave in the same way
            if entry.symtype == SymType.Param:
                self._emit_code(f"ld      l,(ix+{entry.memoff})")
                self._emit_code(f"ld      h,(ix+{entry.memoff+1})")
            elif node.etype == AST.ExpType.Integer:  
                self._emit_code(f"ld      hl,({entry.label})")
            elif node.etype == AST.ExpType.String:
                self._emit_code(f"ld      hl,{entry.label}")
            elif node.etype == AST.ExpType.Real:
                self._emit_code(f"ld      hl,{entry.label}")
            else:
                self._raise_error(2, node, 'var type not implemented yet')
        else:
            self._raise_error(38, node)
    
    def _emit_arrayitem(self, node: AST.ArrayItem) -> None:
            self._emit_arrayitem_ptr(node)
            if node.etype == AST.ExpType.Integer:
                self._emit_code("ld      e,(hl)")
                self._emit_code("inc     hl")
                self._emit_code("ld      d,(hl)")
                self._emit_code("ex      de,hl")

    def _emit_variable_recordptr(self, node: AST.Variable) -> None:
        varname, rname = node.name.split('$.')
        varname = varname + "$" # restore data type character
        var = self.symtable.find(varname, SymType.Variable, self.context)
        entry = self.symtable.find(rname, SymType.Record, self.context)
        if entry is not None and var is not None:
            self._emit_code(f"ld      hl,{var.label}+{entry.memoff}")
        else:
            self._raise_error(38, node)

    def _emit_variable_ptr(self, node: AST.Variable) -> None:
        """
        variables can be local to a DEF FN, SUB or FUNCTION if they are parameters
        so we check that case bacause their address is relative to IX.
        """
        entry = self.symtable.find(node.name, SymType.Param, context=self.context)
        if entry is not None:
            self._emit_code("ld      hl,0", info="set param address in HL")
            self._emit_code("add     hl,ix")
            self._emit_code(f"add     hl,{entry.memoff}")
        else:
            if "$." in node.name:
                self._emit_variable_recordptr(node)
            else:
                entry = self.symtable.find(node.name, SymType.Variable, context=self.context)
                if entry is not None:
                    self._emit_code(f"ld      hl,{entry.label}")
                else:
                    self._raise_error(38, node)
    
    def _emit_arrayitem_ptr(self, node: AST.ArrayItem) -> None:
        """
        Emit code to compute the address of an array element (multi-dimensional).
        Each array type has a different element size:
            Integer -> 2 bytes
            Real    -> 5 bytes
            String  -> 255 bytes
        node.args   : list of index expressions
        var.indexes : list of dimension lengths
        """
        self._emit_import("rt_mul16_A")
        varname = node.name
        record = ""
        vartype = AST.exptype_fromname(varname)
        if "$." in node.name:
            varname, record = node.name.split("$.")
            varname = varname + "$"
            vartype = AST.ExpType.String
        var = self.symtable.find(varname, SymType.Array, context=self.context)
        if var is None:
            var = self.symtable.find(varname, SymType.ArrayParam, context=self.context)
        if var is None:
            self._raise_error(38, node)
        # addr = i1*dim0 + i0
        dims = var.indexes  # type: ignore [union-attr]
        ndims = len(dims)
        if len(node.args) != ndims:
            self._raise_error(2, node, info="bad subscript count")
        # lets calculte the linear offset: x + y*szx + z*szx*szy ...
        self._emit_expression(node.args[0])
        dim_size = 1
        for i in range(1, ndims):
            self._emit_code("push    hl", info=f"save partial offset (dim {i-1})")
            dim_size = dim_size * (dims[i-1] + 1) # adding 1 because array sizes are inclusive 0..N  
            self._emit_expression(node.args[i])
            self._emit_code(f"ld      a,{dim_size}", info=f"dimension {i-1} linear size") 
            self._emit_code("call    rt_mul16_A")
            self._emit_code("pop     de")
            self._emit_code("add     hl,de", info="add next index")
        # address_offset = linear_offset * size_of(data)
        if vartype == AST.ExpType.Integer:
            self._emit_code("add     hl,hl", info="index * 2 bytes")
        elif vartype == AST.ExpType.String:
            self._emit_import("rt_mul16_A")
            self._emit_code(f"ld      a,{var.datasz}", info="string length")  #type: ignore [union-attr]
            self._emit_code("call    rt_mul16_A", info="index * length bytes")
            if record != "":
                # this is a record so we have to apply the final offset
                entry = self.symtable.find(record, SymType.Record, context=self.context)
                if entry is not None:
                    self._emit_code(f"ld      de,{entry.memoff}", info="record memory offset")
                    self._emit_code("add     hl,de", info="apply record attribute offset")
        elif vartype == AST.ExpType.Real:
            self._emit_code("ld      d,h")
            self._emit_code("ld      e,l")
            self._emit_code("add     hl,hl", info="offset * 2")
            self._emit_code("add     hl,hl", info="offset * 4")
            self._emit_code("add     hl,de", info="offset * 5")
        else:
            self._emit_code("ld      hl,0", info="unsupported type")
        # address = address_base + address_offset
        if var.symtype == SymType.ArrayParam:                   # type: ignore [union-attr]
            self._emit_code(f"ld      e,(ix+{var.memoff})", info=f"base address for {node.name}[]") # type: ignore [union-attr]
            self._emit_code(f"ld      d,(ix+{var.memoff+1})")   # type: ignore [union-attr]
        else:
            self._emit_code(f"ld      de,{var.label}", info=f"base address of {node.name}") # type: ignore [union-attr]
        self._emit_code("add     hl,de", info="final address of this item element")

    def _emit_pointer(self, node: AST.ArrayItem | AST.Variable | AST.Label | AST.String) -> None:
        if isinstance(node, AST.ArrayItem):
            self._emit_arrayitem_ptr(node)
        elif isinstance(node, AST.Variable):
            # This includes Records and Params
            self._emit_variable_ptr(node)
        elif isinstance(node, AST.Label):
            if node.value.upper() == "DATA":
                self._emit_code("ld      hl,(rt_data_ptr)")
            else:
                sym = self.symtable.find(node.value, SymType.Label, "")
                if sym is not None:
                    self._emit_code(f"ld      hl,{sym.label}")
                else:
                    self._raise_error(38, node)
        elif isinstance(node, AST.String):
            # ASM label
            self._emit_code(f"ld      hl,{node.value}")
        else:
            self._raise_error(2, node, "unsupported type")

    def _emit_binaryop(self, node: AST.BinaryOp) -> None:
        """ 
        Develops right side and pushes the result, develops left 
        and leaves it in HL
        """
        self._emit_expression(node.right)
        self._emit_code("push    hl")
        self._emit_expression(node.left)
        self._emit_code("pop     de")
        if node.etype == AST.ExpType.Integer:
            self._emit_int_op(node)
        elif node.etype == AST.ExpType.String:
            self._emit_str_op(node)
        elif node.etype == AST.ExpType.Real:
            self._emit_real_op(node)
        else:
            self._raise_error(2, node, f'{node.etype} operations are not supported yet')
    
    def _emit_unaryop(self, node: AST.UnaryOp) -> None:
        self._emit_expression(node.operand)
        if node.etype == AST.ExpType.Integer:
            if node.op == 'NOT':
                self._emit_code("ex      de,hl")
                self._emit_code("ld      hl,&FFFF")
                self._emit_code("ld      a,d")
                self._emit_code("or      e")
                self._emit_code("jr      z,$+3")
                self._emit_code("inc     hl")
            elif node.op == '-':
                self._emit_code("ld      de,0")
                self._emit_code("ex      de,hl")
                self._emit_code("xor     a")
                self._emit_code("sbc     hl,de")
            else:
                self._raise_error(2, node, f"INT '{node.op}' unary op is not supported yet")
        elif node.etype == AST.ExpType.Real:
            if node.op == '-':
                self._emit_import("rt_math_call")
                self._emit_pushcontext()
                self._moveflo_accum1()
                self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_UMINUS}", info="MATH_REAL_UMINUS")
                self._emit_code("call    rt_math_call")
                self._emit_popcontext()
                self._moveflo_heap(node)
        else:
            self._raise_error(2, node, f'{node.etype} unary operations are not supported yet')

    def _emit_int_op(self, node: AST.BinaryOp) -> None:
        """ HL = left value, DE = right value """
        op = node.op.upper()
        if op == '+':
            self._emit_code("add     hl,de")
        elif op == '-':
            self._emit_code("or      a", info="clear carry")
            self._emit_code("sbc     hl,de", info="HL = HL - DE")
        elif op == '*':
            self._emit_import("rt_mul16")
            self._emit_code("call    rt_mul16", info="HL = HL * DE")
        elif op == '\\':
            self._emit_import("rt_div16")
            self._emit_code("call    rt_div16", info="HL = HL \\ DE ")
        elif op == 'MOD':
            self._emit_import("rt_udiv16")
            self._emit_code("call    rt_udiv16")
            self._emit_code("ex      de,hl", info="HL = HL MOD DE")
        elif op == 'AND':
            self._emit_code("ld      a,h")
            self._emit_code("and     d")
            self._emit_code("ld      h,a")
            self._emit_code("ld      a,l")
            self._emit_code("and     e")
            self._emit_code("ld      l,a")
        elif op == 'OR':
            self._emit_code("ld      a,h")
            self._emit_code("or      d")
            self._emit_code("ld      h,a")
            self._emit_code("ld      a,l")
            self._emit_code("or      e")
            self._emit_code("ld      l,a")
        elif op == 'XOR':
            self._emit_code("ld      a,h")
            self._emit_code("xor     d")
            self._emit_code("ld      h,a")
            self._emit_code("ld      a,l")
            self._emit_code("xor     e")
            self._emit_code("ld      l,a")
        elif op in ('=', '<>', '<', '<=', '>', '>='):
            self._emit_comparation(node)
        else:
            self._raise_error(2, node, f'unknown "{op}" INT op')
    
    def _emit_str_op(self, node: AST.BinaryOp) -> None:
        """ HL = left value, DE = right value """
        op = node.op.upper()
        if op == '+':
            self._emit_import("rt_strcopy")
            self._emit_import("rt_strcat")
            self._emit_code("push    de")
            self._emit_code("ex      de,hl")
            self._reserve_heapmem(255, node)
            self._emit_code("call    rt_strcopy", info="(HL) <- (DE)")
            self._emit_code("pop     de")
            self._emit_code("call    rt_strcat", info="(HL) <- (HL) + (DE)")
        else:
            self._raise_error(2, node, f'unknown "{op}" string op')

    def _emit_real_op(self, node: AST.BinaryOp) -> None:
        """
        HL = left value, DE = right value
        WARNING: move to accum destroys DE and BC
        """
        self._emit_import("rt_math_call")
        self._emit_pushcontext()
        self._emit_code("push    hl", info="keep left value")
        self._emit_code("ex      hl,de", info="move right to accum2")
        self._moveflo_accum2()
        self._emit_code("pop     hl", info="restore left and move to accum1")
        self._moveflo_accum1()
        self._emit_code("ld      de,rt_math_accum2", info="restore right ptr")
        op = node.op.upper()
        if op == '+':
            self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_ADD}", info="MATH_REAL_ADD")
            self._emit_code("call    rt_math_call")
        elif op == '-':
            self._emit_code("ex      hl,de")
            self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_REV_SUBS}", info="MATH_REAL_REV_SUBS")
            self._emit_code("call    rt_math_call")
        elif op == '*':
            self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_MULT}", info="MATH_REAL_MULT")
            self._emit_code("call    rt_math_call")
        elif op == '/':
            self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_DIV}", info="MATH_REAL_DIV")
            self._emit_code("call    rt_math_call")
        else:
            self._raise_error(2, node, f'unknown "{op}" REAL op')
        self._moveflo_heap(node)
        self._emit_popcontext()

    def _emit_comparation(self, node: AST.BinaryOp) -> None:
        if node.left.etype == AST.ExpType.String:
            self._emit_str_comparation(node)
        elif node.left.etype == AST.ExpType.Real:
            self._emit_real_comparation(node)
        elif node.op == '=':
            self._emit_code("xor     a")
            self._emit_code("sbc     hl,de")
            self._emit_code("ld      hl,&FFFF", info="HL = -1 TRUE")
            self._emit_code("jr      z,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<>':
            self._emit_code("xor     a")
            self._emit_code("sbc     hl,de")
            self._emit_code("ld      hl,&FFFF", info="HL = -1 TRUE")
            self._emit_code("jr      nz,$+3")
            self._emit_code("inc     hl", info ="HL = 0 FALSE")
        elif node.op == '<':
            self._emit_import("rt_comp16")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,&FFFF", info="HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '>':
            self._emit_import("rt_comp16")
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,&FFFF", info="HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<=':
            self._emit_import("rt_comp16")
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,0", info="HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl", info="HL =-1 TRUE")
        elif node.op == '>=':
            self._emit_import("rt_comp16")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,0", info="HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl", info="HL =-1 TRUE")
        else:
            self._raise_error(2, node, f'INT "{node.op}" op not implemented yet')

    def _emit_str_comparation(self, node: AST.BinaryOp) -> None:
        self._emit_import("rt_strcmp")
        if node.op == '=':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF", info="HL = -1 TRUE")
            self._emit_code("jr      z,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<>':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF", info="HL = -1 TRUE")
            self._emit_code("jr      nz,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<':
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF", info="HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '>':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF", info="HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<=':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,0", info="HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl", info="HL =-1 TRUE")
        elif node.op == '>=':
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,0", info="HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl", info="HL =-1 TRUE")
        else:
            self._raise_error(2, node, f'STRING "{node.op}" op not implemented yet')

    def _emit_real_comparation(self, node: AST.BinaryOp) -> None:
        """
        HL = left value, DE = right value
        WARNING: move to accum destroys DE and BC
        """
        self._emit_import("rt_math_call")
        self._emit_pushcontext()
        self._emit_code("push    hl", info="keep left value")
        self._emit_code("ex      hl,de", info="move right to accum2")
        self._moveflo_accum2()
        self._emit_code("pop     hl", info="restore left and move to accum1")
        self._moveflo_accum1()
        self._emit_code("ld      de,rt_math_accum2", info="restore right ptr")
        self._emit_code(f"ld      ix,{FWCALL.MATH_REAL_COMP}", info="MATH_REAL_COMP")
        self._emit_code("call    rt_math_call", info="comp result is stored in A")
        # if the first real number is greater than the second real number, then A holds &01.
        # if the first real number is the same as the second real number, then A holds &00.
        # if the second real number is greater than the first real number, then A holds &FF.
        if node.op == '=':
            self._emit_code("ld      hl,&FFFF", info="HL = -1 TRUE")
            self._emit_code("jr      z,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<>':
            self._emit_code("ld      hl,&FFFF", info="HL = -1 TRUE")
            self._emit_code("jr      nz,$+3")
            self._emit_code("inc     hl", info ="HL = 0 FALSE")
        elif node.op == '<':
            self._emit_code("ld      hl,&FFFF", info="HL =-1 TRUE")
            self._emit_code("inc     a")
            self._emit_code("jr      z,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '>':
            self._emit_code("ld      hl,&FFFF", info="HL =-1 TRUE")
            self._emit_code("inc     a")
            self._emit_code("jr      nz,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<=':
            self._emit_code("inc     hl", info="HL = 0 FALSE")
            self._emit_code("dec     a")
            self._emit_code("jr      z,$+3")
            self._emit_code("dec     hl", info="HL =-1 TRUE")
        elif node.op == '>=':
            self._emit_code("inc     hl", info="HL = 0 FALSE")
            self._emit_code("inc     a")
            self._emit_code("jr      z,$+3")
            self._emit_code("dec     hl", info="HL =-1 TRUE")
        else:
            self._raise_error(2, node, f'REAL "{node.op}" op not implemented yet')
        self._emit_popcontext()
        
    def _emit_stream(self) -> None:
        """
        0-7 keyboard to screen
        8   keyboard to printer
        9   channel to file
        """
        self._emit_code("ld      a,l")
        self._emit_code(f"call    {FWCALL.TXT_STR_SELECT}", info="TXT_STR_SELECT")

    def _emit_stream_0(self) -> None:
        """
        #0 is the default stream when it is not indicated
        """
        self._emit_code("xor     a", info="Set stream to its default value (#0)")
        self._emit_code(f"call    {FWCALL.TXT_STR_SELECT}", info="TXT_STR_SELECT")

    # ----------------- AST Trasversal functions -----------------

    def _emit_comment(self, node: AST.Comment) -> None:
        pass

    def _emit_assigment_arrayitem(self, node: AST.ArrayItem) -> None:
        var = self.symtable.find(node.name, SymType.Array, self.context)
        if var is None:
            var = self.symtable.find(node.name, SymType.ArrayParam, self.context)
        if var is not None:
            self._emit_code("push    hl")
            self._emit_arrayitem_ptr(node)
            if var.exptype == AST.ExpType.Integer:    
                self._emit_code("pop     de")
                self._emit_code("ld      (hl),e")
                self._emit_code("inc     hl")
                self._emit_code("ld      (hl),d")
            elif var.exptype == AST.ExpType.Real:
                self._emit_code("ex      de,hl")
                self._emit_code("pop     hl")
                self._emit_code("ld      bc,5")
                self._emit_code("ldir")
            elif var.exptype == AST.ExpType.String:
                self._emit_code("ex      de,hl")
                self._emit_code("pop     hl")
                self._emit_code("ld      b,0")
                self._emit_code("ld      c,(hl)")
                self._emit_code("inc     c")
                self._emit_code("ldir")
        else:
            self._raise_error(38, node)

    def _emit_assigment_record(self, node: AST.Variable) -> None:
        varname, rname = node.name.split('$.')
        varname = varname + "$" # restore data type character
        var = self.symtable.find(varname, SymType.Variable, self.context)
        entry = self.symtable.find(rname, SymType.Record, self.context)
        if entry is not None and var is not None:
            if entry.exptype == AST.ExpType.Integer:
                self._emit_code(f"ld      ({var.label}+{entry.memoff}),hl")
            else:
                self._emit_code(f"ld      de,{var.label}+{entry.memoff}")
                self._emit_code("ld      b,0")
                if entry.exptype == AST.ExpType.String:
                    self._emit_code(f"ld      c,(hl)")
                    self._emit_code("inc     c")
                else:
                    self._emit_code(f"ld      c,{entry.datasz}")
                self._emit_code("ldir")
        else:
            self._raise_error(38, node)
    
    def _emit_assigment_param(self, param: SymEntry) -> None:
        """
        self._emit_code(f"ld      l,(ix+{entry.memoff})")
        self._emit_code(f"ld      h,(ix+{entry.memoff+1})")
        """
        if param.exptype == AST.ExpType.Integer:
            self._emit_code(f"ld      (ix+{param.memoff}),l")
            self._emit_code(f"ld      (ix+{param.memoff+1}),h")
        elif param.exptype == AST.ExpType.Real:
            self._emit_code(f"ld      e,(ix+{param.memoff})")
            self._emit_code(f"ld      d,(ix+{param.memoff+1})")
            self._emit_code(f"ld      bc,{param.datasz}")
            self._emit_code("ldir")
        elif param.exptype == AST.ExpType.String:
            self._emit_code(f"ld      e,(ix+{param.memoff})")
            self._emit_code(f"ld      d,(ix+{param.memoff+1})")
            self._emit_code("ld      b,0")
            self._emit_code("ld      c,(hl)")
            self._emit_code("inc     c")
            self._emit_code("ldir")

    def _emit_assigment_variable(self, node: AST.Variable) -> None:
        """
        Params are special variables because they don't have permanent reserved
        memory but are stored in the call stack frame and accessed through IX.
        """  
        var = self.symtable.find(node.name, SymType.Variable, self.context)
        if var is None:
            var = self.symtable.find(node.name, SymType.Param, self.context)
            if var is not None:
                self._emit_assigment_param(var)
                return
        if var is not None:
            if var.exptype == AST.ExpType.Integer:
                self._emit_code(f"ld      ({var.label}),hl")
            elif var.exptype == AST.ExpType.Real:
                self._emit_code(f"ld      de,{var.label}")
                self._emit_code(f"ld      bc,{var.datasz}")
                self._emit_code("ldir")
            elif var.exptype == AST.ExpType.String:
                self._emit_code(f"ld      de,{var.label}")
                self._emit_code("ld      b,0")
                self._emit_code("ld      c,(hl)")
                self._emit_code("inc     c")
                self._emit_code("ldir")
        else:
            self._raise_error(38, node)

    def _emit_assigment(self, node: AST.Assignment) -> None:
        self._emit_expression(node.source)
        if isinstance(node.target, AST.ArrayItem):
            self._emit_assigment_arrayitem(node.target)
        elif isinstance(node.target, AST.Variable):
            if "$." in node.target.name:
                self._emit_assigment_record(node.target)
            else:
                self._emit_assigment_variable(node.target)
        else:
            self._raise_error(38, node.target)

    def _emit_RSX(self, node: AST.RSX) -> None:
        """
        |<RSX command>[,<argument>[,<argument>]*]
        """
        self._emit_import("rt_restoreroms")
        self._emit_import("rt_rsx_setstring")
        self._emit_code(f"; RSX call to {node.command}")
        label = node.command
        sym = self.symtable.find(label, SymType.RSX, "")
        stringargs = 0
        if sym is not None:
            params = len(node.args)
            if params > 0:
                self._emit_pushcontext()
                for a in node.args:
                    self._emit_expression(a)
                    if a.etype == AST.ExpType.String:
                        self._emit_code(f"ld      de,rt_rsx_string{stringargs+1}")
                        self._emit_code("call    rt_rsx_setstring")
                        stringargs += 1
                        if stringargs > 2:
                            self._raise_error(14, a, info="too many string arguments")
                    self._emit_code("push    hl")
                self._emit_code("ld      ix,0")
                self._emit_code("add     ix,sp")
            self._emit_code(f"ld      hl,{sym.label}")
            self._emit_code(f"call    {FWCALL.KL_FIND_COMMAND}", info="KL_FIND_COMMAND")
            self._emit_code("jr      nc,$+7", info="CF if find succeeded")         
            self._emit_code(f"ld      a,{params}")
            self._emit_code(f"call    {FWCALL.KL_FAR_PCHL}", info="KL_FAR_PCHL")
            if params > 0:
                for i in range(0, params):
                    self._emit_code("pop     de")
                self._emit_popcontext()
        self._emit_code(";")

    def _emit_blockend(self, node: AST.BlockEnd) -> None:
        if node.name == "NEXT":
            self._emit_NEXT(node)
        elif node.name == "WEND":
            self._emit_WEND(node)
        elif node.name == "ELSE":
            self._emit_ELSE(node)
        elif node.name == "END IF":
            self._emit_END_IF(node)
        elif node.name == "END SELECT":
            self._emit_END_SELECT(node)
        else:
            self._raise_error(2, node, "not implemented yet")

    def _emit_userfun(self, node: AST.UserFun) -> None:
        self._emit_code(f"; Calling USER FUN {node.name}")
        if len(node.args):
            self._emit_pushcontext()
            for a in node.args:
                if isinstance(a, AST.Array):
                    entry = self.symtable.find(a.name, SymType.Array, self.context)
                    if entry is not None:
                        self._emit_code(f"ld      hl,{entry.label}")
                else:   
                    self._emit_expression(a)
                self._emit_code("push    hl")
            self._emit_code("ld      ix,0", info="last parameter position")
            self._emit_code("add     ix,sp")
        self._emit_code(f"call    {self._get_userfun_label(node.name)}")
        if len(node.args):
            for a in node.args:
                self._emit_code("pop     de", info="clean the stack")
            self._emit_popcontext()
        # Check heap memory will be within the limits 
        entry = self.symtable.find(node.name, SymType.Function)
        if entry is None:
            entry = self.symtable.find(node.name, SymType.Procedure)
        if entry is not None and entry.heapused > 0:
            # DEF FN functions are inline expressions that must free
            # heap memory now
            if entry.symtype == SymType.Function and node.name[:2].upper() == "FN":
                self.free_heap_memory = True
                self.reserved_heap_memory += entry.heapused
                self._check_heapmem()
            else:
                maxconsumed = self.reserved_heap_memory + entry.heapused
                if maxconsumed > self.max_heap_memory:
                    self.max_heap_memory = maxconsumed        
        self._emit_code(";")

    def _emit_function(self, node: AST.Function) -> None:
        """
        Function's result will be placed in HL
        """
        keyword = node.name
        funcname = "_emit_" + keyword.replace('$','SS').replace(' ', '_')
        emit_keyword = getattr(self, funcname , None)
        if emit_keyword is None:
            self._raise_error(2, node, f"unknown keyword {keyword}")
        return emit_keyword(node) # type: ignore[misc]

    def _emit_command(self, node: AST.Command) -> None:
        keyword = node.name
        funcname = "_emit_" + keyword.replace('$','SS').replace(' ', '_')
        emit_keyword = getattr(self, funcname , None)
        if emit_keyword is None:
            self._raise_error(2, node, f"unknown keyword {keyword}")
        return emit_keyword(node) # type: ignore[misc]

    def _emit_statement(self, stmt: AST.Statement) -> None:
        if isinstance(stmt, AST.Comment):
            self._emit_comment(stmt)
        elif isinstance(stmt, AST.Assignment):
            self._emit_assigment(stmt)
        elif isinstance(stmt, AST.If):
            self._emit_IF(stmt)
        elif isinstance(stmt, AST.ForLoop):
            self._emit_FOR(stmt)
        elif isinstance(stmt, AST.WhileLoop):
            self._emit_WHILE(stmt)
        elif isinstance(stmt, AST.SelectCase):
            self._emit_SELECT_CASE(stmt)
        elif isinstance(stmt, AST.BlockEnd):
            self._emit_blockend(stmt)
        elif isinstance(stmt, AST.Data):
            self._emit_DATA(stmt)
        elif isinstance(stmt, AST.Print):
            self._emit_PRINT(stmt)
        elif isinstance(stmt, AST.Input):
            self._emit_INPUT(stmt)
        elif isinstance(stmt, AST.LineInput):
            self._emit_LINE_INPUT(stmt)
        elif isinstance(stmt, AST.ReadIn):
            self._emit_READIN(stmt)
        elif isinstance(stmt, AST.Write):
            self._emit_WRITE(stmt)
        elif isinstance(stmt, AST.DefFN):
            self._emit_DEF_FN(stmt)
            return # we don't free mem after function declaration
        elif isinstance(stmt, AST.DefFUN):
            self._emit_FUNCTION(stmt)
            return # we don't free mem after function declaration
        elif isinstance(stmt, AST.DefSUB):
            self._emit_SUB(stmt)
            return # we don't free mem after sub declaration
        elif isinstance(stmt, AST.UserFun):
            self._emit_userfun(stmt)
        elif isinstance(stmt, AST.Function):
            self._emit_function(stmt)
        elif isinstance(stmt, AST.Command):
            self._emit_command(stmt)
        elif isinstance(stmt, AST.Label):
            self._emit_LABEL(stmt)
        elif isinstance(stmt, AST.RSX):
            self._emit_RSX(stmt)
        elif isinstance(stmt, AST.Nop):
            pass
        else:
            self._raise_error(2, stmt, "unexpected statement")
        self._emit_free_heapmem()

    def _emit_line(self, line: AST.Line) -> None:
        self._emit_line_label(line)
        for stmt in line.statements:
            self._emit_statement(stmt)

    def _compose_program(self) -> str:
        program = ""
        # Add initial LIMIT directive for ABASM if required   
        if self.memlimit < 99999:
            program = self.headcode.replace("$LIMIT$", f"limit   &{hex(self.memlimit)[2:]}")
        else:
            program = self.headcode.replace("$LIMIT$", "")
        program = program + self.heapcode + "\n" 
        # Fix floating point calls depending on the CPC machine
        if "rt_math_call" in self.runtime:
            self._emit_startup("call    rt_math_setoffset")

        program = program + self.startupcode + "_startup_end_:\n"
        program = program + "_code_:\n"
        program = program + self.srccode + "\n"
        program = program + self._emit_runtime()

        program = program + self.data[DataSec.GEN] + "\n"
        program = program + "_data_constants_:\n" + self.data[DataSec.CONST] + "\n"
        program = program + "_data_constants_end_:\n"
        program = program + "_data_variables_:\n" + self.data[DataSec.VARS] + "\n"
        program = program + "_data_variables_end_:\n"
        program = program + "_data_datablock_:\n" + self.data[DataSec.DATA] + "\n"
        program = program + "_data_datablock_end_:\n"
        if self.rtvars != "":
            program = program + "_data_runtime_vars_:\n" + self.rtvars + "\n"
        program = program + "_data_end_:\n"   
        return program + "_program_end_:\n"

    def emit_program(self) -> tuple[str, int]:
        print("Generating assembly code...")
        self.asm = ""
        self._emit_preamble()
        for line in self.program.lines:
            self._emit_line(line)
        self._emit_code_end()
        self._emit_heap_def()
        self._emit_amsdos_support()
        self._emit_symbols(self.symtable.syms)
        self._emit_symbol_table()
        return self._compose_program(), self.max_heap_memory
