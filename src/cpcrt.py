"""
BASC compiler z80 runtime functions

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation in its version 3.

This program is distributed in the hope that it will be useful
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
"""

#
# Addresses for CPC Firmware Rutines
#
class FWCALL:
    LOW_LIMIT           = "&170"
    HIGH_LIMIT          = "&B899"

    # LOW jumpblock
    
    RESET_ENTRY         = "&0000"
    LOW_JUMP            = "&0008"
    KL_LOW_PCHL         = "&000B"
    PCBC_INSTRUCTION    = "&000E"
    SIDE_CALL           = "&0010"
    KL_SIDE_PCHL        = "&0013"
    PCDE_INSTRUCTION    = "&0016"
    FAR_CALL            = "&0018"
    KL_FAR_PCHL         = "&001B"
    PCHL_INSTRUCTION    = "&001E"
    RAM_LAM             = "&0020"
    KL_FAR_CALL         = "&0023"
    FIRM_JUMP           = "&0028"
    USER_RESTART        = "&0030"
    INTERRUPT_ENTRY     = "&0038"
    EXT_INTERRUPT       = "&003B"

    # HI jumpblock

    KL_U_ROM_ENABLE     = "&B900" 
    KL_U_ROM_DISABLE    = "&B903" 
    KL_L_ROM_ENABLE     = "&B906"
    KL_L_ROM_DISABLE    = "&B909"
    KL_ROM_RESTORE      = "&B90C"
    KL_ROM_SELECT       = "&B90F"
    KL_CURR_SELECTION   = "&B912"
    KL_PROBE_ROM        = "&B915"
    KL_ROM_DESELECT     = "&B918"
    KL_LDIR             = "&B91B"
    KL_LDDR             = "&B91E"
    KL_POLL_SYNCHRONOUS = "&B921"
    KL_SCAN_NEEDED      = "&B92A"

    KM_INITIALISE       = "&BB00"
    KM_RESET            = "&BB03"
    KM_WAIT_CHAR        = "&BB06"
    KM_READ_CHAR        = "&BB09"
    KM_CHAR_RETURN      = "&BB0C"
    KM_SET_EXPAND       = "&BB0F"
    KM_GET_EXPAND       = "&BB12"
    KM_EXP_BUFFER       = "&BB15"
    KM_WAIT_KEY         = "&BB18"
    KM_READ_KEY         = "&BB1B"
    KM_TEST_KEY         = "&BB1E"
    KM_GET_STATE        = "&BB21"
    KM_GET_JOYSTICK     = "&BB24"
    KM_SET_TRANSLATE    = "&BB27"
    KM_GET_TRANSLATE    = "&BB2A"
    KM_SET_SHIFT        = "&BB2D"
    KM_GET_SHIFT        = "&BB30"
    KM_SET_CONTROL      = "&BB33"
    KM_GET_CONTROL      = "&BB36"
    KM_SET_REPEAT       = "&BB39"
    KM_GET_REPEAT       = "&BB3C"
    KM_SET_DELAY        = "&BB3F"
    KM_GET_DELAY        = "&BB42"
    KM_ARM_BREAK        = "&BB45"
    KM_DISARM_BREAK     = "&BB48"
    KM_BREAK_EVENT      = "&BB4B"

    TXT_INITIALISE      = "&BB4E"
    TXT_RESET           = "&BB51"
    TXT_VDU_ENABLE      = "&BB54"
    TXT_VDU_DISABLE     = "&BB57"
    TXT_OUTPUT          = "&BB5A"
    TXT_WR_CHAR         = "&BB5D"
    TXT_RD_CHAR         = "&BB60"
    TXT_SET_GRAPHIC     = "&BB63"
    TXT_WIN_ENABLE      = "&BB66"
    TXT_GET_WINDOW      = "&BB69"
    TXT_CLEAR_WINDOW    = "&BB6C"
    TXT_SET_COLUMN      = "&BB6F"
    TXT_SET_ROW         = "&BB72"
    TXT_SET_CURSOR      = "&BB75"
    TXT_GET_CURSOR      = "&BB78"
    TXT_CUR_ENABLE      = "&BB7B"
    TXT_CUR_DISABLE     = "&BB7E"
    TXT_CUR_ON          = "&BB81"
    TXT_CUR_OFF         = "&BB84"
    TXT_VALIDATE        = "&BB87"
    TXT_PLACE_CURSOR    = "&BB8A"
    TXT_REMOVE_CURSOR   = "&BB8D"
    TXT_SET_PEN         = "&BB90"
    TXT_GET_PEN         = "&BB93"
    TXT_SET_PAPER       = "&BB96"
    TXT_GET_PAPER       = "&BB99"
    TXT_INVERSE         = "&BB9C"
    TXT_SET_BACK        = "&BB9F"
    TXT_GET_BACK        = "&BBA2"
    TXT_GET_MATRIX      = "&BBA5"
    TXT_SET_MATRIX      = "&BBA8"
    TXT_SET_M_TABLE     = "&BBAB"
    TXT_GET_M_TABLE     = "&BBAE"
    TXT_GET_CONTROLS    = "&BBB1"
    TXT_STR_SELECT      = "&BBB4"
    TXT_SWAP_STREAMS    = "&BBB7"

    GRA_INITIALISE      = "&BBBA"
    GRA_RESET           = "&BBBD"
    GRA_MOVE_ABSOLUTE   = "&BBC0"
    GRA_MOVE_RELATIVE   = "&BBC3"
    GRA_ASK_CURSOR      = "&BBC6"
    GRA_SET_ORIGIN      = "&BBC9"
    GRA_GET_ORIGIN      = "&BBCC"
    GRA_WIN_WIDTH       = "&BBCF"
    GRA_WIN_HEIGHT      = "&BBD2"
    GRA_GET_W_WIDTH     = "&BBD5"
    GRA_GET_W_HEIGHT    = "&BBD8"
    GRA_CLEAR_WINDOW    = "&BBDB"
    GRA_SET_PEN         = "&BBDE"
    GRA_GET_PEN         = "&BBE1"
    GRA_SET_PAPER       = "&BBE4"
    GRA_GET_PAPER       = "&BBE7"
    GRA_PLOT_ABSOLUTE   = "&BBEA"
    GRA_PLOT_RELATIVE   = "&BBED"
    GRA_TEST_ABSOLUTE   = "&BBF0"
    GRA_TEST_RELATIVE   = "&BBF3"
    GRA_LINE_ABSOLUTE   = "&BBF6"
    GRA_LINE_RELATIVE   = "&BBF9"
    GRA_WR_CHAR         = "&BBFC"
    GRA_FILL            = "&BD52"

    SCR_INITIALISE      = "&BBFF"
    SCR_RESET           = "&BC02"
    SCR_SET_OFFSET      = "&BC05"
    SCR_SET_BASE        = "&BC08"
    SCR_GET_LOCATION    = "&BC0B"
    SCR_SET_MODE        = "&BC0E"
    SCR_GET_MODE        = "&BC11"
    SCR_CLEAR           = "&BC14"
    SCR_CHAR_LIMITS     = "&BC17"
    SCR_CHAR_POSITION   = "&BC1A"
    SCR_DOT_POSITION    = "&BC1D"
    SCR_NEXT_BYTE       = "&BC20"
    SCR_PREV_BYTE       = "&BC23"
    SCR_NEXT_LINE       = "&BC26"
    SCR_PREV_LINE       = "&BC29"
    SCR_INK_ENCODE      = "&BC2C"
    SCR_INK_DECODE      = "&BC2F"
    SCR_SET_INK         = "&BC32"
    SCR_GET_INK         = "&BC35"
    SCR_SET_BORDER      = "&BC38"
    SCR_GET_BORDER      = "&BC3B"
    SCR_SET_FLASHING    = "&BC3E"
    SCR_GET_FLASHING    = "&BC41"
    SCR_FILL_BOX        = "&BC44"
    SCR_FLOOD_BOX       = "&BC17"
    SCR_CHAR_INVERT     = "&BC4A"
    SCR_HW_ROLL         = "&BC4D"
    SCR_SW_ROLL         = "&BC50"
    SCR_UNPACK          = "&BC53"
    SCR_REPACK          = "&BC56"
    SCR_ACCESS          = "&BC59"
    SCR_PIXELS          = "&BC5C"
    SCR_HORIZONTAL      = "&BC5F"
    SCR_VERTICAL        = "&BC62"
    
    CAS_INITIALISE      = "&BC65"
    CAS_SET_SPEED       = "&BC68"
    CAS_NOISY           = "&BC6B"
    CAS_START_MOTOR     = "&BC6E"
    CAS_STOP_MOTOR      = "&BC71"
    CAS_RESTORE_MOTOR   = "&BC74"
    CAS_IN_OPEN         = "&BC77"
    CAS_IN_CLOSE        = "&BC7A"
    CAS_IN_ABANDON      = "&BC7D"
    CAS_IN_CHAR         = "&BC80"
    CAS_IN_DIRECT       = "&BC83"
    CAS_RETURN          = "&BC86"
    CAS_TEST_EOF        = "&BC89"
    CAS_OUT_OPEN        = "&BC8C"
    CAS_OUT_CLOSE       = "&BC8F"
    CAS_OUT_ABANDON     = "&BC92"
    CAS_OUT_CHAR        = "&BC95"
    CAS_OUT_DIRECT      = "&BC98"
    CAS_CATALOG         = "&BC9B"
    CAS_WRITE           = "&BC9E"
    CAS_READ            = "&BCA1"
    CAS_CHECK           = "&BCA4"

    SOUND_RESET         = "&BCA7"
    SOUND_QUEUE         = "&BCAA"
    SOUND_CHECK         = "&BCAD"
    SOUND_ARM_EVENT     = "&BCB0"
    SOUND_RELEASE       = "&BCB3"
    SOUND_HOLD          = "&BCB6"
    SOUND_CONTINUE      = "&BCB9"
    SOUND_AMPL_ENVELOPE = "&BCBC"
    SOUND_TONE_ENVELOPE = "&BCBF"
    SOUND_A_ADDRESS     = "&BCC2"
    SOUND_T_ADDRESS     = "&BCC5"

    KL_CHOKE_OFF        = "&BCC8"
    KL_ROM_WALK         = "&BCCB"
    KL_INIT_BACK        = "&BCCE"
    KL_LOG_EXT          = "&BCD1"
    KL_FIND_COMMAND     = "&BCD4"
    KL_NEW_FRAME_FLY    = "&BCD7"
    KL_ADD_FRAME_FLY    = "&BCDA"
    KL_DEL_FRAME_FLY    = "&BCDD"
    KL_NEW_FAST_TICKER  = "&BCE0"
    KL_ADD_FAST_TICKER  = "&BCE3"
    KL_DEL_FAST_TICKER  = "&BCE6"
    KL_ADD_TICKER       = "&BCE9"
    KL_DEL_TICKER       = "&BCEC"
    KL_INIT_EVENT       = "&BCEF"
    KL_EVENT            = "&BCF2"
    KL_SYNC_RESET       = "&BCF5"
    KL_DEL_SYNCHRONOUS  = "&BCF8"
    KL_NEXT_SYNC        = "&BCFB"
    KL_DO_SYNC          = "&BCFE"
    KL_DONE_SYNC        = "&BD01"
    KL_EVENT_DISABLE    = "&BD04"
    KL_EVENT_ENABLE     = "&BD07"
    KL_DISARM_EVENT     = "&BD0A"
    KL_TIME_PLEASE      = "&BD0D"
    KL_TIME_SET         = "&BD10"

    MC_BOOT_PROGRAM     = "&BD13"
    MC_START_PROGRAM    = "&BD16"
    MC_WAIT_FLYBACK     = "&BD19"
    MC_SET_MODE         = "&BD1C"
    MC_SCREEN_OFFSET    = "&BD1F"
    MC_CLEAR_INKS       = "&BD22"
    MC_SET_INKS         = "&BD25"
    MC_RESET_PRINTER    = "&BD28"
    MC_PRINT_TRANSLATION= "&BD58"
    MC_PRINT_CHAR       = "&BD2B"
    MC_BUSY_PRINTER     = "&BD2E"
    MC_SEND_PRINTER     = "&BD31"
    MC_SOUND_REGISTER   = "&BD34"

    # WATCH OUT: this are 464 addresses
    # 6128 are the same plus 36 bytes
    MATH_MOVE_REAL      = "&BD3D"
    MATH_INT_TO_REAL    = "&BD40"
    MATH_BIN_TO_REAL    = "&BD43"
    MATH_REAL_TO_INT    = "&BD46"
    MATH_REAL_TO_BIN    = "&BD49"
    MATH_REAL_FIX       = "&BD4C"
    MATH_REAL_INT       = "&BD4F"
    MATH_REAL_10A       = "&BD55"
    MATH_REAL_ADD       = "&BD58"
    MATH_REAL_REV_SUBS  = "&BD5E"
    MATH_REAL_MULT      = "&BD61"
    MATH_REAL_DIV       = "&BD64"
    MATH_REAL_COMP      = "&BD6A"
    MATH_REAL_UMINUS    = "&BD6D"
    MATH_REAL_SIGNUM    = "&BD70"
    MATH_SET_ANGLE_MODE = "&BD73"
    MATH_REAL_PI        = "&BD76"
    MATH_REAL_SQR       = "&BD79"
    MATH_REAL_POWER     = "&BD7C"
    MATH_REAL_LOG       = "&BD7F"
    MATH_REAL_LOG_10    = "&BD82"
    MATH_REAL_EXP       = "&BD85"
    MATH_REAL_SINE      = "&BD88"
    MATH_REAL_COSINE    = "&BD8B"
    MATH_REAL_TANGENT   = "&BD8E"
    MATH_REAL_ARCTANGENT= "&BD91"

    KM_TEST_BREAK       = "&BDEE"
    KM_SCAN_KEYS        = "&BDF4"

#
# RUNTIME rutines
# "rutine id": (([rutine code],[]),([dependencies],[]))
# 
RT = {
    #
    # RUNTIME VARIABLES
    #
    "rt_tmp_memory": ([
        "rt_memory_next: dw rt_memory_start\n",
        "rt_memory_start:\n",
    ], []),
    "rt_error": ([
        "; RT_ERROR\n",
        "; Variable, can be set by ERROR and read by ERR\n",
        "rt_error: db 0\n",
    ], []),
    #
    # MEM AND CALLS
    # 
    "rt_malloc": ([
        "; RT_MALLOC\n",
        "; Returns in HL the address to a temporal free memory block\n",
        "; reserving as many bytes as indicated by BC\n",
        "; Inputs:\n",
        ";     BC number of bytes to allocate\n",
        "; Outputs:\n",
        ";     HL address to the new reserved memory\n",
        ";     HL and Flags are modified\n",
        "rt_malloc:\n",
        "\tld      hl,(rt_memory_next)\n",
        "\tpush    hl\n",
        "\tadd     hl,bc\n",
        "\tld      (rt_memory_next),hl\n",
        "\tpop     hl\n",
        "\tret\n",
    ],["rt_free_all"]),
    "rt_malloc_de": ([
        "; RT_MALLOC_DE\n",
        "; Returns in DE the address to a temporal free memory block\n",
        "; reserving as many bytes as indicated by BC\n",
        "; Inputs:\n",
        ";     BC number of bytes to allocate\n",
        "; Outputs:\n",
        ";     DE address to the new reserved memory\n",
        ";     DE and Flags are modified\n",
        "rt_malloc_de:\n",
        "\tld      de,(rt_memory_next)\n",
        "\tpush    de\n",
        "\tex      de,hl\n",
        "\tadd     hl,bc\n",
        "\tex      de,hl\n",
        "\tld      (rt_memory_next),de\n",
        "\tpop     de\n",
        "\tret\n",
    ],["rt_free_all"]),
    "rt_free_all": ([
        "; RT_FREE_ALL\n",
        "; Resets the position of the next available temporal memory block\n",
        "; to its initial position\n",
        "; Inputs:\n",
        ";     None\n",
        "; Outputs:\n",
        ";     None\n",
        ";     DE gets modified\n",
        "rt_free_all:\n",
        "\tld      de,rt_memory_start\n",
        "\tld      (rt_memory_next),de\n",
        "\tret\n",
    ], []),
    "rt_call": ([
        "; RT_CALL\n",
        "; Jumps to the address passed in HL and uses the RET from the\n",
        "; callee to return to the original caller.\n",
        "; Inputs:\n",
        ";      A number of additional parameters in the stack\n",
        ";     IX address to the last parameter in the stack\n",
        ";     HL address to call to\n",
        "; Outputs:\n",
        ";     Depends on the callee\n",
        "rt_call:\n",
        "\tjp      (hl)\n",
    ],[]),
    "rt_math_call": ([
        "; RT_MATH_CALL\n",
        "; Jumps to the address passed in DE but it adjusts the address\n",
        "; so in 664 and 6128 machines it adds 36 bytes which is the shift\n",
        "; in the math jumpblock between these machines and the 464.\n",
        "; Inputs:\n",
        ";     IX call address as per 464 firmware jumpblock\n",
        "; Outputs:\n",
        ";     Depends on the callee\n",
        ";     BC and IX are directly modified\n",
        "rt_math_call:\n",
        "\tld      bc,(rt_math_offset)  ; adjutst for non 464 machines\n"
        "\tadd     ix,bc\n",
        "\tjp      (ix)\n",
        "; RT_MATH_SETOFFSET\n",
        "; Checks the Amstrad CPC model and sets the value of rt_math_offset\n",
        "; so rt_math_call can find the right jumpblock addres.\n",
        "; Inputs:\n",
        ";     None\n",
        "; Outputs:\n",
        ";     None\n",
        ";     AF, BC and DE are directly modified\n",
        "rt_math_accum1:  dw  0,0,0,0,0  ; float values to use with firmware call must be over first 4k\n",
        "rt_math_accum2:  dw  0,0,0,0,0  ; float values to use with firmware call must be over first 4k\n",
        "rt_math_offset: dw  0\n",
        "rt_math_setoffset:\n",
        "\tld      c,0     ; ROM select address\n",
        f"\tcall    {FWCALL.KL_PROBE_ROM}   ; KL_PROBE_ROM\n",
        "\tld      a,h     ; 0 = CPC464, 1 = CPC664, 2 = CPC6128, 4 = Plus)\n",
        "\tor      a\n",
        "\tret     z\n",
        "\tld      a,&24   ; offset for 664 and 6128\n",
        "\tld      (rt_math_offset),a\n",
        "\tret\n",
    ],[]),
    #
    # STRINGS
    #      
    "rt_stradd_len": ([
        "; RT_STRADD_LEN\n",
        "; Returns the addition of two string lenghts.\n",
        "; Final length is cropped to 254 if exceeds.\n",        
        "; Inputs:\n",
        ";    HL address to length1 in memory\n",
        ";    DE address to length2 in memory\n",
        "; Outputs:\n",
        ";     A resulting length (HL) + (DE) truncated to 254 if needed\n",
        ";     B is modified, HL, DE and C are preserved\n",
        "rt_stradd_len:\n",
        "\tld     b,(hl)\n",
        "\tld     a,(de)\n",
        "\tadd    a,b\n",
        "\tjr     nc,__addlen_checkmax\n",
        "\tjr     __addlen_crop\n",
        "__addlen_checkmax:\n",
        "\tcp     255\n",
        "\tret    c\n",
        "__addlen_crop:\n",
        "\tld     a,254\n         ; max allowed\n",
        "\tret\n"
    ],[]),
    "rt_strcopy": ([
        "; RT_STRCOPY\n",
        "; Strings length is limited to 254 characters\n",
        "; First byte contains the string length\n",       
        "; Inputs:\n",
        ";     HL destination\n",
        ";     DE origin\n",
        "; Outputs:\n",
        ";     HL address to the destination string\n",
        ";     AF, B and DE are modified, C is preservedmake\n",
        "rt_strcopy:\n",
        "\tpush    hl\n",
        "\tld      a,(de)     ; total characters to copy\n",
        "\tld      (hl),a     ; number of copied characters\n",
        "\tld      b,a\n"
        "__strcopy_loop:\n",
        "\tinc     hl         ; reserve first byte for length\n",
        "\tinc     de         ; first character\n",
        "\tld      a,(de)\n",
        "\tld      (hl),a\n",
        "\tdjnz    __strcopy_loop\n",
        "\tpop     hl\n",
        "\tret\n",
    ],[]),
    "rt_strcat": ([
        "; RT_STRCAT\n",
        "; DE string gets append to the end of HL string\n",
        "; First byte contains the string length\n",
        "; Inputs:\n",
        ";     HL and DE\n",
        "; Outputs:\n",
        ";     HL points to the resulting string (HL+DE)\n",
        ";     AF, BC and DE are modified\n",
        "rt_strcat:\n",
        "\tcall    rt_stradd_len     ; lets get final length\n"
        "\tld      b,(hl)            ; current length\n",
        "\tld      c,(hl)            ; current length backup\n"
        "\tld      (hl),a            ; store final length\n",
        "\tsub     b\n",
        "\tld      b,a               ; B has the number of bytes to copy\n",
        "\tpush    hl\n",
        "\tld      a,c               ; destination string current len\n",
        "\tadd     a,l\n",
        "\tld      l,a\n",
        "\tadc     a,h\n",
        "\tsub     l\n",
        "\tld      h,a               ; HL points to the its string last byte\n",
        "__strcat_loop:\n"
        "\tinc     hl\n",
        "\tinc     de\n",
        "\tld      a,(de)\n",
        "\tld      (hl),a\n",
        "\tdjnz    __strcat_loop\n",
        "\tpop     hl\n",
        "\tret\n"
    ],["rt_stradd_len"]),
    "rt_strcmp": ([
        "; RT_STRCMP\n",
        "; Compares two strings pointed by HL and DE and sets ZF and CF:\n",
        "; HL=DE ZF=1, HL<DE ZF=0 CF=0, HL>DE ZF=0 CF=1\n",
        "; Inputs:\n",
        ";     HL and DE\n",
        "; Outputs:\n",
        ";     Flags ZF and CF store the result of the comparation\n",
        ";     AF and B are modified\n",
        "rt_strcmp:\n",
        "\tld      a,(de)\n",
        "\tcp      (hl)\n",
        "\tjr      nc,$+3\n",
        "\tld      a,(hl)\n",
        "\tor      a\n",
        "\tret     z              ; empty strings\n",
        "\tpush    hl\n",
        "\tpush    de\n",
        "\tld      b,a            ; longer string length\n",
        "__strcmp_loop:\n",
        "\tinc     hl\n",
        "\tinc     de\n",
        "\tld      a,(de)\n",
        "\tcp      (hl)\n",
        "\tjr      nz,__strcmp_end\n",
        "\tdjnz    __strcmp_loop\n",
        "\tpop     de            ; seems equal\n",
        "\tpop     hl            ; lets check again their lengths\n",
        "\tld      a,(de)\n",
        "\tcp      (hl)\n",
        "\tret\n",
        "__strcmp_end:\n",
        "\tpop     de\n",
        "\tpop     hl\n",
        "\tret\n"
    ],[]),
    "rt_int2str": ([
        "; RT_INT2STR\n",
        "; HL starts containing the number to convert to string\n",
        "; HL ends storing the memory address to the buffer\n",
        "; Subroutine taken from:\n",
        "; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA\n",
        "; Inputs:\n",
        ";     HL number to concert to string\n",
        "; Outputs:\n",
        ";     HL points to the temporal address in memory with the string\n",
        ";      C indicates if the number is negative (C=1) or positive (C=0)\n",
        ";     HL, BC, DE, AF are modified\n",
        "rt_int2str_buf: defs 8\n",
        "rt_int2str:\n",
        "\tld      de,rt_int2str_buf\n"
        "\tinc     de     ; first byte stores string length\n",
        "\tld      bc,0   ; B will count total numbers and C indicates negative\n",
        "\t; Detect sign of HL\n",
        "\tbit     7,h\n",
        "\tjr      z,__int2str_loop1\n",
        "\t; HL is negative so add '-' to string and negate HL\n"
        '\tld      a,"-"\n',
        "\tld      (de),a\n",
        "\tinc     de\n",
        "\tinc     c\n",
        "\t; Negate HL \n",
        "\txor     a\n",
        "\tsub     l\n",
        "\tld      l,a\n",
        "\tld      a,0    ; Note that XOR A or SUB A would disturb CF\n",
        "\tsbc     a,h\n",
        "\tld      h,a\n",
        "__int2str_loop1:\n",
        "\tpush    bc\n",
        "\tcall    rt_div16_by10 ; HL = HL / A, A = remainder\n",
        "\tpop     bc\n",
        "\tpush    af     ; Store digit in stack in reversed order\n",
        "\tinc     b\n",
        "\tld      a,h\n",
        "\tor      l      ; Stop if quotent is 0\n",
        "\tjr      nz, __int2str_loop1\n",
        "\t; Store string length\n",
        "\tld      hl,rt_int2str_buf\n",
        "\tld      a,b\n",
        "\tadd     c\n",
        "\tld      (hl),a\n",
        "__int2str_loop2:\n",
        "\t; Retrieve digits from stack\n",
        "\tpop     af\n",
        "\tor      &30    ; '0' + A\n",
        "\tld      (de), a\n",
        "\tinc     de\n",
        "\tdjnz    __int2str_loop2\n",
        "\tret\n",
    ],["rt_div16_by10"]),
    "rt_strz2num": ([
        "; RT_STRZ2NUM\n",
        "; Converts a string with an integer, hexadecimal or binary number to\n",
        "; its numerical 16 bits long form\n",
        "; Inputs:\n",
        ";     DE address to the null-terminated string with the number\n",
        "; Outputs:\n",
        ";     HL resulting number\n",
        ";     AF, HL, DE and BC are modified\n",
        "rt_strz2num:\n",
        "\tld      a,(de)\n",
        '\tcp      "&"\n',
        "\tjr      nz,rt_strz2int\n",
        "\tinc     de\n",
        "\tld      a,(de)\n",
        '\tcp      "X"\n',
        "\tjr      z,__strz2num_bin\n",
        '\tcp      "x"\n',
        "\tjr      z,__strz2num_bin\n",
        "\tjp      rt_strz2hex\n",
        "__strz2num_bin:\n",
        "\tinc     de\n"
        "\tjp      z,rt_strz2bin\n",
        "\n",
        "; RT_STRZ2INT\n",
        "; DE address to the null-terminated string, ends pointing to first\n",
        "; char not converted.\n",
        "; Routine based in the library created by Zeda:\n",
        "; https://github.com/Zeda/Z80-Optimized-Routines\n",
        "; Inputs:\n",
        ";     DE address to the source null-terminated string\n",
        "; Outputs:\n",
        ";     HL contains the converted number\n",
        ";     HL, BC, DE, AF are modified\n",
        "rt_strz2int:\n",
        "\tld      hl,0\n",
        "__strz2int_loop:\n",
        "\tld      a,(de)\n",
        "\tsub     &30    ; '0' character\n",
        "\tcp      10\n",
        "\tret     nc     ; some other character > 9\n",
        "\tinc     de\n",
        "\tld      b,h\n",
        "\tld      c,l\n",
        "\tadd     hl,hl  ; x2\n",
        "\tadd     hl,hl  ; x4\n",
        "\tadd     hl,bc  ; x5\n",
        "\tadd     hl,hl  ; x10\n",
        "\tadd     l\n",
        "\tld      l,a\n",
        "\tjr      nc,__strz2int_loop\n",
        "\tinc     h\n",
        "\tjp      __strz2int_loop\n",
        "__strz2int_end:\n",
        "\n",
        "; RT_STRZ2HEX\n",
        "; DE address to the null-terminated string with a hexadecimal number,\n",
        "; ends pointing to first char not converted.\n",
        "; Inputs:\n",
        ";     DE address to the source null-terminated string\n",
        "; Outputs:\n",
        ";     HL contains the converted number\n",
        ";     HL, BC, DE, AF are modified\n",
        "rt_strz2hex:\n",
        "\tld      hl,0\n",
        "__str2hex_next:\n",
        "\tld      a,(de)\n",
        "\tor      a\n",
        "\tret     z\n",
        "\tinc     de\n",
        '\tcp      "&"\n',
        "\tjr      z,__str2hex_next\n",
        '\tcp      "H"\n',
        "\tjr      z,__str2hex_next\n",
        '\tcp      "h"\n',
        "\tjr      z,__str2hex_next\n",
        '\tcp      "0"\n',
        "\tret     c                 ; < 0 end of conversion\n",
        '\tcp      "9"+1             ; < 10\n',
        "\tjr      c,__str2hex_digit ; '0'..'9'\n",
        '\tcp      "A"\n',
        "\tret     c                 ; < A end of conversion\n",
        '\tcp      "F"+1\n',
        "\tjr      c,__str2hex_upper ; 'A'..'F'\n",
        '\tcp      "a"\n',
        "\tret     c                 ; < a end of conversion\n",
        '\tcp      "f"+1\n',
        "\tjr      c,__str2hex_lower\n",
        "\tret                       ; > f end of conversion\n",
        "__str2hex_digit:\n",
        '\tsub     "0"\n',
        "\tld      c,a\n",
        "\tjr      __str2hex_shiftadd\n",
        "__str2hex_upper:\n",
        '\tsub     "A"-10\n',
        "\tld      c,a\n",
        "\tjr      __str2hex_shiftadd\n",
        "__str2hex_lower:\n",
        '\tsub     "a"-10\n',
        "\tld      c,a\n",
        "\tjr      __str2hex_shiftadd\n",
        "__str2hex_shiftadd        ; HL = HL*16 + C\n",
        "\tadd     hl,hl           ; *2\n",
        "\tadd     hl,hl           ; *4\n",
        "\tadd     hl,hl           ; *8\n",
        "\tadd     hl,hl           ; *16\n",
        "\tld      b,0\n",
        "\tld      a,c\n",
        "\tld      c,a\n",
        "\tadd     hl,bc\n",
        "\tjr      __str2hex_next\n",
        "\n",
        "; RT_STRZ2BIN\n",
        "; DE address to the null-terminated string with a binary number,\n",
        "; ends pointing to first char not converted.\n",
        "; Inputs:\n",
        ";     DE address to the source null-terminated string\n",
        "; Outputs:\n",
        ";     HL contains the converted number\n",
        ";     HL, BC, DE, AF are modified\n",
        "rt_strz2bin:\n",
        "\tld      hl,0\n",
        "__str2bin_next:\n",
        "\tld      a,(de)\n",
        "\tor      a\n",
        "\tret     z\n",
        "\tinc     de\n",
        '\tcp      "&"\n',
        "\tjr      z,__str2hex_next\n",
        '\tcp      "X"\n',
        "\tjr      z,__str2hex_next\n",
        '\tcp      "x"\n',
        "\tjr      z,__str2hex_next\n",
        '\tcp      "0"\n',
        "\tret     c                 ; < 0 end\n",
        '\tcp      "2"\n',
        "\tret     nc                ; > 1 end\n",
        '\tsub     "0"\n',
        "\tadd     hl,hl             ; hl = hl *2\n",
        "\tor      l\n",
        "\tld      l,a\n",
        "\tjr      __str2bin_next\n",
    ],[]),
    "rt_int2hex": ([
        "; RT_INT2HEX"
        "; Converts a two-bytes integer in an string with its hexadecimal\n",
        "; representation. Routine inspired by the one included in\n",
        "; 'Ready Made Machine Language Routines' book\n",
        "; Inputs:\n",
        ";     A min number of characters: 2 or 4\n",
        ";    HL string address\n",
        ";    DE integer to convert\n",
        "; Outputs:\n",
        ";     HL address to the string with the conversion\n",
        ";     BC, AF are modified\n",
        "rt_int2hex:\n",
        "\tpush    hl\n",
        "\tinc     hl\n",
        "\tld      c,2\n",
        "\tcp      3\n",
        "\tjr      c,__int2hex_low\n",
        "__int2hex_high:\n",
        "\tinc     c\n",
        "\tinc     c\n",
        "\tld      a,d\n",
        "\tcall    __a2hex\n",
        "__int2hex_low:\n",
        "\tld      a,e\n",
        "\tcall    __a2hex\n",
        "\tpop     hl\n",
        "\tld      (hl),c\n",
        "\tret\n",
        "__a2hex:\n",
        "\tpush    bc\n",
        "\tld      b,2    ; b=0 marks the end\n",
        "\tld      c,a    ; keep number so we can restore it\n",
        "\trr      a      ; move high order bits\n",
        "\trr      a      ; into the low part\n",
        "\trr      a\n",
        "\trr      a\n",
        "__a2hex_conv:\n",
        "\tand     &0F\n",
        "\tcp      &0A    ; check if is greater or equal\n",
        "\tjr      nc,__a2hex_letter\n",
        "\tadd     a,&30  ; get the number ASCII code\n",
        "\tjr      __a2hex_store\n",
        "__a2hex_letter:\n",
        "\tadd     a,&37\n",
        "__a2hex_store:\n",
        "\tld      (hl),a\n",
        "\tinc     hl\n",
        "\tld      a,c    ; restore number for next loop\n",
        "\tdjnz    __a2hex_conv\n",
        "\tpop     bc\n",
        "\tret\n",
    ],[]),
    "rt_int2bin": ([
        "; RT_INT2BIN"
        "; Converts a two-bytes integer in an string with its binary\n",
        "; representation. Routine inspired by the one included in\n",
        "; 'Ready Made Machine Language Routines' book\n",
        "; Inputs:\n",
        ";     A min number of characters: 8 or 16\n",
        ";    HL string address\n",
        ";    DE integer to convert\n",
        "; Outputs:\n",
        ";     HL address to the string with the conversion\n",
        ";     BC, AF are modified\n",
        "rt_int2bin:\n",
        "\tpush    hl\n",
        "\tinc     hl\n",
        "\tld      c,8\n",
        "\tcp      9\n",
        "\tjr      c,__int2bin_low\n",
        "__int2bin_high:\n",
        "\tld      c,16\n",
        "\tld      a,d\n",
        "\tcall    __a2bin\n",
        "__int2bin_low:\n",
        "\tld      a,e\n",
        "\tcall    __a2bin\n",
        "\tpop     hl\n",
        "\tld      (hl),c\n",
        "\tret\n",
        "__a2bin:\n",
        "\tld      b,8\n",
        "__a2bin_loop:\n",
        "\trla\n",
        "\tjr      c,$+6\n",
        "\tld      (hl),&30\n",
        "\tjr      $+4\n",
        "\tld      (hl),&31\n",
        "\tinc     hl\n",
        "\tdjnz    __a2bin_loop\n",
        "\tret\n",
    ],[]),
    "rt_copychrs": ([
        "; RT_COPYCHRS\n",
        "; Returns the character in the current cursor position for the\n"
        "; stream given in A.\n",
        "; Inputs:\n",
        ";      A souce stream (0-9)\n",
        ";     HL destination string\n",
        "; Outputs:\n",
        ";     HL  points to the resulting string (may be 0 len)\n",
        ";     DE, AF and B are modified\n",
        "rt_copychrs:\n",
        "\tld      (hl),0\n",
        "\tex      de,hl\n",
        f"\tcall    {FWCALL.TXT_STR_SELECT}  ; TXT_STR_SELECT\n",
		"\tld      c,a     ; save current selected stream\n",
		f"\tcall    {FWCALL.TXT_RD_CHAR}  ; TXT_RD_CHAR\n",
        "\tret     nc      ; NC means error\n",
		"\tld      b,a\n",
        "\tld      a,c\n",
		f"\tcall    {FWCALL.TXT_STR_SELECT}  ; TXT_STR_SELECT\n",
        "\tex      de,hl\n",
        "\tld      (hl),1\n",
        "\tinc     hl\n",
        "\tld      (hl),b\n",
        "\tdec     hl\n",
        "\tret\n",
    ],[]),
    "rt_findstr": ([
        "; RT_FINDSTR\n",
        "; Search the string pointed by HL looking for\n",
        "; substring pointed by DE. Returns in A 0\n",
        "; if the substring wasn't found or the position\n",
        "; Inputs:\n",
        ";     HL address to the main string\n",
        ";     DE address to the substring\n",
        ";      B starting position in HL (starting from 1)\n",
        "; Outputs:\n",
        ";     HL  0 no match found or the position of first ocurrence\n",
        ";     HL, BC, DE and AF are modified\n",
        "rt_findstr:\n",
        "\tld      a,(hl)  ; main string len\n",
        "\tpush    hl\n",
        "\tsub     b       ; apply starting position\n",
        "\tjr      c,__findstr_nomatch+1\n",
        "\tinc     a       ; bacause starting pos starts in 1\n",
        "\tinc     hl\n",
        "\tdjnz    $-1\n",
        "\tld      b,a\n",
        "__findstr_find1st:\n",
        "\tld      a,(de)  ; substring len\n",
        "\tld      c,a\n",
        "\tpush    de\n",
        "\tinc     de\n",
        "\tld      a,(de)  ; first substr char\n",
        "__findstr_loop1:\n",
        "\tcp      (hl)\n",
        "\tjr      z,__findstr_loop2\n",
        "\tinc     hl\n",
        "\tdjnz    __findstr_loop1\n",
        "__findstr_nomatch:\n",
        "\tpop     de\n",
        "\tpop     hl\n",
        "\tld      hl,0\n",
        "\tret\n",
        "__findstr_loop2:\n",
        "\tdec     c\n",
        "\tjr      z,__findstr_match\n",
        "\tdec     b\n",
        "\tjr      z,__findstr_nomatch\n",
        "\tinc     de\n",
        "\tinc     hl\n",
        "\tld      a,(de)\n",
        "\tcp      (hl)\n",
        "\tjr      z,__findstr_loop2\n",
        "\tpop     de\n",
        "\tjr      __findstr_find1st\n",
        "__findstr_match:\n",
        "\tpop     de\n",
        "\tld      a,(de)  ; len substr\n",
        "\tdec     a\n",
        "\tld      b,0\n",
        "\tld      c,a\n",
        "\tsbc     hl,bc   ; HL = current HL - (len DE - 1)\n",
        "\tpop     de\n",
        "\tsbc     hl,de   ; HL = HL - original HL\n",
        "\tret\n",
    ],[]),
    "rt_substr": ([
        "; RT_SUBSTR\n",
        "; Returns part of a string (a substring) of the string pointed by HL\n",
        "; and places them in the string pointed by DE. The starting position to\n",
        "; copy is in C and B has the number of characters to copy (0 to copy\n",
        "; to the end).\n",
        "; Inputs:\n",
        ";     HL address to the source string\n",
        ";     DE address to the destintion string\n",
        ";      C starting position in source string\n",
        ";      B number of characters to copy, 0 copies to the end\n",
        "; Outputs:\n",
        ";     HL  points to the destination string\n",
        ";     HL, BC, DE and AF are modified\n",
        "rt_substr:\n",
        "\tld      a,b\n",
	    "\tor      a\n",
	    "\tjr      nz,$+3\n",
	    "\tld      b,(hl)  ; by default all chars from start to the end\n",
        "\tld      a,(hl)  ; main string len\n",
        "\tex      de,hl\n",
        "\tld      (hl),0\n"
        "\tsub     c\n",
        "\tret     c\n",
        "\tinc     a\n",
        "\tcp      b\n",
        "\tjr      nc,$+3\n",
        "\tld      b,a\n",
        "\tld      (hl),b\n",
        "\tex      de,hl\n",
        "\tinc     hl\n",
        "\tdec     c\n",
        "\tjr      nz,$-2\n",
        "\tpush    de\n",
        "\tinc     de\n",
        "\tld      c,b\n",
        "\tld      b,0\n",
        "\tldir\n",
        "\tpop     hl\n",
        "\tret\n",
    ],[]),
    "rt_strleft": ([
        "; RT_STRLEFT\n",
        "; Extracts characters to the left of the string pointed by HL\n",
        "; and places them in the string pointed by DE. The number of\n",
        "; characters to copy are in C\n",
        "; Inputs:\n",
        ";     HL address to the source string\n",
        ";     DE address to the destintion string\n",
        ";      C number of characters to copy\n",
        "; Outputs:\n",
        ";     HL  points to the destination string\n",
        ";     HL, BC, DE and AF are modified\n",
        "rt_strleft:\n",
        "\tld      a,(hl)  ; main string len\n",
        "\tcp      c       ; more chars than the len of source string\n",
        "\tret     c\n",
        "\tpush    de\n",
        "\tld      (de),a  ; destination length\n",
        "\tinc     hl\n",
        "\tinc     de\n",
        "\tld      b,0\n",
        "\tldir\n",
        "\tpop     hl\n",
        "\tret\n",
    ],[]),
    "rt_strright": ([
        "; RT_STRRIGHT\n",
        "; Extracts characters to the right of the string pointed by HL\n",
        "; and places them in the string pointed by DE. The number of\n",
        "; characters to copy are in C\n",
        "; Inputs:\n",
        ";     HL address to the source string\n",
        ";     DE address to the destintion string\n",
        ";      C number of characters to copy\n",
        "; Outputs:\n",
        ";     HL  points to the destination string\n",
        ";     HL, BC, DE and AF are modified\n",
        "rt_strright:\n",
        "\tld      a,(hl)  ; main string len\n",
        "\tsub     c       ; more chars than the len of source string\n",
        "\tret     c\n",
        "\tret     z\n",
        "\tld      b,a\n",
        "\tld      a,c\n",
        "\tld      (de),a\n",
        "\tpush    de\n",
        "\tinc     b\n",
        "\tinc     de\n",
        "\tinc     hl\n",
        "\tdjnz    $-1\n",
        "\tldir\n",
        "\tpop     hl\n",
        "\tret\n",
    ],[]),
    "rt_strfill": ([
        "; RT_STRFILL\n",
        "; Fills the string pointed by DE with the character in C\n",
        "; as may times as indicated by HL, returs in HL de address to DE\n",
        ";Inputs:\n",
        ";     DE target string address\n",
        ";     HL number of repetitions (0-255)\n",
        ";      C character to print\n",
        ";Outputs:\n",
        ";     HL points to string\n",
        ";     AF, HL, DE and B are modified\n",
        "rt_strfill:\n",
        "\tld      a,l\n",
        "\tld      b,a\n",
        "\tld      (de),a\n",
        "\tpush    de\n",
        "\tld      a,c\n",
        "\tinc     de\n",
        "\tld      (de),a\n",
        "\tdjnz    $-2\n",
        "\tpop     hl\n",
        "\tret\n",
    ],[]),
    "rt_upper": ([
        "; RT_UPPER\n",
        "; Copies to address in DE a new string the same as the input string\n",
        "; pointed by HL but in which all lower case characters are converted\n",
        "; to upper case.\n",
        ";Inputs:\n",
        ";     DE target string address\n",
        ";     HL source string address\n",
        ";Outputs:\n",
        ";     HL points to the target string\n",
        ";     AF, HL, DE and B are modified\n",
        "rt_upper:\n",
        "\tpush    de  ; Save string address\n",
        "\tld      a,(hl)\n",
        "\tld      (de),a\n",
        "\tor      a\n",
        "\tret     z\n",
        "\tld      b,a\n",
        "\tinc     hl\n", 
        "\tinc     de\n",  
        "__upper_loop:\n",                    
        "\tld      a,(hl)\n",
        '\tcp      "a"  ; check if it is in the lower case range\n',
        "\tjr      c,__upper_next\n",
        '\tcp      "z"+1\n',
        "\tjr      nc,__upper_next\n",
        '\tsub     "a"-"A"\n',
        "__upper_next:\n",
        "\tld      (de),a\n",
        "\tinc     hl\n",
        "\tinc     de\n",
        "\tdjnz    __upper_loop\n",
        "\tpop     hl\n",
        "\tret\n",  
    ], []),
        "rt_lower": ([
        "; RT_LOWER\n",
        "; Copies to address in DE a new string the same as the input string\n",
        "; pointed by HL but in which all upper case characters are converted\n",
        "; to lower case.\n",
        ";Inputs:\n",
        ";     DE target string address\n",
        ";     HL source string address\n",
        ";Outputs:\n",
        ";     HL points to the target string\n",
        ";     AF, HL, DE and B are modified\n",
        "rt_lower:\n",
        "\tpush    de  ; Save string address\n",
        "\tld      a,(hl)\n",
        "\tld      (de),a\n",
        "\tor      a\n",
        "\tret     z\n",
        "\tld      b,a\n",
        "\tinc     hl\n", 
        "\tinc     de\n",  
        "__lower_loop:\n",                    
        "\tld      a,(hl)\n",
        '\tcp      "A"  ; check if it is in the upper case range\n',
        "\tjr      c,__lower_next\n",
        '\tcp      "Z"+1\n',
        "\tjr      nc,__lower_next\n",
        '\tadd     "a"-"A"\n',
        "__lower_next:\n",
        "\tld      (de),a\n",                    
        "\tinc     hl\n",
        "\tinc     de\n",
        "\tdjnz    __lower_loop\n",
        "\tpop     hl\n",
        "\tret\n",  
    ], []),
    #
    # DATA BLOCKS
    # 
    "rt_datablock": ([
        "\trt_data_ptr: dw  _data_datablock_\n",
    ],[]),
    "rt_read_int": ([
        "; RT_READ_INT\n",
        "; Copies into HL the next INTEGER in the DATA block\n",
        "; Inputs:\n",
        ";     None\n",
        "; Outputs:\n",
        ";     HL next integer in the DATA block\n",
        ";     HL and DE are modified\n",
        "rt_read_int:\n",
        "\tld      de,(rt_data_ptr)\n",
        "\tld      hl,(de)\n",
        "\tinc     de\n",
        "\tld      (rt_data_ptr),de\n",
        "\tret\n",
    ],["rt_datablock"]),
    "rt_read_real": ([
        "; RT_READ_REAL\n",
        "; Copies into the real pointed by HL the next REAL in the DATA block\n",
        "; Inputs:\n",
        ";     HL address to the target real number\n",
        "; Outputs:\n",
        ";     HL address to the real number\n",
        ";     HL, BC and DE are modified\n",
        "rt_read_int:\n",
        "\tpush    hl\n",
        "\tld      de,(rt_data_ptr)\n",
        "\tld      bc,5\n",
        "\tex      de,hl\n",
        "\tldir\n",
        "\tinc     hl\n",
        "\tld      (rt_data_ptr),hl\n",
        "\tpop     hl\n",
        "\tret\n",
    ],["rt_datablock"]),
    "rt_read_str": ([
        "; RT_READ_STR\n",
        "; Copies into the string pointed by HL the next STRING in DATA block\n",
        "; Inputs:\n",
        ";     HL address to the target string\n",
        "; Outputs:\n",
        ";     HL address to the string\n",
        ";     HL, DE and BC are modified\n",
        "rt_read_str:\n",
        "\tpush    hl\n",
        "\tld      de,(rt_data_ptr)\n",
        "\tex      de,hl\n",
        "\tld      b,0\n",
        "\tld      c,(hl)    ; string length\n",
        "\tinc     c\n",
        "\tldir\n",
        "\tld      (rt_data_ptr),hl\n",
        "\tpop     hl\n",
        "\tret\n",
    ],["rt_datablock"]),
    #
    # INPUT/OUTPUT
    # 
    "rt_print_nl": ([
        "; RT_PRINT_NL\n",
        "; Prints an EOL which in Amstrad is composed\n",
        "; by chraracters 0x0D 0x0A\n",
        "; Inputs:\n",
        ";     None \n",
        "; Outputs:\n",
        ";     None \n",
        ";     AF is modified\n",
        "rt_print_nl:\n",
        "\tld      a,13\n",
        f"\tcall    {FWCALL.TXT_OUTPUT}  ; TXT_OUTPUT\n",
        "\tld      a,10\n",
        f"\tjp      {FWCALL.TXT_OUTPUT}  ; TXT_OUTPUT\n",
    ],[]),
    "rt_print_spc": ([
        "; RT_PRINT_SPC\n",
        "; L indicates the number of spaces to print\n",
        "; but 127 is the maximum\n",
        ";Inputs:\n",
        ";     L number of spaces to print\n",
        ";Outputs:\n",
        ";     None\n",
        ";     AF and B are modified\n",
        "rt_print_spc:\n",
        "\tld      a,l\n",
        "\tand     &7F\n",
        "\tcp      0\n",
        "\tret     z\n",
        "\tld      b,a\n",
        "\tld      a,32   ; white space\n",
        "__print_spc_loop:"
        f"\tcall    {FWCALL.TXT_OUTPUT}\n",
        "\tdjnz    __print_spc_loop\n",
        "\tret\n",
    ],[]),
    "rt_print_str": ([
        "; RT_PRINT_STR\n",
        "; Prints in the screen the string pointed by HL\n",
        "; using the Amstrad CPC firmware routines\n",
        "; Inputs:\n",
        ";     HL address to the string to print\n",
        "; Outputs:\n",
        ";     C stores the total number of printed chars\n",
        ";     AF, HL and BC are modified\n",
        "rt_print_str:\n",
        "\tld      a,(hl)\n",
        "\tld      c,a        ; total number of printed chars\n",
        "\tor      a\n",
        "\tret     z          ; empty string\n",
        "\tld      b,a\n",
        "__print_str_loop:\n",
        "\tinc     hl\n",
        "\tld      a,(HL)\n",
        f"\tcall    {FWCALL.TXT_OUTPUT}\n",
        "\tdjnz    __print_str_loop\n",
        "\tret\n",
    ],[]),
    "rt_print_int": ([
        "; RT_PRINT_INT\n",
        "; Prints an Integer number which in Amstrad is composed\n",
        "; by chraracters two bytes.\n",
        "; Inputs:\n",
        ";     HL holds the number to be printed \n",
        "; Outputs:\n",
        ";     None \n",
        ";     HL, BC, DE and AF are modified\n",
        "rt_print_int:\n",
        "\tcall    rt_int2str\n",
        "\txor     a     ; leave the '-' space in positive numbers\n",
        "\tor      c\n",
        "\tjr      nz,$+7\n",
        "\tld      a,32\n",
        f"\tcall    {FWCALL.TXT_OUTPUT}  ; TXT_OUTPUT\n",
        "\tcall    rt_print_str\n",
        "\tld      a,32   ; trailing space\n",
        f"\tjp      {FWCALL.TXT_OUTPUT}  ; TXT_OUTPUT\n",
    ], ["rt_print_str", "rt_int2str"]),
    "rt_print_real": ([
        "; RT_PRINT_REAL\n",
        "; Prints a Real number which in Amstrad is a\n",
        "; five bytes floating-point representation.\n",
        "; Inputs:\n",
        ";     HL address to the real number \n",
        "; Outputs:\n",
        ";     None \n",
        ";     HL, BC, DE and AF are modified\n",
        "rt_print_real:\n",
        f"ld      ix,{FWCALL.MATH_REAL_TO_INT}  ; MATH_REAL_TO_INT\n",
        "call    rt_math_call\n",
        "jp      p,$+10\n",
        "ld      de,0\n",
        "xor     a\n",
        "ex      hl,de\n",
        "sbc     hl,de\n",
        "jp      rt_print_int\n",
    ], ["rt_math_call", "rt_int2str", "rt_print_int", "rt_print_str"]),
    "rt_count_substrz": ([
        "; RT_COUNT_SUBSTRZ\n",
        "; Returns the number of existing substrings separated\n",
        "; by commas in the null-terminated string addessed by HL.\n",
        "; Inputs:\n",
        ";     HL address to the string to scan\n",
        "; Outputs:\n",
        ";      B number of identified substrings\n",
        ";      C total number of quote characters found\n",
        ";     AF, HL and BC are modified\n", 
        "rt_count_substrz:\n",
        "\tld      bc,&0100    ; final number of substrings\n",
        "__count_loop:\n",
        "\tld      a,(hl)\n",
        "\tor      a\n",
        "\tret     z           ; null termination character\n",
        "\tinc     hl\n",
        "\tcp      &22         ; quote?\n",
        "\tjr      z,__count_quote\n",
        "\tcp      &2c         ; comma?\n",
        "\tjr      nz,__count_loop\n",
        "\tinc     b\n",
        "\tjr      __count_loop\n",
        "__count_quote:\n",
        "\tinc     c\n",
        "\tjr      __count_loop\n",
    ], []),
    "rt_extract_substrz": ([
        "; RT_EXTRACT_SUBSTRZ\n",
        "; Returns the number of existing substrings separated\n",
        "; by commas in the string addessed by HL.\n",
        "; Inputs:\n",
        ";     HL address to the string to scan\n",
        "; Outputs:\n",
        ";      B number of identified substrings\n",
        ";      C total number of quote characters found\n",
        ";     AF, HL and BC are modified\n", 
        "rt_substrz_buf:  defs  255     ; temporal memory to store substrings\n",
        "rt_extract_substrz:\n",
        "\tld      de,rt_substrz_buf\n",
        "\tld      c,0\n",
        "\tcall    rt_strz_lstrip   ; remove spaces leaves char in A\n",
        "\tcp      &22              ; quote?\n",
        "\tjr      nz,__extract_comma_separated\n",
        "\tcall    rt_remove_quotes\n",
        "\tinc     de\n",
        "\tinc     hl\n",
        "\txor     a\n",
        "\tld      (de),a\n",
        "\tcall    rt_strz_lstrip   ; remove spaces after final quote\n",
        "\tcp      &2c              ; comma\n",
        "\tret     nz\n",
        "\tinc     hl\n",
        "\tret\n", 
        "__extract_comma_separated:\n",
        "\tor      a                ; 0?\n",
        "\tjr      z,__extract_end\n",
        "\tinc     hl\n",
        "\tcp      &2c              ; ,?\n",
        "\tjr      z,__extract_end\n",
        "\tinc     c\n",
        "\tld      (de),a\n",
        "\tinc     de\n",
        "\tld      a,(hl)\n",
        "\tjr      __extract_comma_separated\n",
        "__extract_end:\n",
        "\txor     a\n",
        "\tld      (de),a\n",
        "\tld      a,c\n",
        "\tor      c\n",
        "\tret     z                ; empty string\n",
        "\tdec     de               ; last character\n",
        "\tex      de,hl\n",
        "\tcall    rt_strz_rstrip\n",
        "\tinc     hl\n",
        "\tld      (hl),0\n",
        "\tex      de,hl\n",
        "\tret\n",
    ], []),
    "rt_strz_lstrip": ([
        "; RT_STRZ_LSTRIP\n",
        "; Scans the zero-terminated string pointed by HL from the left\n",
        "; until if finds a character different from an empty space.\n",
        "; Inputs:\n",
        ";     HL address to the zero-terminated string to scan\n",
        "; Outputs:\n",
        ";     HL address to the resulting zero-terminated string\n",
        ";      A first character different to an empty space\n",
        ";     AF and HL are modified\n",
        "rt_strz_lstrip:\n",
        "\tld      a,(hl)\n",
        "\tcp      &20  ; espace\n",
        "\tret     nz\n",
        "\tinc     hl\n",
        "\tjr      rt_strz_lstrip\n",
    ], []),
    "rt_strz_rstrip": ([
        "; RT_STRZ_RSTRIP\n",
        "; Scans the zero-terminated string pointed by HL from the right\n",
        "; until if finds a character different from an empty space.\n",
        "; Inputs:\n",
        ";     HL address to the zero-terminated string to scan\n",
        "; Outputs:\n",
        ";     HL address to the resulting zero-terminated string\n",
        ";      A first character different to an empty space\n",
        ";     AF and HL are modified\n", 
        "rt_strz_rstrip:\n",
        "\tld      a,(hl)\n",
        "\tcp      &20  ; espace\n",
        "\tret     nz\n",
        "\tdec     hl\n",
        "\tdec     c\n",
        "\tjr      rt_strz_rstrip\n",
    ], []),
    "rt_remove_quotes": ([
        "; RT_REMOVE_QUOTES\n",
        "; Scans the zero-terminated string pointed by HL and\n",
        "; returs the substring between quotes. Assumes that first\n",
        "; character of HL string is already a quote.\n",
        "; Inputs:\n",
        ";     HL address to the zero-terminated string to scan\n",
        ";     DE address to the resulting string\n",
        "; Outputs:\n",
        ";     DE address to the resulting string\n",
        ";      C length of DE\n",
        ";     AF, DE, HL and C are modified\n", 
        "rt_remove_quotes:\n",
        "\tinc     hl\n",
        "\tld      c,0\n",
        "__remove_quotes_loop:\n",
        "\tld      a,(hl)\n",
        "\tcp      &22\n",
        "\tret     z\n",
        "\tld      (de),a\n",
        "\tinc     hl\n",
        "\tinc     de\n",
        "\tinc     c\n",
        "\tjr      __remove_quotes_loop\n",
    ], []),
    "rt_extract_num": ([
        "; RT_EXTRACT_NUM\n",
        "; Converts and string with an integer or hexadecimal number\n",
        "; Inputs:\n",
        ";     DE address to the null-terminated string with the number\n",
        "; Outputs:\n",
        ";     HL resulting number\n",
        ";     AF, HL, DE and BC are modified\n",
        "rt_extract_num:\n",
        "\tld      a,(de)\n",
        '\tcp      "&"\n',
        "\tjp      nz,rt_strz2int\n",
        "\tinc     de\n",
        "\tjp      rt_strz2hex\n",
    ], []),
    "rt_input": ([
        "; RT_INPUT\n",
        "; Camptures the keyboard input in a null-terminated string\n",
        "; using the Amstrad CPC firmware routines.\n",
        "; Returns in B and C some useful values to validate the input.\n",
        "; Inputs:\n",
        ";     None\n",
        "; Outputs:\n",
        ";     rt_input_buf stores the input as a null-terminated string\n",
        ";      B stores the total number substrings (separated by commas)\n",
        ";      C total number of quote characters found\n",
        ";     AF, HL and BC are modified\n",
        'rt_input_question: db 2,"? "\n',
        'rt_input_redo:     db 16,"?Redo from start "\n',
        'rt_input_buf:      defs 255\n',
        "rt_input:\n",
        f"\tcall    {FWCALL.TXT_CUR_ENABLE} ; TXT_CUR_ENABLE\n",
        f"\tcall    {FWCALL.TXT_CUR_ON} ; TXT_CUR_ON\n",
        "\tld      hl,rt_input_buf\n",
        "\tld      (hl),0\n",
        "\tld      bc,0  ; Initialize characters counter\n",
        "__input_enterchar:\n",
        f"\tcall    {FWCALL.KM_WAIT_KEY} ; KM_WAIT_KEY\n",
        "\tcp      &7F  ; KM_WAIT_KEY returns characters in range &00-&7F\n",
        "\tjr      nz,__input_processchar\n",
        "\tld      a,b  ; backspace key\n",
        "\tor      c\n",
        "\tjr      z,__input_enterchar    ; String length is zero\n",
        "\tld      a,8\n",
        f"\tcall    {FWCALL.TXT_OUTPUT} ; TXT_OUTPUT\n",
        '\tld      a," "\n',
        f"\tcall    {FWCALL.TXT_OUTPUT} ; TXT_OUTPUT\n",
        "\tld      a,8\n",
        f"\tcall    {FWCALL.TXT_OUTPUT} ; TXT_OUTPUT\n",
        "\tdec     hl\n",
        "\tdec     bc\n",
        "\tjr      __input_enterchar\n",
        "__input_processchar:\n",
        "\tcp      13\n",
        "\tjr      z,__input_end          ; Enter key pressed\n",
        f"\tcall    {FWCALL.TXT_OUTPUT} ; TXT_OUTPUT\n",
        "\tld      (hl),a\n",
        "\tinc     hl\n",
        "\tinc     bc\n",
        "\tjr      __input_enterchar\n",
        "__input_end:\n",
        "\tld      (hl),0\n",
        "\tcall    rt_print_nl\n",
        f"\tcall    {FWCALL.TXT_CUR_DISABLE} ; TXT_CUR_DISABLE\n",
        f"\tcall    {FWCALL.TXT_CUR_OFF} ; TXT_CUR_OFF\n",
        "\tld      hl,rt_input_buf\n",
        "\tjp      rt_count_substrz\n",      
    ],["rt_print_nl", "rt_print_str", "rt_count_substrz", "rt_extract_substrz", "rt_strz_lstrip", "rt_strz_rstrip", "rt_remove_quotes"]),
    "rt_writestr": ([
        "; RT_WRITESTR\n",
        "; Writes a quoted string to an already open file (with OPENIN)\n",
        "; Inputs:\n",
        ";     HL address to the input string\n",
        "; Outputs:\n",
        ";     A, B and HL are modified\n",
        "rt_writestr:\n",
        "\tld      a,&22\n",
        f"\tcall    {FWCALL.CAS_OUT_CHAR}  ; CAS_OUT_CHAR\n",
        "\tld      b,(hl)\n",
        "__writestr_loop:\n",
        "\tinc     hl\n",
        "\tld      a,(hl)\n",
        f"\tcall    {FWCALL.CAS_OUT_CHAR}  ; CAS_OUT_CHAR\n",
        "\tdjnz    __writestr_loop\n",
        "\tld      a,&22\n",
        f"\tjp      {FWCALL.CAS_OUT_CHAR}  ; CAS_OUT_CHAR\n",
    ], []),
    "rt_writeint": ([
        "; RT_WRITEINT\n",
        "; Writes the integer hold in HL to an already open file (with OPENIN)\n",
        "; Inputs:\n",
        ";     HL signed integer value\n",
        "; Outputs:\n",
        ";     A, B and HL are modified\n",
        "rt_writeint:\n",
        "\tcall    rt_int2str\n",
        "\tld      b,(hl)\n",
        "__writeint_loop:\n",
        "\tinc     hl\n",
        "\tld      a,(hl)\n",
        f"\tcall    {FWCALL.CAS_OUT_CHAR}  ; CAS_OUT_CHAR\n",
        "\tdjnz    __writestr_loop\n",
        "\tret     \n",
    ], ["rt_int2str"]),
    "rt_writenl": ([
        "; RT_WRITENL\n",
        "; Writes an EOL to an already open file (with OPENIN)\n",
        "; Inputs:\n",
        ";     None\n",
        "; Outputs:\n",
        ";     AF is modified\n",
        "rt_writenl:\n",
        "\tld      a,13\n",
        f"\tcall    {FWCALL.CAS_OUT_CHAR}  ; CAS_OUT_CHAR\n",
        "\tld      a,10\n",
        f"\tjp      {FWCALL.CAS_OUT_CHAR}  ; CAS_OUT_CHAR\n",
    ], ["rt_int2str"]),
    "rt_readstr": ([
        "; RT_READSTR\n",
        "; Reads a quoted string from an already open file (with OPENIN).\n",
        "; Ends trying to read the comma that separates data in the file.\n"
        "; Inputs:\n",
        ";     HL address to the destination string\n",
        "; Outputs:\n",
        ";     HL contains the address to the destination string\n",
        ";     A, B and HL are modified\n",
        "rt_readstr:\n",
        "\tld      (hl),0\n",
        f"\tcall    {FWCALL.CAS_IN_CHAR}  ; CAS_IN_CHAR\n",
        "\tcp      &22\n",
        "\tret     nz\n",
        "\tld      b,0\n",
        "\tpush    hl\n",
        "__readstr_loop:\n",
        "\tinc     hl\n",
        f"\tcall    {FWCALL.CAS_IN_CHAR}  ; CAS_IN_CHAR\n",
        "\tjr      nc,__readstr_end  ; if error jump to end\n",
        "\tcp      &22\n",
        "\tjr      z,__readstr_end\n",
        "\tld      (hl),a\n",
        "\tinc     b\n",
        "\tjr      __readstr_loop\n",
        "__readstr_end:\n",
        "\tpop     hl\n",
        "\tld      (hl),b\n",
        "\tjp      rt_readnext   ; consume comma or new-line\n",
    ], ["rt_readnext"]),
    "rt_readint": ([
        "; RT_READINT\n",
        "; Reads an integer from an already open file (with OPENIN).\n",
        "; It consumes any comma used to separate values.\n",
        "; Inputs:\n",
        ";     None\n",
        "; Outputs:\n",
        ";     HL contains the integer value\n",
        ";     A, B and HL are modified\n",
        "rt_readint_bufz: defs 19     ; space for 16 bits integers (including hex and bin formats)\n",
        "rt_readint:\n",
        "\tld      hl,0\n",
        "\tld      b,18    ; max buffer length for numbers\n",
        "\tld      de,rt_readint_bufz\n",
        "__readint_loop:\n",
        f"\tcall    {FWCALL.CAS_IN_CHAR}  ; CAS_IN_CHAR\n",
        "\tjr      nc,__readint_end  ; if error jump to end\n",
        "\tcp      &2c\n",
        "\tjr      z,__readint_end\n",
        "\tcp      &0d\n",
        "\tjr      z,__readint_end\n",
        "\tcp      &0a\n",
        "\tjr      z,__readint_end\n",
        "\tld      (de),a\n",
        "\tdjnz    __readint_loop\n",
        "__readint_end:\n",
        "\tinc     de\n",
        "\txor     a\n",
        "\tld      (de),a   ; zero-terminated string\n",
        "\tld      de,rt_readint_bufz\n",
        "\tcall    rt_strz2num\n",
        "\tjp      rt_readnext\n",
    ], ["rt_strz2num", "rt_readnext"]),
    "rt_readnext": ([
        "; RT_READNEXT\n",
        "; Consume chars until it consumes a comma or a new-line\n",
        "; Inputs:\n",
        ";     None\n",
        "; Outputs:\n",
        ";     None\n",
        ";     AF is modified\n",
        "rt_readnext:\n",
        "__readnext_loop:\n",
        f"\tcall    {FWCALL.CAS_IN_CHAR}  ; CAS_IN_CHAR\n",
        "\tret     nc    ; error reading\n",
        "\tcp      &2c   ; comma?\n",
        "\tret     z\n",
        "\tcp      &0a   ; end of new-line?\n",
        "\tret     z\n",
        "\tcp      &0d   ; new-line (0xd,0xa)?\n",
        "\tjr      nz,__readnext_loop\n",
        f"\tjp      {FWCALL.CAS_IN_CHAR}  ; CAS_IN_CHAR\n",
    ], []),
    #
    # MATH
    # 
    "rt_umul16": ([
        "; RT_UMULT16"
        "; 16x16 unsigned multplication\n",
        "; HL = HL * DE.\n",
        "; Algorithm from Rodney Zaks, 'Programming the Z80'.\n",
        "; Developed by Nils M. Holm (cc0)\n",
        "; Inputs:\n",
        ";     HL and DE\n",
        "; Outputs:\n",
        ";     HL is the HL * DE\n",
        ";     AF, BC and DE are modified\n",
        "rt_umul16:\n",
        "\tld      a,l	    ; transfer HL to CA\n",
        "\tld      c,h\n",
        "\tld      b,16	    ; 16 bits to multiply\n",
        "\tld      hl,0\n",
        "__mul0_unsigned:\n",
        "\tsrl     c		; shift CA right, get low bit\n",
        "\trra\n",
        "\tjr      nc,__mul1_unsigned	; zero fell out, do not add\n",
        "\tadd     hl,de	; else add DE\n",
        "__mul1_unsigned:\n",
        "\tex      de,hl	; DE = DE*2\n",
        "\tadd     hl,hl\n",
        "\tex      de,hl\n",
        "\tdjnz    __mul0_unsigned\n",
        "\tret\n",
    ],[]),
    "rt_udiv16": ([
        "; RT_UDIV16\n",
        "; 16/16 unsigned division\n",
        "; HL = HL DIV DE\n",
        "; DE = HL MOD DE\n",
        "; Algorithm from Rodney Zaks, 'Programming the Z80'.\n",
        "; Developed by Nils M. Holm (cc0)\n",
        "; Inputs:\n",
        ";     HL, DE\n",
        "; Outputs:\n",
        ";     HL is the quotient\n",
        ";     DE is the remainder\n",
        ";     AF, BC are modified\n",
        "rt_udiv16:\n",
        "\tld      b,h	    ; store HL in BC\n",
	    "\tld      c,l\n",
        "\tld      a,e	    ; transfer DE to AC\n",
	    "\tor      d\n",
	    "\tld      hl,0	    ; intermediate result\n",
	    "\tret     z		; DIV by 0?\n",      
        "\tld      a,b\n",
        "\tld      b,16	    ; 16 bits to divide\n",
        "__div0_unsigned:\n",
        "\trl      c		; get AC high bit, rotate in result bit\n",
        "\trla\n",
        "\tadc     hl,hl	; HL = HL*2, never sets C\n",
        "\tsbc     hl,de	; trial subtract and test DE > HL\n",
        "\tjr      nc,__div1_unsigned\n",
        "\tadd     hl,de	; DE > HL, restore HL\n",
        "__div1_unsigned:\n",
        "\tccf		        ; result bit\n",
        "\tdjnz    __div0_unsigned\n",
        "\tex      de,hl\n",
        "\trl      c		; rotate in last result bit\n",
        "\trla\n",
        "\tld      h,a\n",
        "\tld      l,c\n",
	    "\tret\n",
    ],[]),
    "rt_compute_sign": ([
        "; RT_COMPUTE_SIGN\n",
        "; Computes resulting sign between HL and DE integers\n",
        "; returns C=0 (pos) if signs are equal and otherwise C=1 (neg)\n",
        "; Developed by Nils M. Holm (cc0)\n",
        "; Inputs:\n",
        ";     HL, DE\n",
        "; Outputs:\n",
        ";     CF carry stores the sign\n",
        ";     AF is modified\n",
        "rt_compute_sign:\n",
        "\tld      a,h\n",
        "\txor     d\n",
        "\trla		; sign to carry\n",
        "\tret\n",
    ],[]),
    "rt_abs": ([   
        "; RT_ABS\n", 
        "; Strips sign from HL\n",
        "; performing COMP+2 if it is negative\n",
        "; Inputs:\n",
        ";     HL\n",
        "; Outputs:\n",
        ";     HL is the number in possitive\n",
        ";     AF is modified\n",
        "rt_abs:\n",
        "\tbit     7,h\n",
        "\tret     z\n",
        "\tld      a,h\n",
        "\tcpl\n",
        "\tld      h,a\n",
        "\tld      a,l\n",
        "\tcpl\n",
        "\tld      l,a\n",
        "\tinc     hl\n",
        "\tret\n",
    ],[]),
    "rt_sign_strip": ([   
        "; RT_SIGN_STRIP\n", 
        "; Strips signs from HL and DE\n",
        "; performing COMP+2 if they are negative\n",
        "; Developed by Nils M. Holm (cc0)\n",
        "; Inputs:\n",
        ";     HL and DE\n",
        "; Outputs:\n",
        ";     HL is the number in possitive\n",
        ";     DE is the number in possitive\n",
        ";     AF is modified\n",
        "rt_sign_strip:\n",
        "\tbit     7,d\n",
        "\tjr      z,__sign_strip_posde\n",
        "\tld      a,d\n",
        "\tcpl\n",
        "\tld      d,a\n",
        "\tld      a,e\n",
        "\tcpl\n",
        "\tld      e,a\n",
        "\tinc     de\n",
        "__sign_strip_posde:\n",
        "\tbit     7,h\n",
        "\tret     z\n",
        "__sign_strip_neghl:\n",
        "\tld      a,h\n",
        "\tcpl\n",
        "\tld      h,a\n",
        "\tld      a,l\n",
        "\tcpl\n",
        "\tld      l,a\n",
        "\tinc     hl\n",
        "\tret\n",
    ],[]),
    "rt_mul16": ([
        "; RT_MUL16\n",
        "; 15x15 signed multiplication\n",
        "; HL = HL * DE\n",
        "; Developed by Nils M. Holm (cc0)\n",
        "; Inputs:\n",
        ";     HL and DE\n",
        "; Outputs:\n",
        ";     HL is the HL * DE\n",
        ";     AF, BC, DE are modified\n",
        "rt_mul16:\n",	
        "\tcall    rt_compute_sign\n",
        "\tpush    af\n",
        "\tcall    rt_sign_strip\n",
        "\tcall    rt_umul16\n",
        "\tpop     af\n",
        "\tret     nc\n",
        "\tjr      __sign_strip_neghl\n",
    ],["rt_compute_sign", "rt_sign_strip", "rt_umul16"]),
    "rt_div16": ([
        "; RT_DIV16\n",
        "; 15/15 signed division\n",
        "; HL = HL DIV DE\n",
        "; DE = HL MOD DE\n",
        "; Developed by Nils M. Holm (cc0)\n",
        "; Inputs:\n",
        ";     HL, DE\n",
        "; Outputs:\n",
        ";     HL is the quotient\n",
        ";     DE is the remainder\n",
        ";     AF, BC are changed\n",
        "rt_div16:\n",
        "\tcall    rt_compute_sign\n",
        "\tpush    af\n",
        "\tcall    rt_sign_strip\n",
        "\tcall    rt_udiv16\n",
        "\tpop     af\n",
        "\tret     nc\n",
        "\tjr      __sign_strip_neghl\n",
    ],["rt_compute_sign", "rt_sign_strip", "rt_udiv16"]),
    "rt_comp16": ([
        "; RT_COMP16\n",
        "; Signed comparison HL-DE, set Z and C flags,\n",
        "; where C indicates that HL < DE\n",
        "; Inputs:\n",
        ";     HL, DE\n",
        "; Outputs:\n",
        ";     AF Z=1 if HL=DE; Z=0 & C=1 if HL < DE\n"
        ";     HL is modified\n",
        ";     BC, DE are preserved\n",
        "rt_comp16:\n",
        "\txor     a\n",
        "\tsbc     hl,de\n",
        "\tret     z\n",
        "\tjp      m,__comp16_cs1\n",
        "\tor      a\n",
        "\tret\n",
        "__comp16_cs1:\n",
        "\tscf\n",
        "\tret\n",
    ],[]),
    "rt_ucomp16": ([
        "; RT_UCOMP16\n",
        "; Unsigned comparison HL-DE, set ZF and CF flags,\n",
        "; where CF indicates that HL < DE\n",
        "; Inputs:\n",
        ";     HL, DE\n",
        "; Outputs:\n",
        ";     AF ZF=1 if HL=DE; ZF=0 & CF=1 if HL < DE\n"
        ";     HL is modified\n",
        ";     BC, DE are preserved\n",
        "rt_cuomp16:\n",
        "\txor     a          ; Clear C flag\n",
        "\tsbc     hl,de\n",
        "\tret\n",
    ],[]),
    "rt_div16_by10": ([
        "; RT_DIV16_BY10\n",
        "; Fast integer division by 10\n",
        "; Taken from:\n",
        "; https://learn.cemetech.net/index.php/Z80:Math_Routines&Speed_Optimised_HL_div_10\n",
        "; HL = HL DIV 10\n",
        "; Inputs:\n",
        ";     HL\n",
        "; Outputs:\n",
        ";     HL is the quotient\n",
        ";     A is the remainder\n",
        ";     HL, BC, AF are modified, DE is preserved\n",
        "rt_div16_by10:\n",
        "\tld      bc,&0D0A\n",
        "\txor     a\n",
        "\tadd     hl,hl\n",
        "\trla\n",
        "\tadd     hl,hl\n",
        "\trla\n",
        "\tadd     hl,hl\n",
        "\trla\n",
        "\tadd     hl,hl\n",
        "\trla\n",
        "\tcp      c\n",
        "\tjr      c,$+4\n",
        "\tsub     c\n",
        "\tinc     l\n",
        "\tdjnz    $-7\n",
        "\tret\n",
    ],[]),
    "rt_udiv8": ([
        "; RT_UDIV8\n",
        "; 8/8 unsigned integer division,\n",
        ";Inputs:\n",
        ";     A  numerator, E denominator\n",
        ";Outputs:\n",
        ";     D  quotient\n",
        ";     A  remainder\n"
        ";     BC, DE are preserved\n",
        "rt_udiv8:\n",
        "\tld d,0           ; Initialize quotient\n",
        "__div8_loop:\n",
        "\tcp e             ; Compare A with E\n",
        "\tjr c,__div8_end  ; If A < E, we're done\n",
        "\tsub e            ; Subtract E from A\n",
        "\tinc d            ; Increment quotient\n",
        "\tjr __div8_loop   ; Continue dividing\n",
        "__div8_end:\n",
        "\tret\n",
    ],[]),
    "rt_mul16_255": ([
        "; RT_MUL16_255\n",
        "; Multiplies HL by 255 and leaves the result in HL\n",
        "; HL * 255 = HL * (256 - 1) = (HL << 8) - HL\n",
        ";Inputs:\n",
        ";     HL  number to be multiplied\n",
        ";Outputs:\n",
        ";     HL  result of HL * 255\n",
        ";     AF, DE and HL are modified\n",
        "rt_mul16_255:\n",
        "\tld      d,h      ; keep HL so we can sub later\n",
        "\tld      e,l\n",
        "\tld      a,h\n",
        "\tld      h,l      ; HL << 8\n",
        "\tld      l,0\n",
        "\tor      a        ; clear CF\n",
        "\tsbc     hl,de    ; HL = (HL << 8) - DE\n",
        "\tret\n",
    ],[]),
    "rt_mul16_A": ([
        "; RT_MUL16_A\n",
        "; Multiplies HL by A and leaves the result in HL\n",
        "; Routine taken from:\n",
        "; https://learn.cemetech.net/index.php/Z80:Math_Routines\n",
        ";Inputs:\n",
        ";     HL  number to be multiplied\n",
        ";      A  number to by multiplied by\n",
        ";Outputs:\n",
        ";     HL  result of HL * A\n",
        ";     AF, DE and HL are modified\n",
        "rt_mul16_A:\n",
        "\tld      b,8\n",
        "\tld      hl,0\n",
        "__mult16_a_loop:\n",
        "\tadd     hl,hl\n",
        "\trlca\n",
        "\tjr      nc,$+3\n",
        "\tadd     hl,de\n",
        "\tdjnz    __mult16_a_loop\n",
        "\tret\n",
    ],[]),
    #
    # runtime for BASIC commands support
    #
    "rt_timer": ([
        "; RT_TIMER_GET\n",
        "; Retrieves a AFTER/EVERY data block (tick block). Each tick block has\n",
        "; a size of 13 bytes. The las 7 bytes are the event block contained\n",
        "; inside the tick block\n",
        ";Inputs:\n",
        ";     A  timer number (0-3)\n",
        ";Outputs:\n",
        ";     HL address to the timer block\n",
        "rt_timer_blocks: defs 13*4 ; 4 tick blocks\n",
        "rt_timer_get:\n",
        "\tld      hl,rt_timer_blocks\n",
        "\tld      de,13       ; Block size\n",
        "__timerget_loop:\n",
        "\tor      a\n",
        "\tret     z\n",
        "\tadd     hl,de\n",
        "\tdec     a\n",
        "\tjr      __timerget_loop\n",
    ],[]),
    "rt_fill": ([
        "; RT_FILL\n",
        "; Wrapper for the GRA FILL firmware call in the 664 and 6128\n",
        ";Inputs:\n",
        ";      L  INK index\n",
        ";Outputs:\n",
        ";     None\n",
        ";     AF, BC, DE and HL are modified\n",
        "rt_timer_blocks: defs 13*4 ; 4 tick blocks\n",
        "rt_fill_buffer: defs 70\n",
        "rt_fill:\n",
        "\tld      a,l\n",
        "\tld      hl,rt_fill_buffer\n",
        "\tld      de,70\n",
        f"\tjp      {FWCALL.GRA_FILL}  ; GRA_FILL\n",
    ],[]),
    "rt_inkey": ([
        "; RT_INKEY\n",
        "; Wrapper for the KEY TEST firmware call\n",
        ";Inputs:\n",
        ";      HL  Key numeric value to test\n",
        ";Outputs:\n",
        ";     HL  -1 no pressed, 0, 32, 128 and 160 as per INKEY doc\n",
        ";     AF, C, and HL are modified\n",
        "rt_inkey:\n",
        "\tld      a,l\n",
        f"\tcall    {FWCALL.KM_TEST_KEY}  ; KM_TEST_KEY\n",
        "\tld      hl,&FFFF  ; -1 (the key is not pressed)\n",
        "\tjr      z,$+4\n",
        "\tinc     h\n",
        "\tld      l,c\n",
        "\tret\n",
    ],[]),
    "rt_gettime": ([
        "; RT_GETTIME\n",
        "; Wrapper for the KL TIME PLEASE firmware call\n",
        "; It captures the bin number and casts it to real\n",
        "; Leaving the result in rt_math_accum1\n",
        ";Inputs:\n",
        ";     None\n",
        ";Outputs:\n",
        ";     HL points to rt_math_accum1\n",
        ";     AF, HL, BC, DE and IX are modified\n",
        "rt_gettime:\n",
        f"\tcall     {FWCALL.KL_TIME_PLEASE}  ; KL_TIME_PLEASE\n",
        "\tld      ix,rt_math_accum1\n",
        "\tld      (ix+0),l\n",
        "\tld      (ix+1),h\n",
        "\tld      (ix+2),e\n",
        "\tld      (ix+3),d\n",
        "\txor     a\n",
        "\tld      hl,rt_math_accum1\n"
        f"\tld      ix,{FWCALL.MATH_BIN_TO_REAL}  ; MATH_BIN_TO_REAL\n",
        "\tjp      rt_math_call\n",
    ],["rt_math_call"]),
    "rt_randomize": ([
    "; RT_RANDOMIZE\n",
    "; Sets rt_rnd_seed1 and rt_rnd_seed2 which are used by rt_rnd\n",
    ";Inputs:\n",
    ";   HL address to a buffer with at least 4 bytes\n",
    ";Outputs:\n",
    ";   rt_rnd_seed1 gets the value of HL\n",
    ";   rt_rnd_seed2 gets the value of DE\n",
    ";   HL is modified\n",
    "rt_rnd_seed1: db &6c,&07       ; some initial value just in case\n",
    "rt_rnd_seed2: db &70,&c6\n",
    "rt_old_seed1: db &6c,&07       ; to retrieve again last number\n",
    "rt_old_seed2: db &07,&6c\n",
    "rt_randomize:\n",
    "\tld      a,(hl)\n",
    "\tld      (rt_rnd_seed1),a\n",
    "\tinc     hl\n",
    "\tld      a,(hl)\n",
    "\tld      (rt_rnd_seed1+1),a\n",
    "\tinc     hl\n",
    "\tld      a,(hl)\n",
    "\tld      (rt_rnd_seed2),a\n",
    "\tinc     hl\n",
    "\tld      a,(hl)\n",
    "\tld      (rt_rnd_seed2+1),a\n",
    "\tret\n",
    ], []),
    "rt_rnd": ([
    "; RT_RND\n",
    "; This is a very fast, quality pseudo-random number generator.\n",
    "; It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG.\n",
    "; Taken from:\n",
    "; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random\n",
    ";Inputs:\n",
    ";   (rt_rnd_seed1) contains a 16-bit seed value\n",
    ";   (rt_rnd_seed2) contains a NON-ZERO 16-bit seed value\n",
    ";Outputs:\n",
    ";   HL address to the REAL result\n",
    ";   BC is the result of the LCG, so not that great of quality\n",
    ";   AF is modified, DE is preserved\n",
    "rt_rnd_32767: db &00,&00,&FE,&7F,&8F\n",
    "rt_rnd:\n",
    "\tld      hl,(rt_rnd_seed1)\n",
    "\tld      (rt_old_seed1),hl\n",
    "\tld      b,h\n",
    "\tld      c,l\n",
    "\tadd     hl,hl\n",
    "\tadd     hl,hl\n",
    "\tinc     l\n",
    "\tadd     hl,bc\n",
    "\tld      (rt_rnd_seed1),hl\n",
    "\tld      hl,(rt_rnd_seed2)\n",
    "\tld      (rt_old_seed2),hl\n",
    "\tadd     hl,hl\n",
    "\tsbc     a,a\n",
    "\tand     %00101101\n",
    "\txor     l\n",
    "\tld      l,a\n",
    "\tld      (rt_rnd_seed2),hl\n",
    "\tadd     hl,bc\n",
    "\tres     7,h\n",
    "\tld      de,rt_math_accum1  ; lests convert the number to REAL\n",
    "\txor     a                  ; always positive\n",
    f"\tld      ix,{FWCALL.MATH_INT_TO_REAL}           ; MATH_INT_TO_REAL\n",
    "\tcall    rt_math_call\n",
    "\tld      de,rt_rnd_32767    ; max number that can be generated\n",
    f"\tld      ix,{FWCALL.MATH_REAL_DIV}           ; MATH_REAL_DIV\n",
    "\tjp      rt_math_call\n\n",
     "; RT_RND0\n",
    "; Depending on the value of HL it returns the last generated number.\n",
    "; a new one in the sequence\n",
    ";Inputs:\n",
    ";   HL 0 to get the latest generated number\n",
    ";Outputs:\n",
    ";   HL is the address to the REAL result\n",
    ";   BC is the result of the LCG, so not that great of quality\n",
    ";   AF is modified, DE is preserved\n",
    "rt_rnd0:\n",
    "\tld      a,l\n",
    "\tor      a\n",
    "\tjr      nz,rt_rnd\n",
    "\tld      hl,rt_old_seed1\n",
    "\tcall    rt_randomize\n"
    "\tjr      rt_rnd\n",
    ], ["rt_randomize"]),
    "rt_fileinbuf": ([
        "; Buffer for content read from files through OPENIN\n",
        "rt_fileinbuf: defs 2048\n",
    ], ["rt_error"]),
    "rt_fileoutbuf": ([
        "; Buffer for content written to files through OPENOUT\n",
        "rt_fileoutbuf: defs 2048\n",
    ], ["rt_error"]),
    "rt_sound": ([
        "; Adds a new sound to one of the available Amstrad CPC\n",
        "; sound queues. The data must be kept in a buffer placed\n",
        "; somewhere in the 32k central memory area.\n",
        ";Inputs:\n",
        ";   HL address to the sound buffer with the data.\n",
        ";Outputs:\n",
        ";   CF if sound was added to the queue.\n",
        ";   AF, BC, DE, IX and HL are modified.\n",
        "rt_sound_buf: defs 9\n",
        "rt_sound:\n",
        "\tld      hl,rt_sound_buf\n",
        f"\tjp      {FWCALL.SOUND_QUEUE} ; SOUND_QUEUE\n",
    ], ["rt_error"]),
    "rt_load": ([
        "; RT_LOAD\n",
        "; Reads an AMSDOS file (with header) and extracts length and\n",
        "; target address, loading there the content.\n",
        ";Inputs:\n",
        ";   HL address to the file name\n",
        ";Outputs:\n",
        ";   None\n",
        ";   AF, HL, BC, DE and IX are modified\n",
        "rt_load:\n",
        "\tld      de,0   ; 2K buffer not needed with disks\n",
        "\tdi\n",
        "\tld      b,(hl) ; filename length\n",
        "\tinc     hl\n",
        f"\tcall    {FWCALL.CAS_IN_OPEN}  ; CAS_IN_OPEN\n",
        "\tret     nc     ; Error\n",
        "\tex      de,hl\n",
        f"\tcall    {FWCALL.CAS_IN_DIRECT}  ; CAS_IN_DIRECT\n",
        "\tei\n"
        f"\tjp      {FWCALL.CAS_IN_CLOSE}  ; CAS_IN_CLOSE\n",
    ], []),
    "rt_loadaddr": ([
        "; RT_LOADADDR\n",
        "; Reads an AMSDOS file (with header) and extracts its length.\n",
        "; The content is loaded into the address stored in DE.\n",
        ";Inputs:\n",
        ";   HL address to the file name\n",
        ";   DE address where content must be loaded\n",
        ";Outputs:\n",
        ";   CF if no error\n",
        ";   AF, HL, BC, DE and IX are modified\n",
        "rt_loadaddr:\n",
        "\tpush    de\n",
        "\tdi\n",
        "\tld      de,0   ; 2K buffer not needed with CAS_IN_DIRECT\n",
        "\tld      b,(hl) ; filename length\n",
        "\tinc     hl\n",
        f"\tcall    {FWCALL.CAS_IN_OPEN}  ; CAS_IN_OPEN\n",
        "\tret     nc     ; Error\n",
        "\tpop     hl\n",
        f"\tcall    {FWCALL.CAS_IN_DIRECT}  ; CAS_IN_DIRECT\n",
        "\tei\n",
        f"\tjp      {FWCALL.CAS_IN_CLOSE}  ; CAS_IN_CLOSE\n",
    ], []),
    "rt_save": ([
        "; RT_SAVE\n",
        "; Dumps a memory region as an AMSDOS binary file (with header)\n",
        ";Inputs:\n",
        ";   HL address to the file name\n",
        ";   IX address to the first param in memory\n",
        ";      IX + 0: Memory address\n",
        ";      IX + 2: Entry point\n",
        ";      IX + 4: Memory block length\n",
        ";Outputs:\n",
        ";   CF  if no error\n",
        ";   AF, HL, BC, DE and IX are modified\n",
        "rt_save:\n",
        "\tld      de,0   ; 2K buffer not needed with CAS_OUT_DIRECT\n",
        "\tdi\n",
        "\tld      b,(hl) ; filename length\n",
        "\tinc     hl\n",
        f"\tcall    {FWCALL.CAS_OUT_OPEN}  ; CAS_OUT_OPEN\n",
        "\tret     nc     ; Error\n",
        "\tld       l,(ix+0)\n",
        "\tld       h,(ix+1)\n",
        "\tld       c,(ix+2)\n",
        "\tld       b,(ix+3)\n",
        "\tld       e,(ix+4)\n",
        "\tld       d,(ix+5)\n",
        "\tld       a,2\n",
        f"\tcall    {FWCALL.CAS_OUT_DIRECT}  ; CAS_OUT_DIRECT\n",
        "\tei\n"
        f"\tjp      {FWCALL.CAS_OUT_CLOSE}  ; CAS_OUT_CLOSE\n",
    ], []),
}
