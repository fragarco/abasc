"""
Translates intermediate code generated by the parser
to Amstrad CPC Z80 Assembly language in Maxam/WinAPE style.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation in its version 3.

This program is distributed in the hope that it will be useful
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

Functions and Commands comments are taken from:
https://www.grimware.org/doku.php/documentations/software/locomotive.basic/start
and are not covered by the above license statement.
"""

from __future__ import annotations
from baspp import CodeLine
from baserror import BasError
from symbols import SymTable, SymEntry, SymType, symsto_json
import astlib as AST
from cpcrt import FWCALL, RT

class CPCEmitter:
    def __init__(self, code: list[CodeLine], program: AST.Program, symtable: SymTable, warning_level=-1, verbose=False):
        self.source = code
        self.program = program
        self.symtable = symtable
        self.warning_level = warning_level
        self.verbose=verbose
        self.data= ""
        self.code= ""
        self.rtcode: list[str] = []
        self.runtime: list[str] = []
        self.constants: int = 0
        self.free_tmp_memory: bool = False
        self.reserved_tmp_memory: int = 0
        self.org = 0x4000
        self.forloops: list[AST.ForLoop] = []
        self.wloops: list[AST.WhileLoop] = []
        self.ifblocks: list[AST.If] = []
        self.symbolafter = 9999

    def _emit_code(self, line: str="", indent: int=4, info: str=""):
        pad = ""
        for _ in range(indent): pad = pad + " "
        line = f"{pad}{line}"
        if info != "":
            line = f"{line:<30}; {info}"
        self.code = self.code + line + "\n"

    def _emit_data(self, line: str="", indent: int=4):
        pad = ""
        for _ in range(indent): pad = pad + " "
        self.data = self.data + f"{pad}{line}\n"

    def _emit_line_label(self, line: AST.Line):
        sym = self.symtable.find(str(line.number), "")
        if sym is not None:
            codeline = self.source[line.line-1]
            self._emit_code(f"{sym.label}:", info=codeline.code)
        else:
            self._raise_error(2, line)

    def _emit_import(self, fname: str) -> bool:
        if fname not in self.runtime:
            self.runtime.append(fname)
            fcode, depends = RT[fname]
            for dep in depends:
                self._emit_import(dep)
            self.rtcode = self.rtcode + fcode
            self.rtcode.append('\n')
            return True
        return False

    def _emit_free_mem(self) -> None:
        if self.free_tmp_memory:
            self._emit_code(f"; Free all used temporal memory ({self.reserved_tmp_memory} bytes)")
            self._emit_code("ld      de,_memory_start")
            self._emit_code("ld      (_memory_next),de")
            self._emit_code(";")
            self.free_tmp_memory = False
            self.reserved_tmp_memory = 0

    def _reserve_memory(self, nbytes: int):
        self._emit_import("rt_malloc")
        self._emit_code(f"; Malloc of {nbytes} bytes")
        self._emit_code(f"ld      bc,{nbytes}", info="bytes to reserve")
        self._emit_code("call    rt_malloc", info="HL points to empty mem")
        self._emit_code(";")
        self.free_tmp_memory = True
        self.reserved_tmp_memory += nbytes

    def _emit_head(self):
        self._emit_code("; FILE GENERATED BY BASC COMPILER", 0)
        self._emit_code("; DESIGNED TO BE ASSEMBLED BY ABASM", 0)
        self._emit_code(";", 0)
        self._emit_code()
        self._emit_code("org     0x170", 0)
        self._emit_code("jp      _code_", 0)
        self._emit_code()
        self._emit_code("; DYNAMIC MEMORY AREA, USED TO STORE TEMPORAL VALUES",0)
        self._emit_code("_dynamic_memory_area_:", 0)
        self._emit_code("_memory_next: dw _memory_start")
        self._emit_code("_memory_start:")
        self._emit_code()
        self._emit_code("; PROGRAM MAIN", 0)
        self._emit_code(f"org     {hex(self.org)}", 0)
        self._emit_code()
        self._emit_code("_code_:", 0)
        self._emit_data("_data_:", 0)

    def _emit_code_end(self):
        self._emit_code()
        self._emit_code("_end_: jr _end_", info="infinite end loop", indent=0)

    def _emit_global_symbols(self):
        for sym in self.symtable.syms:
            entry = self.symtable.syms[sym]
            if entry.symtype == SymType.Variable:
                self._emit_vardecl(entry)
            elif entry.symtype == SymType.Array:
                self._emit_arraydecl(entry)
            elif entry.symtype == SymType.RSX:
                # last char must have bit 7 set
                lastchar = ord(sym[-1]) + 128
                self._emit_data(f'{entry.label}: db "{sym[0:-1]}",{lastchar}')

    def _emit_vardecl(self, entry: SymEntry):
        if entry.exptype == AST.ExpType.Integer:
            self._emit_data(f"{entry.label}: dw   0")
        elif entry.exptype == AST.ExpType.String:
            self._emit_data(f"{entry.label}: defs 255")
        elif entry.exptype == AST.ExpType.Real:
            self._emit_data(f"{entry.label}: defs 5")

    def _emit_arraydecl(self, entry: SymEntry):
        items = 1
        for index in entry.indexes: items = items * index
        if entry.exptype == AST.ExpType.Integer:
            self._emit_data(f"{entry.label}: dw   {2*items}")
        elif entry.exptype == AST.ExpType.String:
            self._emit_data(f"{entry.label}: defs {255*items}")
        elif entry.exptype == AST.ExpType.Real:
            self._emit_data(f"{entry.label}: defs {5*items}")
    
    def _emit_runtime(self) -> str:
        return "_runtime_:\n\n" + ''.join(self.rtcode) + '\n'
    
    def _emit_symbol_table(self) -> None:
        # 240 is the BASIC default if no SYMBOL AFTER is used
        if self.symbolafter == 9999:
            self.symbolafter = 240
        self._emit_data()
        self._emit_data("; Table for symbols defined with SYMBOL keyword")
        self._emit_data(f"_symbols_table: defs {(256 - self.symbolafter)*8}")

    def _real(self, n: float) -> bytearray:
        """
        In Amstrad BASIC, a floating point number is stored in base-2 in a normalized form 1 x 2 ** <exp>
        The representation uses 5 bytes stored using the following structure:
        | M (31-24) | M	(23-16) | M	(15-8) | sign + M (7-0) | exponent |
        The exponent is 8-bit an uses a bias of 128 (128-255 possitive, 0-127 negative)
        """
        sign = '1' if n < 0 else '0'
        exp = 0
        prec = abs(n)
    
        while prec >= 1:
            exp = exp + 1
            prec = prec / 2.0
        while 0 < prec < 0.5:
            prec = prec * 2
            exp = exp - 1

        exp = 0 if exp == 0 else exp + 128
        bit = 0
        mant = ""
        for i in range(32):
            prec = prec - bit
            prec = prec * 2
            bit = int(prec)
            mant = mant + str(bit)
        # round values last bit
        if prec > 0.5: mant = mant[:-1] + '1'
        # is normalized so drop first bit and used it for sign
        mant = sign + mant[1:]
        real = bytearray(int(mant, 2).to_bytes(4, byteorder='little'))
        real.extend(exp.to_bytes(1, 'little'))
        return real

    # ----------------- Label generation -----------------

    def _get_conststr_label(self) -> str:
        self.constants +=1
        return f"__const_str_{self.constants}"
        
    def _get_constreal_label(self) -> str:
        self.constants +=1
        return f"__const_real_{self.constants}"
    
    def _get_for_labels(self) -> tuple[str,str]:
        self.constants +=1
        return (f"__forloop_start_{self.constants}", f"__forloop_end_{self.constants}")

    def _get_while_labels(self) -> tuple[str,str]:
        self.constants +=1
        return (f"__whileloop_start_{self.constants}", f"__whileloop_end_{self.constants}")

    def _get_if_labels(self) -> tuple[str,str]:
        self.constants +=1
        return (f"__if_else_{self.constants}", f"__if_end_{self.constants}")

    def _get_symbol_label(self) -> str:
        self.constants +=1
        return f"__symbol_{self.constants}"

    # ----------------- Error management -----------------

    def _raise_error(self, codenum: int, node: AST.ASTNode, info: str = ""):
        if self.verbose:
            print(node)
        codeline = self.source[node.line - 1]
        raise BasError(
            codenum,
            codeline.source,
            codeline.code,
            codeline.line,
            node.col,
            info
        ) 

    def _raise_warning(self, level: int, msg: str, node: AST.ASTNode):
        if self.warning_level < 0 or self.warning_level >= level:
            # tokens start line counting in 1
            codeline = self.source[node.line - 1]
            print(f"[WARNING] {codeline.source}:{codeline.line}:{node.col}: {msg} in {codeline.code}")

    # ----------------- Commands and Functions -----------------

    def _emit_ABS(self, node:AST.Function):
        """
        Returns the absolute value of the given expression which primarily means
        that negative numbers are returned as positive. 
        """
        self._emit_import("rt_abs")
        self._emit_code("; ABS(<numeric expression>)")
        arg = node.args[0]
        if arg.etype == AST.ExpType.Real:
            # TODO: reals
            self._raise_error(2, node, 'reals are not supported')
        self._emit_expression(arg)
        self._emit_code("call    rt_abs")

    def _emit_AFTER(self, node:AST.Command):
        """
        Invoke a subroutine after a given time period has elapsed. The first
        <int expr>, indicates the period of the delay, in units of 1/50 second,
        and the second <int expr>, (in range 0 to 3), indicates which of the
        four available delay timers should be used. 
        """
        self._emit_code("; AFTER <int expr>[,<int expr>] GOSUB (INT | IDENT)")
        self._emit_event_init(node)
        self._emit_code("ld      bc,0", info="recharge value")
        self._emit_code(f"call    {FWCALL.KL_ADD_TICKER}", info="KL_ADD_TICKER")
        self._emit_code(";")

    def _emit_event_init(self, node:AST.Command):
        self._emit_import("rt_timer")
        args = node.args
        self._emit_expression(args[0])
        self._emit_code("push    hl", info="number of ticks to fire event")
        if len(args) == 3:
            self._emit_expression(args[1])
            self._emit_code("ld      a,l")
        else:
            self._emit_code("xor     a", info="default timer ID is 0")
        self._emit_code("call    rt_timer_get", info="HL address to event block")
        self._emit_code("push    hl", info="tick block address")
        self._emit_code("ld      bc,6")
        self._emit_code("add     hl,bc", info="HL = event block inside the tick")
        # GOSUB address
        label = args[-1].args[0] # type: ignore [attr-defined]
        if isinstance(label, AST.Integer) or isinstance(label, AST.Label):
            sym = self.symtable.find(str(label.value), "")
            if sym is not None:
                self._emit_code(f"ld      de,{sym.label}")
        self._emit_code("ld      b,&81", info="async near call")
        self._emit_code(f"call    {FWCALL.KL_INIT_EVENT}", info="KL_INIT_EVENT")
        self._emit_code("pop     hl", info="tick block address")
        self._emit_code("pop     de", info="timer ticks needed to fire the event")

    def _emit_ASC(self, node:AST.Function):
        """
        Gets the numeric value of the first character of a string as long as
        ASCII characters are used.
        """
        self._emit_code("; ASC(<string>)")
        self._emit_expression(node.args[0])
        self._emit_code("inc     hl")
        self._emit_code("ld      a,(hl)", info="get first char numeric value")
        self._emit_code("ld      l,a")
        self._emit_code("ld      h,0")
        self._emit_code(";")

    def _emit_ATN(self, node:AST.Function):
        """
        Calculates the arc-tangent (forcing the numeric expression) to a real
        number ranging from -PI/2 to +PI/2 of the value specified.
        """
        # TODO: reals
        self._emit_code("; ATN(<numeric expression>)")
        self._raise_error(2, node, 'not implemented yet')
        self._emit_code(";")

    def _emit_AUTO(self, node:AST.Command):
        """
        Generate line numbers automatically. The <line number>, sets the first
        line to be generated, in case you want to add to the end of an existing
        program. The value of the <increment> between line numbers, and the first
        line number to be generated, both default to 10 if not specified.
        """
        self._emit_code("; AUTO [<line number>l[,<increment>]")
        self._emit_code("; IGNORED")
        self._raise_warning(0, 'AUTO is ignored and has not effect', node)

    def _emit_BINSS(self, node:AST.Function):
        """
        Produces a string of binary digits that represents the value of the
        <unsigned integer expression>, filling with leading zeros to the number
        of digits instructed by the second <integer expression>.
        """
        # prints 8 or 16 characters
        self._emit_import("rt_int2bin")
        self._emit_code("; BIN$(<unsigned integer expression>[,<integer expression>])")
        if len(node.args) == 2:
            self._emit_expression(node.args[1])
        else:
            self._emit_code("ld      hl,16")
        self._emit_code("push    hl")
        self._emit_expression(node.args[0])
        self._emit_code("ex      de,hl", info="number to convert")
        self._reserve_memory(17)
        self._emit_code("pop     bc", info="number of characters")
        self._emit_code("ld      a,c", info="only 8 or 16 are valid")
        self._emit_code("call    rt_int2bin")
        self._emit_code(";")

    def _emit_BORDER(self, node:AST.Command):
        """
        To change the colour of the border on the screen. If two colours are
        specified, the border alternates between the two at the rate determined
        in the SPEED INK command, if given. The range of border colours
        is 0 to 26.        
        """ 
        self._emit_code("; BORDER <colour>[,<colour>]")
        self._emit_expression(node.args[0])
        if len(node.args) == 2:
            self._emit_code("push    hl")
            self._emit_expression(node.args[1])
            self._emit_code("ld      c,l", info="second color")
            self._emit_code("pop     de")
            self._emit_code("ld      b,e", info="first color")
        else:
            self._emit_code("ld      c,l", info="second color")
            self._emit_code("ld      b,l", info="first color")
        self._emit_code(f"call    {FWCALL.SCR_SET_BORDER}", info="SCR_SET_BORDER")
        self._emit_code(";")

    def _emit_CALL(self, node:AST.Command):
        """
        Allows an externally developed sub-routine to be invoked from BASIC.
        The routine is called with IX pointing to the list of parameters and A
        containing the number of parameters. Parameters are passed in reverse
        order, ie. (IX+0) is the last parameter supplied.
        """
        self._emit_code("; CALL <address expression> ,[<list of: <parameter>]")
        if len(node.args) == 1 and isinstance(node.args[0],AST.Integer):
            address: int = node.args[0].value
            self._emit_code(f"call     {address}", info=f"calling {address:#04x}")
        else:
            self._emit_import("rt_call")
            params = node.args[1:]
            if len(params) > 0:
                for a in params:
                    self._emit_expression(a)
                    self._emit_code("push    hl")
                self._emit_code("ld      ix,0")
                self._emit_code("add     ix,sp")
            self._emit_expression(node.args[0])
            self._emit_code(f"ld      a,{len(params)}")
            self._emit_code("call    rt_call", info="HL has the address")
            for a in params:
                self._emit_code("pop     de")
        self._emit_code(";")

    def _emit_CAT(self, node:AST.Command):
        """
        Causes BASIC to start reading the directory of the current drive
        (cassette or disc) and to display the names of all files found.
        This does not affect the program currently in memory, and so may be used
        to verify a program that has just been saved before altering the program
        memory. 
        """
        self._emit_import("rt_malloc")
        self._emit_code("; CAT")
        self._emit_code("ld      bc,2048", info="buffer used by the firmware")
        self._emit_code("call    rt_malloc")
        self._emit_code("ex      de,hl", info="buffer address in DE")
        self._emit_code(f"call    {FWCALL.CAS_CATALOG}")
        self._emit_code(";")

    def _emit_CHAIN(self, node:AST.Command):
        """
        CHAIN loads a program from disc or cassette into the memory; replacing the
        existing program. The new program then commences running, either from the
        beginning, or from the line specified in the optional <line number expr>.
        Protected files (saved with the ',P' type) can be loaded and run by chaining.
        """
        self._emit_code("; CHAIN <file name>[,<line number>]")
        self._raise_warning(0, 'CHAIN is ignored and has not effect', node)
        self._emit_code("; IGNORED")
        self._emit_code(";")

    def _emit_CHAIN_MERGE(self, node:AST.Command):
        """
        CHAIN MERGE merges a program from disc or cassette into the current program
        memory. The <line number expression>, indicates the line number from which
        execution is to begin once the new program is chain merged. In the absence
        of <line number expression>, BASIC will default to the lowest line number
        available. 
        """
        # CHAIN MERGE is processed by the preprocessor and it is used to
        # append additional BAS files, so here we don't have to do anything
        # here.
        self._emit_code("; CHAIN MERGE <file name>[,<line number>][, DELETE <range>]")
        self._raise_warning(0, 'CHAIN MERGE is ignored and has not effect', node)
        self._emit_code("; IGNORED")
        self._emit_code(";")

    def _emit_CHRSS(self, node:AST.Function):
        """
        Converts <integer expression> in the range 0 to 255, to its character
        string equivalent. Note that 0 to 31 are control characters. 
        """
        self._emit_code("; CHR$(<integer expression>)") 
        self._emit_expression(node.args[0])
        self._emit_code("ex      de,hl")
        self._reserve_memory(2)
        self._emit_code("ld      (hl),1")
        self._emit_code("inc     hl")
        self._emit_code("ld      (hl),e")
        self._emit_code("dec     hl")
        self._emit_code(";")

    def _emit_CINT(self, node:AST.Function):
        """
        Converts the given value to a rounded integer in the range -32768..32767. 
        """
        # TODO: reals
        self._emit_code("; INT(<numeric expression>)")
        self._raise_error(2, node, 'not implemented yet')
        self._emit_code(";")

    def _emit_CLEAR(self, node:AST.Command):
        """
        Clears all variables to zero or null. All open files are abandoned, all
        arrays and user functions are erased, and BASIC is set to radians mode
        of calculation. 
        """
        self._emit_code("; CLEAR")
        self._raise_warning(0, 'CLEAR is ignored and has not effect', node)
        self._emit_code("; IGNORED")
        self._emit_code(";")
        
    def _emit_CLEAR_INPUT(self, node:AST.Command):
        """
        Only available with BASIC 1.1
        Discards all previously typed input from the keyboard, still in the
        keyboard buffer.
        """
        # There is an specific Firmware routine in the 6128 (KM FLUSH)
        # but to make it compatible with the 464 we use KM RESET instead
        self._emit_code("; CLEAR INPUT")
        self._emit_code(f"call    {FWCALL.KM_RESET}", info="KM_RESET")
        self._emit_code(";")

    def _emit_CLG(self, node:AST.Command):
        """
        Clears the graphics screen to the graphics paper colour. If the <ink>
        is specified, the graphics paper is set to that value. 
        """
        self._emit_code("; CLG [<masked ink>]")
        if len(node.args) > 0:
            self._emit_expression(node.args[0])
            self._emit_code("ld      a,l")
            self._emit_code(f"call    {FWCALL.GRA_SET_PAPER}", info="GRA_SET_PAPER")
        self._emit_code(f"call    {FWCALL.GRA_CLEAR_WINDOW}", info="GRA_CLEAR_WINDOW")
        self._emit_code(";")
    
    def _emit_CLOSEIN(self, node:AST.Command):
        """
        Close any input file from disc or cassette.
        """
        self._emit_code("; CLOSEIN")
        self._emit_code(f"call    {FWCALL.CAS_IN_CLOSE}", info="CAS_IN_CLOSE")
        self._emit_code(";")

    def _emit_CLOSEOUT(self, node:AST.Command):
        """
        Close any output file from disc or cassette.
        """
        self._emit_code("; CLOSEOUT")
        self._emit_code(f"call    {FWCALL.CAS_OUT_CLOSE}", info="CAS_OUT_CLOSE")
        self._emit_code(";")

    def _emit_CLS(self, node:AST.Command):
        """
        Clear the given screen stream (window) to its paper ink. If no
        <stream expression> is given, screen stream #0 is cleared. 
        """
        self._emit_code("; CLS [#<stream expression>]")
        if len(node.args):
            self._emit_expression(node.args[0])
            self._emit_stream()
        else:
            self._emit_code("xor     a")
            self._emit_code(f"call    {FWCALL.TXT_STR_SELECT}", info="TXT_STR_SELECT")
        self._emit_code(f"call    {FWCALL.TXT_CLEAR_WINDOW}", info="TXT_CLEAR_WINDOW")

    def _emit_CONT(self, node:AST.Command):
        """
        Continue program execution after a *Break*, STOP or END, as long as the
        program has not been altered. Direct commands may be entered. 
        """
        self._emit_code("; CONT")
        self._raise_warning(0, 'CONT is ignored and has not effect', node)
        self._emit_code("; IGNORED")
        self._emit_code(";")
    
    def _emit_COPYCHRSS(self, node:AST.Function):
        """
        BASIC 1.1 only
        COPies ChaRacter from the current position in the stream (which MUST be
        specified). If the character read is not recognized, a null string is
        returned. 
        """
        self._emit_import("rt_copychrs")
        self._emit_code("; COPYCHR$(#<stream expression>)")
        self._emit_expression(node.args[0])
        self._emit_code("ex      de,hl")
        self._reserve_memory(2)
        self._emit_code("ld      a,e")
        self._emit_code("call    rt_copychrs")
        self._emit_code(";")

    def _emit_COS(self, node:AST.Function):
        """
        Calculates the COSINE of a given value. The function defaults to radian
        measure unless specifically instructed otherwise by the DEG command. 
        """
        # TODO: reals
        self._emit_code("; COS(<numeric expression>)")
        self._raise_error(2, node, 'not implemented yet')
        self._emit_code(";")

    def _emit_CREAL(self, node:AST.Function):
        """
        Converts a value to a real number (As opposed to integer).
        """
        # TODO: reals
        self._emit_code("; CREAL(<numeric expression>)")
        self._raise_error(2, node, 'not implemented yet')
        self._emit_code(";")

    def _emit_CURSOR(self, node:AST.Command):
        """
        Only available with BASIC 1.1
        Sets the system switch or the user switch to the cursor, ON or OFF. The
        <system switch> and <user switch> parameters must be either 0 (OFF) or 1 (ON).
        The cursor is displayed whenever both the <system switch> and <user switch>
        are ON (1). The <system switch> is automatically turned OFF when printing
        text to screen. Either swtich parameter may be omitted, but not both. If
        a switch parameter is omitted, that particular switch state is not changed.
        """
        self._emit_code("; CURSOR [<system switch>][,<user switch>]")
        calls_on = [FWCALL.TXT_CUR_ON, FWCALL.TXT_CUR_ENABLE]
        calls_off = [FWCALL.TXT_CUR_OFF, FWCALL.TXT_CUR_DISABLE]
        for i,a in enumerate(node.args):
            self._emit_code("; system cursor" if i == 0 else "; user cursor")
            self._emit_expression(a)
            self._emit_code("ld      a,l", info="valid values are 0 or <>0")
            self._emit_code("or      a")
            self._emit_code("jr      z,$+7")
            self._emit_code(f"call    {calls_on[i]}", info="TXT_CURSOR_ON/TXT_CURSOR_ENABLE")
            self._emit_code("jr      $+5")
            self._emit_code(f"call    {calls_off[i]}", info="TXT_CURSOR_OFF/TXT_CURSOR_DISABLE")
        self._emit_code(";")
   
    def _emit_DATA(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DECSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEF(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEFINT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEFREAL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEFSTR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEF_FN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEG(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DELETE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DERR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DI(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DIM(self, node:AST.Command):
        """
        Allocate space for arrays and specify maximum subscript values. Basic must be
        advised of the space to be reserved for an array, or it will default to 10.
        Once set either implicitly or explicitly, the size of the array may not be changed,
        or an error will result.
       """
        self._emit_code("; DIM <list of: subscripted variable>")
        # We don't really emit code here but check that we don't consume 
        # more than 28K of central memory leaving 4K max for code.
        for var in node.args:
            if isinstance(var, AST.Array):
                entry = self.symtable.find(var.name, context="")
                if entry is not None:
                    mem = 1
                    for index in entry.indexes: mem = mem * index
                    if var.etype == AST.ExpType.String: mem = mem * 255
                    elif var.etype == AST.ExpType.Integer: mem = mem * 2
                    elif var.etype == AST.ExpType.Real: mem = mem * 5
                    self._emit_code(f"; Array variable {entry.label} with {mem} bytes")
                    if mem > 28*1024:
                        self._raise_error(7, node)
                else:
                    self._raise_error(2, node)
            else:
                self._raise_error(2, node)
        self._emit_code(";")

    def _emit_DRAW(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DRAWR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_EDIT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_EI(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ELSE(self, node:AST.Statement):
        if len(self.ifblocks) > 0:
            # IFEND will remove from the queue
            ifnode = self.ifblocks[-1]
            self._emit_code(f"jp      {ifnode.end_label}")
            self._emit_code("; ELSE")
            self._emit_code(ifnode.else_label, 0)
        else:
            self._raise_error(37, node)

    def _emit_END(self, node:AST.Statement):
        """
        End of program. An END is implicit in AMSTRAD BASIC as the program
        passes the last line of instruction. END closes all cassette files and
        returns to the direct mode. Sound queues will continue until empty.
        """
        # In our version, we call FULL RESET after any key is pressed
        self._emit_code("; END")
        self._emit_code(f"call    {FWCALL.KM_WAIT_CHAR}", info="KM_WAIT_CHAR")
        self._emit_code("call    0")

    def _emit_ENT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ENV(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_EOF(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ERASE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ERL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ERR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ERROR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_EVERY(self, node:AST.Command):
        """
        The EVERY command allows a BASIC program to arrange for subroutines to
        be called at regular intervals. Four delay timers are available, specified
        by the 2nd <int expression> in the range 0 to 3 each of which may have a
        subroutine associated with it.
        """
        self._emit_code("; EVERY <int expr>[,<int expr>] GOSUB (INT | IDENT)")
        self._emit_event_init(node)
        self._emit_code("ld      b,d", info="recharge value")
        self._emit_code("ld      c,e")
        self._emit_code(f"call    {FWCALL.KL_ADD_TICKER}", info="KL_ADD_TICKER")
        self._emit_code(";")


    def _emit_EXP(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_FILL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_FIX(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_FN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_FOR(self, node:AST.ForLoop):
        """
        Execute a body of program a given number of times, stepping a control
        variable between a start and an end value. If not specified, STEP
        defaults to 1. 
        """
        sym = self.symtable.find(node.var.name)
        start, end = self._get_for_labels()
        node.start_label = start
        node.end_label = end
        if sym is not None:
            self._emit_code("; FOR <variable> = <start> TO <end> [STEP <size>]")
            self._emit_expression(node.start)
            self._emit_code(f"ld      ({sym.label}),hl")
            if node.step is not None:
                self._emit_code("; STEP precalculation")
                self._emit_expression(node.step)
                self._emit_code("ld      c,l")
                self._emit_code("ld      b,h")
            self._emit_code("; FOR condition")
            self._emit_code(start, 0)
            self._emit_expression(node.end)
            # clear temporal memory if used by the condition expression before
            # jumping. Modifies DE
            self._emit_free_mem()
            self._emit_code(f"ld      de,({sym.label})")
            self._emit_code("or      a")
            if node.step is not None:
                self._emit_code("; check STEP sign")
                self._emit_code("bit     7,b")
                self._emit_code("jr      z,$+3")
                self._emit_code("ex      de,hl")
            self._emit_code("sbc     hl,de")
            self._emit_code(f"jp      m,{end}")
            if node.step is not None:
                self._emit_code("push    bc")
            self._emit_code("; FOR body")
            node.var_label = sym.label
            self.forloops.append(node)
        else:
            self._raise_error(2, node, "undeclared variable {var.name}")

    def _emit_FRAME(self, node:AST.Statement):
        """
        Only available with BASIC 1.1
        Synchronises the writing of the graphics on the screen with the frame
        flyback (VSYNC) of the display. The overall effect of this is that
        character or graphics movement on the screen will appear to be smoother,
        without flickering or tearing.
        With BASIC 1.0, two alternatives for the FRAME command exist:
        - CALL &BD19 (call the firmware function MC WAIT FLYBACK).
        - WAIT &F500,1 (wait until the frame flyback bit at PPI Port B is set).
        """
        self._emit_code("; FRAME")
        self._emit_code(f"call    {FWCALL.MC_WAIT_FLYBACK}", info="MC_WAIT_FLYBACK")

    def _emit_FRE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_GOSUB(self, node:AST.Command):
        """
        Call a BASIC subroutine by branching to the specified line number or
        label. 
        """
        label = node.args[0]
        self._emit_code("; GOSUB <line number> | <label> ")
        if isinstance(label, AST.Integer) or isinstance(label, AST.Label):
            sym = self.symtable.find(str(label.value), "")
            if sym is not None:
                self._emit_code(f"call    {sym.label}")
            else:
                self._raise_error(38, label)
        self._emit_code(";")

    def _emit_GOTO(self, node:AST.Command):
        """
        Branch to specified line number or label. 
        """
        label = node.args[0]
        self._emit_code("; GOTO <line number> | <label> ")
        if isinstance(label, AST.Integer) or isinstance(label, AST.Label):
            sym = self.symtable.find(str(label.value), "")
            if sym is not None:
                self._emit_code(f"jp      {sym.label}")
            else:
                self._raise_error(38, label)
        self._emit_code(";")

    def _emit_GRAPHICS_PAPER(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_GRAPHICS_PEN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_HEXSS(self, node:AST.Function):
        """
        Converts the number given into Hexadecimal form. The second <int expr>
        can be used to specify the minimum length of the result. 
        """
        # prints 2 or 4 characters
        self._emit_import("rt_int2hex")
        self._emit_code("; HEX$(<int expr>[,<int expr>])")
        if len(node.args) == 2:
            self._emit_expression(node.args[1])
        else:
            self._emit_code("ld      hl,&0004")
        self._emit_code("push    hl")
        self._emit_expression(node.args[0])
        self._emit_code("ex      de,hl", info="number to convert")
        self._reserve_memory(5)
        self._emit_code("pop     bc", info="number of characters")
        self._emit_code("ld      a,c", info="only 2 or 4 are valid")
        self._emit_code("call    rt_int2hex")
        self._emit_code(";")

    def _emit_HIMEM(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_IF(self, node:AST.If):
        """
        It is used to conditionally determine branch points in a program. The
        logical part is evaluated, and if true the THEN or GOTO part is executed,
        if false, the program skips to the ELSE part, or merely passes onto the
        next line.
        """
        elselabel, endlabel = self._get_if_labels()
        node.else_label = elselabel
        node.end_label = endlabel
        self._emit_code("; IF <logical expr> THEN <option part> [ELSE <option part>]")
        self._emit_expression(node.condition)
        # clear temporal memory if used by the condition expression before
        # jumping. Modifies DE
        self._emit_free_mem()
        self._emit_code("ld      a,h")
        self._emit_code("or      a")
        if node.has_else:
            self._emit_code(f"jp      z,{elselabel}")
        else:
            self._emit_code(f"jp      z,{endlabel}")
        self._emit_code("; THEN")
        if len(node.inline_then):
            for stmt in node.inline_then:
                self._emit_statement(stmt)
                if node.has_else:
                    self._emit_code(f"jp      {endlabel}")
            if len(node.inline_else):
                self._emit_code("; ELSE")
                self._emit_code(elselabel, 0)
                for stmt in node.inline_else:
                    self._emit_statement(stmt)
            self._emit_code("; IF end")
            self._emit_code(endlabel, 0)
        else:
            self.ifblocks.append(node)

    def _emit_IFEND(self, node:AST.BlockEnd):
        if len(self.ifblocks) > 0:
            ifnode = self.ifblocks.pop()
            self._emit_code("; IFEND")
            self._emit_code(ifnode.end_label, 0)
            self._emit_code(";")
        else:
            self._raise_error(36, node)

    def _emit_INK(self, node:AST.Command):
        """
        Assigns colour(s) to a given ink. The <ink> parameter describes the ink
        reference, which must be an integer expression in the range 0 to 15, for
        use in the appertaining PEN or PAPER command. The first <colour>
        parameter should be an integer expression yielding a colour value in the
        range 0 to 26. If an optional second <colour> is specified, the ink
        alternates between the two colours, at a rate determined by SPEED INK
        command. Depending on the current screen mode, a number of INKs are
        available. 
        """
        self._emit_code("; INK <ink>,<colour>[,<colour>]")
        self._emit_expression(node.args[1])
        if len(node.args) == 3:
            self._emit_code("push    hl")
            self._emit_expression(node.args[2])
            self._emit_code("ld      c,l", info="second color")
            self._emit_code("pop     de")
            self._emit_code("ld      b,e", info="first color")
        else:
            self._emit_code("ld      c,l", info="second color")
            self._emit_code("ld      b,l", info="first color")
        self._emit_code("push    bc")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code("pop     bc")
        self._emit_code(f"call    {FWCALL.SCR_SET_INK}", info="SCR_SET_INK")
        self._emit_code(";")

    def _emit_INKEY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_INKEYSS(self, node:AST.Function):
        """
        Reads a key from the keyboard to provide operator interaction without
        hitting [ENTER] after every answer. If there is a key pressed, then the
        function responds - if no key is pressed, it continues to return an
        empty string which is used to loop until a valid input is detected
        for processing.
        """
        self._emit_code("; INKEY$")
        self._reserve_memory(2)
        self._emit_code("ld      (hl),0", info="emtpy string")
        self._emit_code("push    hl")
        self._emit_code(f"call    {FWCALL.KM_READ_CHAR}", info="KM_READ_CHAR")
        self._emit_code("pop     hl")
        self._emit_code("jr      nc,$+7", info="if CF we have a character")
        self._emit_code("ld      (hl),1")
        self._emit_code("inc     hl")
        self._emit_code("ld      (hl),a")
        self._emit_code("dec     hl")
        self._emit_code(";")

    def _emit_INP(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_INPUT(self, node:AST.Input):
        """
        Reads data from the stated stream. A semicolon after INPUT suppresses the
        carriage return typed at the end of the line being entered. A semicolon
        after the <quoted string> causes a question mark to be displayed.
        A comma suppresses the question mark. All responses must be terminated
        with an [ENTER].
        """
        self._emit_import("rt_input")
        self._emit_code("; INPUT [#<stream>][;][<quoted string>,]<list: [var]>")
        if node.stream is not None:
            self._emit_stream()
        if node.prompt != "":
            self._print_str(AST.String(value=node.prompt))
        if node.question:
            self._emit_code("ld      hl,rt_input_question")
            self._emit_code("call    rt_print_str")
        # Ask for values and check that we get as many values as variables
        inputs = len(node.vars)
        lstart, lend = self._get_while_labels()
        self._emit_code(lstart, 0)
        self._emit_code("call    rt_input")
        self._emit_code("ld      a,c", info="check all quoted strings are terminated")
        self._emit_code("and     &01", info="the count must be even so A turns 0")
        self._emit_code("add     b", info="number of substrings")
        self._emit_code(f"cp      {inputs}", info="number of given variables")
        self._emit_code(f"jr      z,{lend}")
        self._emit_code("ld      hl,rt_input_redo")
        self._emit_code("call    rt_print_str")
        self._emit_code(f"jr      {lstart}")
        self._emit_code(lend, 0)
        self._emit_code("ld      hl,rt_input_buf")
        for v in node.vars:
            self._emit_code("call    rt_extract_substrz")
            self._emit_code("push    hl", info="current position in input buffer")
            entry = self.symtable.find(v.name)
            if entry is not None:
                if isinstance(v, AST.Variable):
                    self._emit_code(f"; integer variable {v.name}")
                    if v.etype == AST.ExpType.String:
                        self._emit_code(f"ld      hl,{entry.label}")
                        self._emit_input_str(v, entry)
                    elif v.etype == AST.ExpType.Integer:
                        self._emit_input_int(v, entry)
                        self._emit_code(f"ld      ({entry.label}),hl")
                    elif v.etype == AST.ExpType.Real:
                        self._emit_input_real(v, entry)
                elif isinstance(v, AST.ArrayItem):
                    self._emit_code(f"; array item {v.name}")
                    self._emit_arrayitem(v)
                    if v.etype == AST.ExpType.String:
                        self._emit_input_str(v, entry)
                    elif v.etype == AST.ExpType.Integer:
                        self._emit_code("push    hl")
                        self._emit_input_int(v, entry)
                        self._emit_code("ex      de,hl")
                        self._emit_code("pop     hl")
                        self._emit_code("ld      (hl),de")
                    elif v.etype == AST.ExpType.Real:
                        self._emit_input_real(v, entry)
            self._emit_code("pop     hl", info="ready for next substring")
    
    def _emit_input_str(self, v:AST.Variable | AST.ArrayItem, var: SymEntry): 
        self._emit_code("ld      de,rt_substrz_buf")
        self._emit_code("ld      (hl),c", info="string len")
        self._emit_code("inc     hl")
        self._emit_code("ex      de,hl")
        self._emit_code("ld      b,0")
        self._emit_code("ldir")

    def _emit_input_int(self, v:AST.Variable | AST.ArrayItem, var: SymEntry):
        self._emit_import("rt_strz2num")
        self._emit_code("ld      de,rt_substrz_buf")
        self._emit_code("call    rt_strz2num")


    def _emit_input_real(self, v:AST.Variable | AST.ArrayItem, var: SymEntry):
        self._raise_error(2, v, 'float numbers in INPUT are not supported yet')

    def _emit_INSTR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_INT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_JOY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_KEY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_KEY_DEF(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LABEL(self, node:AST.Label):
        sym = self.symtable.find(node.value, "")
        if sym is not None:
            self._emit_code(f"{sym.label}", info="USER DEFINED LABEL")
        else:
            self._raise_error(38, node)

    def _emit_LEFTSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LEN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LET(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LINE_INPUT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LIST(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LOAD(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LOCATE(self, node:AST.Command):
        """
        Moves the text cursor at the stream indicated, to the position specified
        by the x and y co-ordinates, which are relative to the origin of the
        stream (WINDOW). Stream 0 is the default stream.
        """
        self._emit_code("; LOCATE [#<stream expression>,] <x coord>,<y coord>")
        args = node.args
        if len(args) == 3:
            self._emit_expression(args[0])
            self._emit_stream()
            args = args[1:]
        self._emit_expression(args[0])
        self._emit_code("push    hl", info="X coord")
        self._emit_expression(args[1])
        self._emit_code("pop     de")
        self._emit_code("ld      h,e")
        self._emit_code(f"call    {FWCALL.TXT_SET_CURSOR}", info="TXT_SET_CURSOR")
        self._emit_code(";")

    def _emit_LOG(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LOG10(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LOWERSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MASK(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MAX(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MEMORY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MERGE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MIDSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MODE(self, node:AST.Command):
        """
        Change the screen mode (0,1 or 2), and clear the screen to INK 0, which
        may not be the current PAPER ink. All text and graphics WINDOWS are reset
        to the whole screen, and the text and graphics cursors homed to their
        respective origins. 
        """
        self._emit_code("; MODE <integer expression>")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"call    {FWCALL.SCR_SET_MODE}", info="SCR_SET_MODE")

    def _emit_MOVE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MOVER(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_NEW(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_NEXT(self, node:AST.BlockEnd):
        fornode = self.forloops.pop()
        self._emit_code("; NEXT - FOR STEP")
        if fornode.step is not None:
            self._emit_code("pop     bc")
            self._emit_code(f"ld      hl,({fornode.var_label})")
            self._emit_code("add     hl,bc")
            self._emit_code(f"ld      ({fornode.var_label}),hl")
        else:
            self._emit_code(f"ld      hl,({fornode.var_label})")
            self._emit_code("inc     hl")
            self._emit_code(f"ld      ({fornode.var_label}),hl")
        self._emit_code(f"jp      {fornode.start_label}")
        self._emit_code(fornode.end_label, 0)
        self._emit_code(";")

    def _emit_ON(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ON_BREAK(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ON_ERROR_GOTO(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ON_SQ(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_OPENIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_OPENOUT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ORIGIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_OUT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PAPER(self, node:AST.Command):
        """
        Sets the background ink for characters. When characters are written to
        the text screen, the character cell is filled with the PAPER ink before
        the character is written, unless the transparent mode has been selected. 
        """
        self._emit_code("; PAPER [#<stream expression>,]<masked ink>")
        args = node.args
        if len(args) == 2:
            self._emit_expression(args[0])
            self._emit_stream()
            args = args[1:]
        self._emit_expression(args[0])
        self._emit_code("ld      a,l", info="color")
        self._emit_code(f"call    {FWCALL.TXT_SET_PAPER}", info="TXT_SET_PAPER")
        self._emit_code(";")


    def _emit_PEEK(self, node:AST.Function):
        """
        Examine the contents of a memory location specified in the <address>
        which should be in the range &0000 to &FFFF (0 to 65535). In all cases
        PEEK will return the value at the RAM address specified (not the ROM),
        and will be in the range &00 to &FF (0 to 255).
        """
        self._emit_code("; PEEK(<address expression>)")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,(hl)")
        self._emit_code("ld      h,0")
        self._emit_code("ld      l,a")
        self._emit_code(";")

    def _emit_PEN(self, node:AST.Command):
        """
        PEN sets the ink to be used when drawing at the given screen stream,
        defaulting to screen #0. 
        """
        self._emit_code("; PEN [#<stream expression>, ]<masked ink>")
        args = node.args
        if len(args) == 2:
            self._emit_expression(args[0])
            self._emit_stream()
            args = args[1:]
        self._emit_expression(args[0])
        self._emit_code("ld      a,l     ; color")
        self._emit_code(f"call    {FWCALL.TXT_SET_PEN}", info="TXT_SET_PEN")
        self._emit_code(";")

    def _emit_PI(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PLOT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PLOTR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_POKE(self, node:AST.Command):
        """
        Provides direct access to the machine memory. Writes the <int expr> in
        the range 0 to 255 directly into the machine memory (RAM) at the
        specified <address expression>. 
        """
        self._emit_code("; POKE <address expression>, <integer expression>")
        self._emit_expression(node.args[1])
        self._emit_code("push    hl", info="value to write")
        self._emit_expression(node.args[0])
        self._emit_code("pop     de")
        self._emit_code("ld      (hl),e")
        self._emit_code(";")

    def _emit_POS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PRINT(self, node:AST.Print):
        """
        Prints the list of: <print items>s to the given stream (to stream #0 if
        <stream expression> is not specified). Note that when a semicolon ; is
        used to tell the computer to print the following <print item> next to
        the preceding item, BASIC first checks to see if the following
        <print item> can fit onto the same line. If not, it will be printed on a
        new line regardless of the semicolon. Note that when a coma , is used to
        tell the computer to print the following <print item> in the next print
        zone, BASIC first checks to see that the preceding item has not exceeded
        the lenght of the current zone. If it has, the following <print item>
        is printed in a further zone. 
        """
        self._emit_import("rt_print")
        self._emit_code("; PRINT [#<stream expression>,][list of: <print item>]")
        if node.stream is not None:
            self._emit_expression(node.stream)
            self._emit_stream()
        for i,item in enumerate(node.items):
            if isinstance(item, AST.Separator):
                self._print_separator(item)
            elif isinstance(item, AST.Pointer):
                self._print_pointer(item)
            elif item.etype == AST.ExpType.String:
                self._print_str(item)
            elif item.etype == AST.ExpType.Integer:
                self._print_int(item)
            elif item.etype == AST.ExpType.Real:
                self._print_real(item)
            else:
                self._raise_error(2, item, 'print item not supported yet')
        if node.newline:
            self._print_newline()

    def _print_str(self, item:AST.Statement):
        self._emit_code("; PRINT string item")
        self._emit_expression(item)
        self._emit_code("call    rt_print_str")

    def _print_int(self, item:AST.Statement):
        # Integers always print one space before and after
        self._emit_import("rt_int2str")
        self._emit_code("; PRINT int item")
        self._emit_code("ld      a,32")
        self._emit_code(f"call    {FWCALL.TXT_OUTPUT}", info="TXT_OUTPUT")
        self._emit_expression(item)
        self._emit_code("call    rt_int2str")
        self._emit_code("call    rt_print_str")
        self._emit_code("ld      a,32")
        self._emit_code(f"call    {FWCALL.TXT_OUTPUT}", info="TXT_OUTPUT")
    
    def _print_pointer(self, item:AST.Pointer):
        # Pointer are always an address (int 16 bits)
        self._emit_import("rt_int2str")
        self._emit_code("; PRINT pointer item")
        self._emit_code("ld      a,32")
        self._emit_code(f"call    {FWCALL.TXT_OUTPUT}", info="TXT_OUTPUT")
        self._emit_pointer(item)
        self._emit_code("call    rt_int2str")
        self._emit_code("call    rt_print_str")
        self._emit_code("ld      a,32")
        self._emit_code(f"call    {FWCALL.TXT_OUTPUT}", info="TXT_OUTPUT")

    def _print_real(self, item:AST.Statement):
        self._raise_error(2, item, "printing reals is not supported")

    def _print_separator(self, item:AST.Separator):
        self._emit_code(f"; PRINT separator [{item.sym}]")
        if item.sym == ',':
            # TODO: do not use fix spaces
            self._emit_import("rt_print")
            self._emit_code("ld      l,4")
            self._emit_code("call    rt_print_spc")

    def _print_newline(self) -> None:
        self._emit_import("rt_print")
        self._emit_code("; new line")
        self._emit_code("call    rt_print_nl")

    def _emit_RAD(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RANDOMIZE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_READ(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RELEASE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_REMAIN(self, node:AST.Function):
        """
        Returns the REMAINing count from the delay timer specified in <int expr>
        (in the range 0 to 3) and disable it. 
        """
        self._emit_import("rt_timer")
        self._emit_code("; REMAIN(<integer expression>)")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code("call    rt_timer_get", info="HL address to event block")
        self._emit_code("ld      bc,4")
        self._emit_code("add     hl,bc", info="point to recharge value")
        self._emit_code("ld      (hl),&0000", info="reset recharge value")
        self._emit_code("dec     hl",   info="remaining ticks")
        self._emit_code("ld      d,(hl)")
        self._emit_code("dec     hl")
        self._emit_code("ld      e,(hl)")
        self._emit_code("ld      (hl),&0000", info="disable ticker")
        self._emit_code("ex      de,hl")
        self._emit_code("inc     hl", info="user count starts in 1 but system in 0")
        self._emit_code(";") 

    def _emit_RENUM(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RESTORE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RESUME(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RETURN(self, node:AST.Command):
        """
        Signals the end of a subroutine. BASIC returns to continue processing at
        the point after the GOSUB which invoked it.
        """
        self._emit_code("; RETURN")
        self._emit_code("ret")
        self._emit_code(";")

    def _emit_RIGHTSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RND(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ROUND(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RUN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SAVE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SGN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SOUND(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SPACESS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SPC(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SPEED_INK(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SPEED_KEY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SPEED_WRITE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SQ(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SQR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_STOP(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_STRINGSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_STRSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SYMBOL(self, node:AST.Command):
        """
        The SYMBOL command redefines the representation of a given character that
        has first been specified in the SYMBOL AFTER command. The character number,
        is chosen from the available ASCII or other characters from the CPC464's
        standard character set, and the following entries define the new character
        on an 88 pixel matrix. A 0 in the row indicates the paper colour to be
        used and a 1 indicates that the pixel is to be set to the current ink colour. 
        """
        self._emit_code("; SYMBOL <character number>,<list of: row>")
        label = self._get_symbol_label()
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"ld      hl,{label}")
        self._emit_code(f"call    {FWCALL.TXT_SET_MATRIX}", info="TXT_SET_MATRIX")
        self._emit_code(";")
        data = f"{label}: db "
        values: list[str] = []
        for i in range(1,9):
            arg = node.args[i]
            if isinstance(arg, AST.Integer):
                values.append(str(arg.value))
            else:
                self._raise_error(2, arg, 'an integer value was expected')
        data = data + ','.join(values)
        self._emit_data(data)

    def _emit_SYMBOL_AFTER(self, node:AST.Command):
        """
        The number of user definable characters is set by the SYMBOL AFTER command.
        The default setting is 240, giving 16 user defined characters. If the
        <integer expression>, is 32, then all characters from 32 to 255 are
        redefinable. Whenever a SYMBOL AFTER command is used, all user defined
        characters are reset to the default condition. 
        """
        # We use a static table that will be dimensioned to the biggest value
        # used in a symbol after call. For that reason, we don't allow
        # expressions and require de argument to be an integer value
        arg = node.args[0]
        if isinstance(arg, AST.Integer):
            num = arg.value
            if num < 0 or num > 255: num = 256 
            self._emit_code("; SYMBOL AFTER <int expression>")
            if num < self.symbolafter:
                self.symbolafter = num
            self._emit_code(f"ld      de,{num}")
            self._emit_code("ld      hl,_symbols_table")
            self._emit_code(f"call    {FWCALL.TXT_SET_M_TABLE}", info="TXT_SET_M_TABLE")
            self._emit_code(";")
        else:
            self._raise_error(2, arg, 'an integer value was expected')

    def _emit_TAB(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TAG(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TAGOFF(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TAN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TEST(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TESTR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_THEN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TIME(self, node:AST.Function):
        """
        Holds the elapsed time since switch-on, excluding periods when reading or writing
        the cassette (interrupts off). The units of time are 1/300th of a second.
        The firmware call returns the result in DEHL. The call eneables interrups.
        """
        self._emit_code("; TIME")
        self._emit_code(f"call     {FWCALL.KL_TIME_PLEASE}", info="KL_TIME_PLEASE")
        self._emit_code(";")

    def _emit_TROFF(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TRON(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_UNT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_UPPERSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_VAL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_VPOS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_WAIT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_WEND(self, node:AST.Statement):
        wnode = self.wloops.pop()
        self._emit_code("; WEND")
        self._emit_code(f"jp      {wnode.start_label}")
        self._emit_code(wnode.end_label, 0)
        self._emit_code(";")

    def _emit_WHILE(self, node:AST.WhileLoop):
        """
        A WHILE loop repeatedly executes a body of program until a given
        condition is true. The WHILE command defines the head of the loop, and
        gives the condition. The WEND command terminates the WHILE loop. 
        """
        start, end = self._get_while_labels()
        node.start_label = start
        node.end_label = end
        self._emit_code("; WHILE <logical expression>")
        self._emit_code(start, 0)
        self._emit_expression(node.condition)
        # clear temporal memory if used by the condition before
        # jumping. Modifies DE
        self._emit_free_mem()
        self._emit_code("ld      a,h")
        self._emit_code("or      a")
        self._emit_code(f"jp      z,{end}")
        self._emit_code("; WHILE BODY")
        self.wloops.append(node)
    
    def _emit_WIDTH(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_WINDOW(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_WINDOW_SWAP(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_WRITE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_XPOS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_YPOS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ZONE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    # ----------------- Expressions -----------------

    def _emit_expression(self, node: AST.Statement):
        if isinstance(node, AST.Integer):
            self._emit_code(f"ld      hl,{node.value & 0xFFFF}")
        elif isinstance(node, AST.String):
            self._emit_const_str(node)
        elif isinstance(node, AST.Real):
            self._emit_const_real(node)
        elif isinstance(node, AST.Variable):
            self._emit_variable(node)
        elif isinstance(node, AST.ArrayItem):
            self._emit_arrayitem(node)
        elif isinstance(node, AST.BinaryOp):
            self._emit_binaryop(node)
        elif isinstance(node, AST.UnaryOp):
            self._emit_unaryop(node)
        elif isinstance(node, AST.Function):
            self._emit_function(node)
        elif isinstance(node, AST.Pointer):
            self._emit_pointer(node)
        else:
            self._raise_error(2, node, 'expression not supported yet')

    def _emit_const_str(self, node: AST.String):
        label = self._get_conststr_label()
        self._emit_code(f"ld      hl,{label}")
        self._emit_data(f'{label}: db {len(node.value)},"{node.value}"')

    def _emit_const_real(self, node: AST.Real):
        label = self._get_constreal_label()
        self._emit_code(f"ld      hl,{label}")
        cpcreal = self._real(node.value)
        values = ""
        for b in cpcreal:
            values = values + f'&{b:02X},'
        # send code without last ','
        self._emit_data(f'{label}: db {values[:-1]}')

    def _emit_variable(self, node: AST.Variable):
        var = self.symtable.find(node.name)
        if var is not None:
            if node.etype == AST.ExpType.Integer:  
                self._emit_code(f"ld      hl,({var.label})")
            elif node.etype == AST.ExpType.String:
                self._emit_code(f"ld      hl,{var.label}")
            elif node.etype == AST.ExpType.Real:
                self._emit_code(f"ld      hl,{var.label}")
            else:
                self._raise_error(2, node, 'var type not implemented yet')
        else:
            self._raise_error(38, node)
    
    def _emit_arrayitem(self, node: AST.ArrayItem):
            self._emit_arrayitem_ptr(node)
            if node.etype == AST.Integer:
                self._emit_code("ld      de,(hl)")
                self._emit_code("ex      de,hl")

    def _emit_arrayitem_ptr(self, node: AST.ArrayItem):
        var = self.symtable.find(node.name)
        if var is not None:
            if var.exptype != node.etype:
                self._raise_error(13, node)
            self._emit_expression(node.args[0])  # index
            if node.etype == AST.ExpType.Integer:
                self._emit_code("add     hl,hl", info="index * 2 bytes")                
            elif node.etype == AST.ExpType.String:
                self._emit_import("rt_mul16_255")
                self._emit_code("call    rt_mul16_255")
            elif node.etype == AST.ExpType.Real:
                self._emit_code("ld      d,h")
                self._emit_code("ld      e,l")
                self._emit_code("add     hl,hl", info="index * 5 bytes")
                self._emit_code("add     hl,hl")
                self._emit_code("add     hl,de")
            else:
                self._emit_code("ld      hl,0")
            self._emit_code(f"ld      de,{var.label}")
            self._emit_code("add     hl,de")
        else:
            self._raise_error(38, node)

    def _emit_pointer(self, node: AST.Pointer):
        var = self.symtable.find(node.var.name)
        if var is not None:
            if var.symtype == SymType.Variable:
                self._emit_code(f"ld      hl,{var.label}")
            elif var.symtype == SymType.Array:
                self._emit_arrayitem_ptr(node.args[0])
        else:
            self._raise_error(2, node)

    def _emit_binaryop(self, node: AST.BinaryOp):
        """ 
        Develops right side and pushes the result, develops left 
        and leaves it in HL
        """
        self._emit_expression(node.right)
        self._emit_code("push    hl")
        self._emit_expression(node.left)
        self._emit_code("pop     de")
        if node.etype == AST.ExpType.Integer:
            self._emit_int_op(node)
        elif node.etype == AST.ExpType.String:
            self._emit_str_op(node)
        elif node.etype == AST.ExpType.Real:
            self._emit_real_op(node)
        else:
            self._raise_error(2, node, f'{node.etype} operations are not supported yet')
    
    def _emit_unaryop(self, node: AST.UnaryOp):
        self._emit_expression(node.operand)
        if node.etype == AST.ExpType.Integer:
            if node.op == 'NOT':
                self._emit_code("ex      de,hl")
                self._emit_code("ld      hl,&FFFF")
                self._emit_code("ld      a,d")
                self._emit_code("or      e")
                self._emit_code("jr      z,$+3")
                self._emit_code("inc     hl")
            elif node.op == '-':
                self._emit_code("ld      de,0")
                self._emit_code("ex      de,hl")
                self._emit_code("xor     a")
                self._emit_code("sbc     hl,de")
            else:
                self._raise_error(2, node, f"integer '{node.op}' unary op is not supported yet")
        else:
            self._raise_error(2, node, f'{node.etype} unary operations are not supported yet')

    def _emit_int_op(self, node: AST.BinaryOp):
        op = node.op.upper()
        if op == '+':
            self._emit_code("add     hl,de")
        elif op == '-':
            self._emit_code("or      a", info="clear carry")
            self._emit_code("sbc     hl,de", info="HL = right - left")
        elif op == '*':
            self._emit_import("rt_mul16")
            self._emit_code("call   rt_mul16", info="HL = HL * DE")
        elif op == '\\':
            self._emit_import("rt_div16")
            self._emit_code("call    rt_div16", info="HL = HL \\ DE ")
        elif op == 'MOD':
            self._emit_import("rt_udiv16")
            self._emit_code("call    rt_udiv16")
            self._emit_code("ex      de,hl", info="HL = HL MOD DE")
        elif op == 'AND':
            self._emit_code("ld      a,h")
            self._emit_code("and     d")
            self._emit_code("ld      h,a")
            self._emit_code("ld      a,l")
            self._emit_code("and     e")
            self._emit_code("ld      l,a")
        elif op == 'OR':
            self._emit_code("ld      a,h")
            self._emit_code("or      d")
            self._emit_code("ld      h,a")
            self._emit_code("ld      a,l")
            self._emit_code("or      e")
            self._emit_code("ld      l,a")
        elif op == 'XOR':
            self._emit_code("ld      a,h")
            self._emit_code("xor     d")
            self._emit_code("ld      h,a")
            self._emit_code("ld      a,l")
            self._emit_code("xor     e")
            self._emit_code("ld      l,a")
        elif op == '/':
            self._raise_error(2, node, 'real div is not supported yet')
        elif op in ('=', '<>', '<', '<=', '>', '>='):
            self._emit_int_compare(node)
        else:
            self._raise_error(2, node, f'unknown "{op}" int op')
    
    def _emit_str_op(self, node: AST.BinaryOp):
        op = node.op.upper()
        if op == '+':
            self._emit_import("rt_strcopy")
            self._emit_import("rt_strcat")
            self._emit_code("push    de")
            self._emit_code("ex      de,hl")
            self._reserve_memory(255)
            self._emit_code("call    rt_strcopy", info="(HL) <- (DE)")
            self._emit_code("pop     de")
            self._emit_code("call    rt_strcat", info="(HL) <- (HL) + (DE)")
        else:
            self._raise_error(2, node, f'unknown "{op}" string op')

    def _emit_real_op(self, node: AST.BinaryOp):
        self._raise_error(2, node, 'real operations are not supported yet')

    def _emit_int_compare(self, node: AST.BinaryOp):
        if node.left.etype == AST.ExpType.String:
            self._emit_str_compare(node)
            return
        if node.op == '=':
            self._emit_code("xor     a")
            self._emit_code("sbc     hl,de")
            self._emit_code("ld      hl,&FFFF", info="HL = -1 TRUE")
            self._emit_code("jr      z,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<>':
            self._emit_code("xor     a")
            self._emit_code("sbc     hl,de")
            self._emit_code("ld      hl,&FFFF", info="HL = -1 TRUE")
            self._emit_code("jr      nz,$+3")
            self._emit_code("inc     hl", info ="HL = 0 FALSE")
        elif node.op == '<':
            self._emit_import("rt_comp16")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,&FFFF", info="HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '>':
            self._emit_import("rt_comp16")
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,&FFFF", info="HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<=':
            self._emit_import("rt_comp16")
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,0", info="HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl", info="HL =-1 TRUE")
        elif node.op == '>=':
            self._emit_import("rt_comp16")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,0", info="HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl", info="HL =-1 TRUE")
        else:
            self._raise_error(2, node, f'int "{node.op}" op not implemented yet')

    def _emit_str_compare(self, node: AST.BinaryOp):
        self._emit_import("rt_strcmp")
        if node.op == '=':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF", info="HL = -1 TRUE")
            self._emit_code("jr      z,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<>':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF", info="HL = -1 TRUE")
            self._emit_code("jr      nz,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<':
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF", info="HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '>':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF", info="HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl", info="HL = 0 FALSE")
        elif node.op == '<=':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,0", info="HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl", info="HL =-1 TRUE")
        elif node.op == '>=':
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,0", info="HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl", info="HL =-1 TRUE")
        else:
            self._raise_error(2, node, f'string "{node.op}" op not implemented yet')

    def _emit_stream(self) -> None:
        """
        0-7 keyboard to screen
        8   keyboard to printer
        9   channel to file
        """
        self._emit_code("; SET #STREAM")
        self._emit_code("ld      a,l")
        self._emit_code("and     &0F", info="valid stream range 0-9")
        self._emit_code(f"call    {FWCALL.TXT_STR_SELECT} ; TXT_STR_SELECT")

    # ----------------- AST Trasversal functions -----------------

    def _emit_comment(self, node: AST.Comment):
        pass

    def _emit_assigment(self, node: AST.Assignment):
        var = self.symtable.find(node.target.name) # type: ignore[attr-defined]
        if var is not None:
            self._emit_expression(node.source)
            if var.exptype == AST.ExpType.Integer:
                self._emit_code(f"ld      ({var.label}),hl")
            elif var.exptype == AST.ExpType.Real:
                self._emit_code("ld      b,0")
                self._emit_code("ld      c,5")
                self._emit_code(f"ld      de,{var.label}")
                self._emit_code("ldir")
            elif var.exptype == AST.ExpType.String:
                self._emit_code("ld      b,0")
                self._emit_code("ld      c,(hl)")
                self._emit_code("inc     c")
                self._emit_code(f"ld      de,{var.label}")
                self._emit_code("ldir")
            else:
                self._raise_error(2, node, f'variable type not implemented yet')
        else:
            self._raise_error(38, node)

    def _emit_RSX(self, node: AST.RSX):
        self._emit_code(f"; RSX call to {node.command}")
        label = node.command
        sym = self.symtable.find(label, "")
        if sym is not None:
            params = len(node.args)
            if params > 0:
                for a in node.args:
                    self._emit_expression(a)
                    self._emit_code("push    hl")
                self._emit_code("ld      ix,0")
                self._emit_code("add     ix,sp")
            self._emit_code(f"ld      hl,{sym.label}")
            self._emit_code(f"call    {FWCALL.KL_FIND_COMMAND}", info="KL_FIND_COMMAND")
            self._emit_code("jr      nc,$+7", info="CF if find succeeded")         
            self._emit_code(f"ld      a,{params}")
            self._emit_code(f"call    {FWCALL.KL_FAR_PCHL}", info="KL_FAR_PCHL")
            for i in range(0, params):
                self._emit_code("pop     de")
        self._emit_code(";")

    def _emit_blockend(self, node: AST.BlockEnd):
        if node.name == "NEXT":
            self._emit_NEXT(node)
        elif node.name == "WEND":
            self._emit_WEND(node)
        elif node.name == "ELSE":
            self._emit_ELSE(node)
        elif node.name == "IFEND":
            self._emit_IFEND(node)
        else:
            self._raise_error(2, node, "not implemented yet")

    def _emit_userfun(self, node: AST.UserFun):
        self._raise_error(2, node, "not implemented yet")

    def _emit_function(self, node: AST.Function):
        """
        Function's result will be placed in HL
        """
        keyword = node.name
        funcname = "_emit_" + keyword.replace('$','SS').replace(' ', '_')
        emit_keyword = getattr(self, funcname , None)
        if emit_keyword is None:
            self._raise_error(2, node, f", unknown keyword {keyword}")
        return emit_keyword(node) # type: ignore[misc]

    def _emit_command(self, node: AST.Command):
        keyword = node.name
        funcname = "_emit_" + keyword.replace('$','SS').replace(' ', '_')
        emit_keyword = getattr(self, funcname , None)
        if emit_keyword is None:
            self._raise_error(2, node, f", unknown keyword {keyword}")
        return emit_keyword(node) # type: ignore[misc]

    def _emit_statement(self, stmt: AST.Statement):
        if isinstance(stmt, AST.Comment):
            self._emit_comment(stmt)
        elif isinstance(stmt, AST.Assignment):
            self._emit_assigment(stmt)
        elif isinstance(stmt, AST.If):
            self._emit_IF(stmt)
        elif isinstance(stmt, AST.ForLoop):
            self._emit_FOR(stmt)
        elif isinstance(stmt, AST.WhileLoop):
            self._emit_WHILE(stmt)
        elif isinstance(stmt, AST.BlockEnd):
            self._emit_blockend(stmt)
        elif isinstance(stmt, AST.Print):
            self._emit_PRINT(stmt)
        elif isinstance(stmt, AST.Input):
            self._emit_INPUT(stmt)
        elif isinstance(stmt, AST.LineInput):
            self._emit_LINE_INPUT(stmt)
        elif isinstance(stmt, AST.Write):
            self._emit_WRITE(stmt)
        elif isinstance(stmt, AST.DefFN):
            self._emit_DEF_FN(stmt)
        elif isinstance(stmt, AST.UserFun):
            self._emit_userfun(stmt)
        elif isinstance(stmt, AST.Function):
            self._emit_function(stmt)
        elif isinstance(stmt, AST.Command):
            self._emit_command(stmt)
        elif isinstance(stmt, AST.Label):
            self._emit_LABEL(stmt)
        elif isinstance(stmt, AST.RSX):
            self._emit_RSX(stmt)
        else:
            self._raise_error(2, stmt, "unexpected statement")
        self._emit_free_mem()

    def _emit_line(self, line: AST.Line):
        self._emit_line_label(line)
        for stmt in line.statements:
            self._emit_statement(stmt)

    def emit_program(self) -> str:
        print("Generating assembly code...")
        self.asm = ""
        self._emit_head()
        for line in self.program.lines:
            self._emit_line(line)
        self._emit_code_end()
        self._emit_global_symbols()
        self._emit_symbol_table()
        code = self.code + "\n" + self.data + "\n" + self._emit_runtime()
        code = code + "\n\n_program_end_:"
        return code