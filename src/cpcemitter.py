"""
Translates intermediate code generated by the parser
to Amstrad CPC Z80 Assembly language in Maxam/WinAPE style.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation in its version 3.

This program is distributed in the hope that it will be useful
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
"""

from __future__ import annotations
from typing import List, Optional, cast, Any
from baspp import CodeLine
from baserror import BasError
from symbols import SymTable, SymEntry, SymType
import astlib as AST
from cpcrt import RT_FWCALL, RT_STR, RT_MATH, RT_MEM, RT_STDIO

class CPCEmitter:
    def __init__(self, code: list[CodeLine], program: AST.Program, symtable: SymTable, warning_level=-1):
        self.source = code
        self.program = program
        self.symtable = symtable
        self.warning_level = warning_level
        self.data= ""
        self.code= ""
        self.rtcode: list[str] = []
        self.runtime: list[str] = []
        self.constants: int = 0
        self.free_tmp_memory: bool = False
        self.reserved_tmp_memory: int = 0
        self.org = 0x4000
        self.forloops: list[AST.ForLoop] = []
        self.wloops: list[AST.WhileLoop] = []
        self.ifblocks: list[AST.If] = []

    def _emit_code(self, line: str="", indent: int=4):
        pad = ""
        for _ in range(indent): pad = pad + " "
        self.code = self.code + f"{pad}{line}\n"

    def _emit_data(self, line: str="", indent: int=4):
        pad = ""
        for _ in range(indent): pad = pad + " "
        self.data = self.data + f"{pad}{line}\n"

    def _emit_line_label(self, line: AST.Line):
        label = self._get_linenum_label(line.number)
        codeline = self.source[line.line-1]
        self._emit_code(label + f":   ; {codeline.code}")

    def _emit_import(self, lib: Any, fname: str) -> bool:
        if fname not in self.runtime:
            self.runtime.append(fname)
            fcode: List[str] = lib[fname]
            self.rtcode = self.rtcode + fcode
            self.rtcode.append('\n')
            return True
        return False

    def _emit_free_mem(self) -> None:
        if self.free_tmp_memory:
            self._emit_code("; Free all used temporal memory")
            self._emit_code("ld    hl,_memory_start")
            self._emit_code("ld    (_memory_next),hl")
            self.free_tmp_memory = False
            self.reserved_tmp_memory = 0

    def _reserve_memory(self, nbytes: int):
        self._emit_import(RT_MEM, "rt_malloc")
        self._emit_code(f"ld      a,{nbytes}      ; bytes to reserve")
        self._emit_code("call    rt_malloc  ; HL points to empty mem")
        self.free_tmp_memory = True
        self.reserved_tmp_memory += nbytes

    def _emit_head(self):
        self._emit_code("; FILE GENERATED BY BASC COMPILER", 0)
        self._emit_code("; DESIGNED TO BE ASSEMBLED BY ABASM", 0)
        self._emit_code(";", 0)
        self._emit_code()
        self._emit_code("org     0x170", 0)
        self._emit_code("jp      _code_", 0)
        self._emit_code()
        self._emit_code("; TEMPORAL MEMORY AREA, USED TO STORE TEMPORAL VALUES",0)
        self._emit_code("_temp_memory_area_:", 0)
        self._emit_code("_memory_next: dw _memory_start")
        self._emit_code("_memory_start:")
        self._emit_code()
        self._emit_code("; PROGRAM MAIN", 0)
        self._emit_code(f"org     {hex(self.org)}", 0)
        self._emit_code()
        self._emit_code("_code_:", 0)
        self._emit_data("_data_:", 0)

    def _emit_code_end(self):
        self._emit_code()
        self._emit_code("_end_: jr _end_   ; infinite end loop", 0)

    def _emit_global_symbols(self):
        for sym in self.symtable.syms:
            entry = self.symtable.syms[sym]
            if entry.symtype == SymType.Variable:
                if entry.exptype == AST.ExpType.Integer:
                    self._emit_data(f"{entry.label}: dw   0")
                if entry.exptype == AST.ExpType.String:
                    self._emit_data(f"{entry.label}: defs 255")
                if entry.exptype == AST.ExpType.Real:
                    self._emit_data(f"{entry.label}: defs 5")
     
    def _emit_runtime(self) -> str:
        return "__runtime__:\n\n" + ''.join(self.rtcode) + '\n'
    
    def _real(self, n: float) -> bytearray:
        """
        In Amstrad BASIC, a floating point number is stored in base-2 in a normalized form 1 x 2 ** <exp>
        The representation uses 5 bytes stored using the following structure:
        | M (31-24) | M	(23-16) | M	(15-8) | sign + M (7-0) | exponent |
        The exponent is 8-bit an uses a bias of 128 (128-255 possitive, 0-127 negative)
        """
        sign = '1' if n < 0 else '0'
        exp = 0
        prec = abs(n)
    
        while prec >= 1:
            exp = exp + 1
            prec = prec / 2.0
        while 0 < prec < 0.5:
            prec = prec * 2
            exp = exp - 1

        exp = 0 if exp == 0 else exp + 128
        bit = 0
        mant = ""
        for i in range(32):
            prec = prec - bit
            prec = prec * 2
            bit = int(prec)
            mant = mant + str(bit)
        # round values last bit
        if prec > 0.5: mant = mant[:-1] + '1'
        # is normalized so drop first bit and used it for sign
        mant = sign + mant[1:]
        real = bytearray(int(mant, 2).to_bytes(4, byteorder='little'))
        real.extend(exp.to_bytes(1, 'little'))
        return real

    # ----------------- Label generation -----------------

    def _get_linenum_label(self, num: int) -> str:
        return f"__line_{num}"

    def _get_conststr_label(self) -> str:
        self.constants +=1
        return f"__const_str_{self.constants}"
        
    def _get_constreal_label(self) -> str:
        self.constants +=1
        return f"__const_real_{self.constants}"
    
    def _get_for_labels(self) -> tuple[str,str]:
        self.constants +=1
        return (f"__forloop_start_{self.constants}", f"__forloop_end_{self.constants}")

    def _get_while_labels(self) -> tuple[str,str]:
        self.constants +=1
        return (f"__whileloop_start_{self.constants}", f"__whileloop_end_{self.constants}")

    def _get_if_labels(self) -> tuple[str,str]:
        self.constants +=1
        return (f"__if_else_{self.constants}", f"__if_end_{self.constants}")

    # ----------------- Error management -----------------

    def _raise_error(self, codenum: int, node: AST.ASTNode, info: str = ""):
        codeline = self.source[node.line - 1]
        raise BasError(
            codenum,
            codeline.source,
            codeline.code,
            codeline.line,
            node.col,
            info
        ) 

    def _raise_warning(self, level: int, msg: str, node: AST.ASTNode):
        if self.warning_level < 0 or self.warning_level >= level:
            # tokens start line counting in 1
            codeline = self.source[node.line - 1]
            print(f"[WARNING] {codeline.source}:{codeline.line}:{node.col}: {msg} in {codeline.code}")

    # ----------------- Commands and Functions -----------------

    def _emit_ABS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_AFTER(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ASC(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ATN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_AUTO(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_BINSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_BORDER(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CALL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CAT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CHAIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CHAIN_MERGE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CHRSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CINT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CLEAR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CLEAR_INPUT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CLG(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CLOSEIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CLOSEOUT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CLS(self, node:AST.Command):
        self._emit_code("; CLS")
        if len(node.args):
            self._emit_expression(node.args[0])
            self._emit_stream()
        self._emit_code(f"call    {RT_FWCALL.TXT_CLEAR_WINDOW} ; TXT_CLEAR_WINDOW")

    def _emit_CONT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_COPYCHRSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_COS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CREAL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_CURSOR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DATA(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DECSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEF(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEFINT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEFREAL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEFSTR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEF_FN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DEG(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DELETE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DERR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DI(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DIM(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DRAW(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_DRAWR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_EDIT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_EI(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ELSE(self, node:AST.Statement):
        if len(self.ifblocks) > 0:
            # IFEND will remove from the queue
            ifnode = self.ifblocks[-1]
            self._emit_code(f"jp      {ifnode.end_label}")
            self._emit_code("; ELSE")
            self._emit_code(ifnode.else_label, 0)
        else:
            self._raise_error(37, node)

    def _emit_END(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ENT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ENV(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_EOF(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ERASE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ERL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ERR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ERROR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_EVERY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_EXP(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_FILL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_FIX(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_FN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_FOR(self, node:AST.ForLoop):
        sym = self.symtable.find(node.var.name)
        start, end = self._get_for_labels()
        node.start_label = start
        node.end_label = end
        if sym is not None:
            self._emit_code("; FOR initialization")
            self._emit_expression(node.start)
            self._emit_code(f"ld    ({sym.label}),hl")
            if node.step is not None:
                self._emit_code("; STEP precalculation")
                self._emit_expression(node.step)
                self._emit_code("ld      c,l")
                self._emit_code("ld      b,h")
            self._emit_code("; FOR condition")
            self._emit_code(start, 0)
            self._emit_expression(node.end)
            self._emit_code(f"ld      de,({sym.label})")
            self._emit_code("or      a")
            if node.step is not None:
                self._emit_code("; check STEP sign")
                self._emit_code("bit     7,b")
                self._emit_code("jr      z,$+3")
                self._emit_code("ex      de,hl")
            self._emit_code("sbc     hl,de")
            self._emit_code(f"jp      m,{end}")
            if node.step is not None:
                self._emit_code("push    bc")
            self._emit_code("; FOR body")
            node.var_label = sym.label
            self.forloops.append(node)
        else:
            self._raise_error(2, node, "undeclared variable {var.name}")

    def _emit_FRAME(self, node:AST.Statement):
        self._emit_code("\t; FRAME")
        self._emit_code(f"\tcall    {RT_FWCALL.MC_WAIT_FLYBACK} ; MC_WAIT_FLYBACK")

    def _emit_FRE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_GOSUB(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_GOTO(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_GRAPHICS_PAPER(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_GRAPHICS_PEN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_HEXSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_HIMEM(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_IF(self, node:AST.If):
        elselabel, endlabel = self._get_if_labels()
        node.else_label = elselabel
        node.end_label = endlabel
        self._emit_code(";IF condition")
        self._emit_expression(node.condition)
        self._emit_code("ld      a,h")
        self._emit_code("or      a")
        if node.has_else:
            self._emit_code(f"jp      z,{elselabel}")
        else:
            self._emit_code(f"jp      z,{endlabel}")
        self._emit_code("; THEN")
        if len(node.inline_then):
            for stmt in node.inline_then:
                self._emit_statement(stmt)
                if node.has_else:
                    self._emit_code(f"jp      {endlabel}")
            if len(node.inline_else):
                self._emit_code("; ELSE")
                self._emit_code(elselabel, 0)
                for stmt in node.inline_else:
                    self._emit_statement(stmt)
            self._emit_code("; IF end")
            self._emit_code(endlabel, 0)
        else:
            self.ifblocks.append(node)

    def _emit_IFEND(self, node:AST.BlockEnd):
        if len(self.ifblocks) > 0:
            ifnode = self.ifblocks.pop()
            self._emit_code("; IF end")
            self._emit_code(ifnode.end_label, 0)
        else:
            self._raise_error(36, node)

    def _emit_INK(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_INKEY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_INKEYSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_INP(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_INPUT(self, node:AST.Input):
        self._emit_import(RT_STDIO, "rt_input")
        self._emit_import(RT_STDIO, "rt_print")
        self._emit_code("; INPUT")
        if node.stream is not None:
            self._emit_stream()
        if node.prompt != "":
            self._print_str(AST.String(value=node.prompt))
        if node.question:
            self._emit_code("ld      hl,rt_input_question")
            self._emit_code("call    rt_print_str")
        # Ask for values and check that we get as many values as variables
        inputs = len(node.vars)
        lstart, lend = self._get_while_labels()
        self._emit_code(lstart, 0)
        self._emit_code("call    rt_input")
        self._emit_code("ld      a,c   ; check all quoted strings are terminated")
        self._emit_code("and     &01   ; the count must be even so A turns 0")
        self._emit_code("add     b     ; number of substrings")
        self._emit_code(f"cp      {inputs} ; number of given variables")
        self._emit_code(f"jr      z,{lend}")
        self._emit_code("ld      hl,rt_input_redo")
        self._emit_code("call    rt_print_str")
        self._emit_code(f"jr      {lstart}")
        self._emit_code(lend, 0)
        self._emit_code("ld      hl,rt_input_buf")
        for v in node.vars:
            self._emit_code("call    rt_extract_substrz")
            var = self.symtable.find(v.name)
            if var is not None:
                self._emit_code("push    hl  ; current position in input buffer")
                if v.etype == AST.ExpType.String:
                    self._emit_input_str(v, var)
                elif v.etype == AST.ExpType.Integer:
                    self._emit_input_int(v, var)
                elif v.etype == AST.ExpType.Real:
                    self._emit_input_real(v, var)
                self._emit_code("pop     hl  ; ready for next substring")
    
    def _emit_input_str(self, v:AST.Variable, var: SymEntry):
        self._emit_code(f"; string variable {v.name}")
        self._emit_code("ld      de,rt_substrz_buf")
        self._emit_code(f"ld      hl,{var.label}")
        self._emit_code("ld      (hl),c  ; string len")
        self._emit_code("inc     hl")
        self._emit_code("ex      de,hl")
        self._emit_code("ld      b,0")
        self._emit_code("ldir")

    def _emit_input_int(self, v:AST.Variable, var: SymEntry):
        self._emit_import(RT_STR, "rt_strz2int")
        self._emit_import(RT_STR, "rt_strz2hex")
        self._emit_code(f"; integer variable {v.name}")
        self._emit_code("ld      de,rt_substrz_buf")
        self._emit_code("call    rt_extract_num")
        self._emit_code(f"ld      ({var.label}),hl")

    def _emit_input_real(self, v:AST.Variable, var: SymEntry):
        self._emit_code(f"; real variable {v.name}")
        self._raise_error(2, v, 'float numbers in INPUT are not supported yet')

    def _emit_INSTR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_INT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_JOY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_KEY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_KEY_DEF(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LEFTSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LEN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LET(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LINE_INPUT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LIST(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LOAD(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LOCATE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LOG(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LOG10(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_LOWERSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MASK(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MAX(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MEMORY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MERGE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MIDSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MODE(self, node:AST.Command):
        self._emit_code("; MODE")
        self._emit_expression(node.args[0])
        self._emit_code("ld      a,l")
        self._emit_code(f"call    {RT_FWCALL.SCR_SET_MODE} ; SCR_SET_MODE")

    def _emit_MOVE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_MOVER(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_NEW(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_NEXT(self, node:AST.BlockEnd):
        fornode = self.forloops.pop()
        self._emit_code("; FOR STEP")
        if fornode.step is not None:
            self._emit_code("pop     bc")
            self._emit_code(f"ld      hl,({fornode.var_label})")
            self._emit_code("add     hl,bc")
            self._emit_code(f"ld      ({fornode.var_label}),hl")
        else:
            self._emit_code(f"ld      hl,({fornode.var_label})")
            self._emit_code("inc     hl")
            self._emit_code(f"ld      ({fornode.var_label}),hl")
        self._emit_code(f"jp      {fornode.start_label}")
        self._emit_code(fornode.end_label, 0)

    def _emit_ON(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ON_BREAK(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ON_ERROR_GOTO(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ON_SQ(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_OPENIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_OPENOUT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ORIGIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_OUT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PAPER(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PEEK(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PEN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PI(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PLOT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PLOTR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_POKE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_POS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_PRINT(self, node:AST.Print):
        if node.stream is not None:
            self._emit_expression(node.stream)
            self._emit_stream()
        for item in node.items:
            if item.etype == AST.ExpType.String:
                self._print_str(item)
            elif item.etype == AST.ExpType.Integer:
                self._print_int(item)
            elif item.etype == AST.ExpType.Real:
                self._print_real(item)
            elif isinstance(item, AST.Separator):
                self._print_separator(item)
            else:
                self._raise_error(2, item, 'print item not supported yet')
        if node.line:
            self._print_newline()

    def _print_str(self, item:AST.Statement):
        self._emit_import(RT_STDIO, "rt_print")
        self._emit_code("; PRINT string item")
        self._emit_expression(item)
        self._emit_code("call    rt_print_str")

    def _print_int(self, item:AST.Statement):
        self._emit_import(RT_MATH, "rt_div16_by10")
        self._emit_import(RT_STDIO, "rt_print")
        self._emit_import(RT_STR, "rt_int2str")
        self._emit_code("; PRINT int item")
        self._emit_expression(item)
        self._emit_code("call    rt_int2str")
        self._emit_code("call    rt_print_str")
    
    def _print_real(self, item:AST.Statement):
        self._raise_error(2, item, "printing reals is not supported")

    def _print_separator(self, item:AST.Separator):
        self._emit_code(f"; PRINT separator [{item.sym}]")
        if item.sym == ',':
            # TODO: do not use fix spaces
            self._emit_import(RT_STDIO, "rt_print")
            self._emit_code("ld      l,4")
            self._emit_code("call    rt_print_spc")

    def _print_newline(self) -> None:
        self._emit_import(RT_STDIO, "rt_print")
        self._emit_code("; new line")
        self._emit_code("call    rt_print_nl")

    def _emit_RAD(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RANDOMIZE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_READ(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RELEASE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_REMAIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RENUM(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RESTORE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RESUME(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RETURN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RIGHTSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RND(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ROUND(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_RUN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SAVE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SGN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SIN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SOUND(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SPACESS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SPC(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SPEED_INK(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SPEED_KEY(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SPEED_WRITE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SQ(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SQR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_STOP(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_STRINGSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_STRSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SYMBOL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_SYMBOL_AFTER(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TAB(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TAG(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TAGOFF(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TAN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TEST(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TESTR(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_THEN(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TIME(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TROFF(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_TRON(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_UNT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_UPPERSS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_VAL(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_VPOS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_WAIT(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_WEND(self, node:AST.Statement):
        wnode = self.wloops.pop()
        self._emit_code(f"jp      {wnode.start_label}")
        self._emit_code(wnode.end_label, 0)

    def _emit_WHILE(self, node:AST.WhileLoop):
        start, end = self._get_while_labels()
        node.start_label = start
        node.end_label = end
        self._emit_code("; WHILE condition")
        self._emit_code(start, 0)
        self._emit_expression(node.condition)
        self._emit_code("ld      a,h")
        self._emit_code("or      a")
        self._emit_code(f"jp      z,{end}")
        self._emit_code("; WHILE BODY")
        self.wloops.append(node)
    
    def _emit_WIDTH(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_WINDOW(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_WINDOW_SWAP(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_WRITE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_XPOS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_YPOS(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    def _emit_ZONE(self, node:AST.Statement):
        self._raise_error(2, node, 'not implemented yet')

    # ----------------- Expressions -----------------

    def _emit_expression(self, node: AST.Statement):
        if isinstance(node, AST.Integer):
            self._emit_code(f"ld      hl,{node.value & 0xFFFF}")
        elif isinstance(node, AST.String):
            self._emit_const_str(node)
        elif isinstance(node, AST.Real):
            self._emit_const_real(node)
        elif isinstance(node, AST.Variable):
            self._emit_variable(node)
        elif isinstance(node, AST.BinaryOp):
            self._emit_binaryop(node)
        elif isinstance(node, AST.UnaryOp):
            self._emit_unaryop(node)
        else:
            self._raise_error(2, node, 'not implemented yet')

    def _emit_const_str(self, node: AST.String):
        label = self._get_conststr_label()
        self._emit_code(f"ld      hl,{label}")
        self._emit_data(f'{label}: db {len(node.value)},"{node.value}"')

    def _emit_const_real(self, node: AST.Real):
        label = self._get_constreal_label()
        self._emit_code(f"ld      hl,{label}")
        cpcreal = self._real(node.value)
        values = ""
        for b in cpcreal:
            values = values + f'&{b:02X},'
        # send code without last ','
        self._emit_data(f'{label}: db {values[:-1]}')

    def _emit_variable(self, node: AST.Variable):
        var = self.symtable.find(node.name)
        if var is not None:
            if node.etype == AST.ExpType.Integer:  
                self._emit_code(f"ld      hl,({var.label})")
            elif node.etype == AST.ExpType.String:
                self._emit_code(f"ld      hl,{var.label}")
            elif node.etype == AST.ExpType.Real:
                self._emit_code(f"ld      hl,{var.label}")
            else:
                self._raise_error(2, node, 'var type not implemented yet')
        else:
            self._raise_error(38, node)
    
    def _emit_binaryop(self, node: AST.BinaryOp):
        """ 
        Develops right side and pushes the result, develops left 
        and leaves it in HL
        """
        self._emit_expression(node.right)
        self._emit_code("push    hl")
        self._emit_expression(node.left)
        self._emit_code("pop     de")
        if node.etype == AST.ExpType.Integer:
            self._emit_int_op(node)
        elif node.etype == AST.ExpType.String:
            self._emit_str_op(node)
        elif node.etype == AST.ExpType.Real:
            self._emit_real_op(node)
        else:
            self._raise_error(2, node, f'{node.etype} operations are not supported yet')
    
    def _emit_unaryop(self, node: AST.UnaryOp):
        self._emit_expression(node.operand)
        if node.etype == AST.ExpType.Integer:
            if node.op == 'NOT':
                self._emit_code("ex      de,hl")
                self._emit_code("ld      hl,&FFFF")
                self._emit_code("ld      a,d")
                self._emit_code("or      e")
                self._emit_code("jr      z,$+3")
                self._emit_code("inc     hl")
            elif node.op == '-':
                self._emit_code("ld      de,0")
                self._emit_code("ex      de,hl")
                self._emit_code("xor     a       ; clear C flag")
                self._emit_code("sbc     hl,de")
            else:
                self._raise_error(2, node, f"integer '{node.op}' unary op is not supported yet")
        else:
            self._raise_error(2, node, f'{node.etype} unary operations are not supported yet')

    def _emit_int_op(self, node: AST.BinaryOp):
        op = node.op.upper()
        if op == '+':
            self._emit_code("add     hl,de")
        elif op == '-':
            self._emit_code("or      a      ; clear carry")
            self._emit_code("sbc     hl,de  ; HL = right - left")
        elif op == '*':
            self._emit_import(RT_MATH, "rt_compute_sign")
            self._emit_import(RT_MATH, "rt_sign_strip")
            self._emit_import(RT_MATH, "rt_umul16")
            self._emit_import(RT_MATH, "rt_mul16")
            self._emit_code("call   rt_mul16 ; HL = HL * DE")
        elif op == '\\':
            self._emit_import(RT_MATH, "rt_compute_sign")
            self._emit_import(RT_MATH, "rt_sign_strip")
            self._emit_import(RT_MATH, "rt_udiv16")
            self._emit_import(RT_MATH, "rt_div16")
            self._emit_code("call     rt_div16 ; HL = HL \\ DE ")
        elif op == '/':
            self._raise_error(2, node, 'real div is not supported yet')
        elif op in ('=', '<>', '<', '<=', '>', '>='):
            self._emit_int_compare(node)
        else:
            self._raise_error(2, node, f'unknown "{op}" int op')
    
    def _emit_str_op(self, node: AST.BinaryOp):
        op = node.op.upper()
        if op == '+':
            self._emit_import(RT_STR, "rt_straddlengths")
            self._emit_import(RT_STR, "rt_strcopy")
            self._emit_import(RT_STR, "rt_strcat")
            self._emit_code("push    de")
            self._emit_code("ex      de,hl")
            self._reserve_memory(255)
            self._emit_code("call    rt_strcopy ; (HL) <- (DE)")
            self._emit_code("pop     de")
            self._emit_code("call    rt_strcat  ; (HL) <- (HL) + (DE)")
        else:
            self._raise_error(2, node, f'unknown "{op}" string op')

    def _emit_real_op(self, node: AST.BinaryOp):
        self._raise_error(2, node, 'real operations are not supported yet')

    def _emit_int_compare(self, node: AST.BinaryOp):
        if node.left.etype == AST.ExpType.String:
            self._emit_str_compare(node)
            return
        if node.op == '=':
            self._emit_code("xor     a         ; Clear C flag")
            self._emit_code("sbc     hl,de")
            self._emit_code("ld      hl,&FFFF  ; HL = -1 TRUE")
            self._emit_code("jr      z,$+3")
            self._emit_code("inc     hl        ; HL = 0 FALSE")
        elif node.op == '<>':
            self._emit_code("xor     a         ; Clear C flag")
            self._emit_code("sbc     hl,de")
            self._emit_code("ld      hl,&FFFF  ; HL = -1 TRUE")
            self._emit_code("jr      nz,$+3")
            self._emit_code("inc     hl        ; HL = 0 FALSE")
        elif node.op == '<':
            self._emit_import(RT_MATH, "rt_comp16")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,&FFFF  ; HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl        ; HL = 0 FALSE")
        elif node.op == '>':
            self._emit_import(RT_MATH, "rt_comp16")
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,&FFFF  ; HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl        ; HL = 0 FALSE")
        elif node.op == '<=':
            self._emit_import(RT_MATH, "rt_comp16")
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,0      ; HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl        ; HL =-1 TRUE")
        elif node.op == '>=':
            self._emit_import(RT_MATH, "rt_comp16")
            self._emit_code("call    rt_comp16")
            self._emit_code("ld      hl,0      ; HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl        ; HL =-1 TRUE")
        else:
            self._raise_error(2, node, f'int "{node.op}" op not implemented yet')

    def _emit_str_compare(self, node: AST.BinaryOp):
        self._emit_import(RT_STR, "rt_strcmp")
        if node.op == '=':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF  ; HL = -1 TRUE")
            self._emit_code("jr      z,$+3")
            self._emit_code("inc     hl        ; HL = 0 FALSE")
        elif node.op == '<>':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF  ; HL = -1 TRUE")
            self._emit_code("jr      nz,$+3")
            self._emit_code("inc     hl        ; HL = 0 FALSE")
        elif node.op == '<':
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF  ; HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl        ; HL = 0 FALSE")
        elif node.op == '>':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,&FFFF  ; HL =-1 TRUE")
            self._emit_code("jr      c,$+3")
            self._emit_code("inc     hl        ; HL = 0 FALSE")
        elif node.op == '<=':
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,0      ; HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl        ; HL =-1 TRUE")
        elif node.op == '>=':
            self._emit_code("ex      de,hl")
            self._emit_code("call    rt_strcmp")
            self._emit_code("ld      hl,0      ; HL = 0 FALSE")
            self._emit_code("jr      c,$+3")
            self._emit_code("dec     hl        ; HL =-1 TRUE")
        else:
            self._raise_error(2, node, f'string "{node.op}" op not implemented yet')

    def _emit_stream(self) -> None:
        """
        0-7 keyboard to screen
        8   keyboard to printer
        9   channel to file
        """
        self._emit_code("; SET STREAM")
        self._emit_code("ld      a,l")
        self._emit_code("and     &0F   ; valid stream range 0-9")
        self._emit_code(f"call    {RT_FWCALL.TXT_STR_SELECT} ; TXT_STR_SELECT")

    # ----------------- AST Trasversal functions -----------------

    def _emit_comment(self, node: AST.Comment):
        pass

    def _emit_assigment(self, node: AST.Assignment):
        var = self.symtable.find(node.target.name) # type: ignore[attr-defined]
        if var is not None:
            self._emit_expression(node.source)
            if var.exptype == AST.ExpType.Integer:
                self._emit_code(f"ld      ({var.label}),hl")
            elif var.exptype == AST.ExpType.Real:
                self._emit_code("ld      b,0")
                self._emit_code("ld      c,5")
                self._emit_code(f"ld      de,{var.label}")
                self._emit_code("ldir")
            elif var.exptype == AST.ExpType.String:
                self._emit_code("ld      b,0")
                self._emit_code("ld      c,(hl)")
                self._emit_code("inc     c")
                self._emit_code(f"ld      de,{var.label}")
                self._emit_code("ldir")
            else:
                self._raise_error(2, node, f'variable type not implemented yet')
        else:
            self._raise_error(38, node)

    def _emit_blockend(self, node: AST.BlockEnd):
        if node.name == "NEXT":
            self._emit_NEXT(node)
        elif node.name == "WEND":
            self._emit_WEND(node)
        elif node.name == "ELSE":
            self._emit_ELSE(node)
        elif node.name == "IFEND":
            self._emit_IFEND(node)
        else:
            self._raise_error(2, node, "not implemented yet")

    def _emit_userfun(self, node: AST.UserFun):
        self._raise_error(2, node, "not implemented yet")

    def _emit_function(self, node: AST.Function):
        keyword = node.name
        funcname = "_emit_" + keyword.replace('$','SS').replace(' ', '_')
        emit_keyword = getattr(self, funcname , None)
        if emit_keyword is None:
            self._raise_error(2, node, f", unknown keyword {keyword}")
        return emit_keyword(node) # type: ignore[misc]

    def _emit_command(self, node: AST.Command):
        keyword = node.name
        funcname = "_emit_" + keyword.replace('$','SS').replace(' ', '_')
        emit_keyword = getattr(self, funcname , None)
        if emit_keyword is None:
            self._raise_error(2, node, f", unknown keyword {keyword}")
        return emit_keyword(node) # type: ignore[misc]

    def _emit_statement(self, stmt: AST.Statement):
        if isinstance(stmt, AST.Comment):
            self._emit_comment(stmt)
        elif isinstance(stmt, AST.Assignment):
            self._emit_assigment(stmt)
        elif isinstance(stmt, AST.If):
            self._emit_IF(stmt)
        elif isinstance(stmt, AST.ForLoop):
            self._emit_FOR(stmt)
        elif isinstance(stmt, AST.WhileLoop):
            self._emit_WHILE(stmt)
        elif isinstance(stmt, AST.BlockEnd):
            self._emit_blockend(stmt)
        elif isinstance(stmt, AST.Print):
            self._emit_PRINT(stmt)
        elif isinstance(stmt, AST.Input):
            self._emit_INPUT(stmt)
        elif isinstance(stmt, AST.LineInput):
            self._emit_LINE_INPUT(stmt)
        elif isinstance(stmt, AST.Write):
            self._emit_WRITE(stmt)
        elif isinstance(stmt, AST.DefFN):
            self._emit_DEF_FN(stmt)
        elif isinstance(stmt, AST.UserFun):
            self._emit_userfun(stmt)
        elif isinstance(stmt, AST.Function):
            self._emit_function(stmt)
        elif isinstance(stmt, AST.Command):
            self._emit_command(stmt)
        else:
            self._raise_error(2, stmt, "unexpected statement")

    def _emit_line(self, line: AST.Line):
        self._emit_line_label(line)
        for stmt in line.statements:
            self._emit_statement(stmt)
        self._emit_free_mem()

    def emit_program(self) -> str:
        print("Generating assembly code...")
        self.asm = ""
        self._emit_head()
        for line in self.program.lines:
            self._emit_line(line)
        self._emit_code_end()
        self._emit_global_symbols()
        return self.code + "\n" + self.data + "\n" + self._emit_runtime()